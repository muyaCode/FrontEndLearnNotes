import{_ as i,c as p,o as u,ah as e}from"./chunks/framework.DqD713j2.js";const h=JSON.parse('{"title":"JavaScript 基础","description":"","frontmatter":{},"headers":[],"relativePath":"Document/JavaScript笔记/JavaScript基础/JavaScript基础.md","filePath":"Document/JavaScript笔记/JavaScript基础/JavaScript基础.md","lastUpdated":1750954157000}'),t={name:"Document/JavaScript笔记/JavaScript基础/JavaScript基础.md"};function o(a,l,n,r,s,c){return u(),p("div",null,l[0]||(l[0]=[e(`<h1 id="javascript-基础" tabindex="-1">JavaScript 基础 <a class="header-anchor" href="#javascript-基础" aria-label="Permalink to &quot;JavaScript 基础&quot;">​</a></h1><p>JavaScript 介绍：</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Language_Overview#functions" target="_blank" rel="noreferrer">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Language_Overview#functions</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript" target="_blank" rel="noreferrer">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript</a></li></ul><p><strong>MDN 的 JavaScript 从入门到高级文档</strong>：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript" target="_blank" rel="noreferrer">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript</a></p><p>编程之家 JavaScript 文档：<a href="https://www.jb51.cc/javascript-tutorial/1186430.html" target="_blank" rel="noreferrer">https://www.jb51.cc/javascript-tutorial/1186430.html</a></p><p>JavaScript 菜鸟教程基础文档：<a href="https://www.runoob.com/js/js-tutorial.html" target="_blank" rel="noreferrer">https://www.runoob.com/js/js-tutorial.html</a></p><p>JavaScript 菜鸟教程文档：<a href="https://www.runoob.com/js/js-libraries.html" target="_blank" rel="noreferrer">https://www.runoob.com/js/js-libraries.html</a></p><p>JavaScript 实例：<a href="https://m.runoob.com/js/js-examples.html" target="_blank" rel="noreferrer">https://m.runoob.com/js/js-examples.html</a></p><p>JavaScript 各种对象文档参考：<a href="https://www.runoob.com/jsref/prop-element-classList.html" target="_blank" rel="noreferrer">https://www.runoob.com/jsref/prop-element-classList.html</a></p><p>腾讯复制 MDN 的 JavaScript 文档：<a href="https://www.apiref.com/javascript-zh/index.htm" target="_blank" rel="noreferrer">https://www.apiref.com/javascript-zh/index.htm</a></p><p><a href="https://juejin.cn/post/7345775192260755497" target="_blank" rel="noreferrer">不知道，但是可能超有用的 Web API - 掘金 (juejin.cn)</a></p><hr><p>基础练习作业：</p><p>1.通过 concat 方法实现&quot;abc&quot;,&quot;def&quot;,&quot;hij&quot;的字符串的拼接----&gt;输出结果为:&quot;abcdefhij&quot;</p><p>2.通过 indexOf 方法实现&quot;what are you no sha lei&quot; 每个字符串的出现的次数</p><p>3.通过 replace 方法实现 &quot;小苏好帅&quot; 替换成 &quot;小杨好帅&quot;</p><p>4.通过 split 方法实现 &quot;小明|小红|小丽|小白&quot; 该字符串去掉|</p><p>5.通过 substr 方法实现 &quot;十一这个假期作业好少啊&quot; 该字符串最终的截取结果为:----&gt;&quot;作业好少啊&quot;</p><p>6.通过 every 方法实现[1000,1500,2500,3000]该数组中是否所有的工资都大于 2000,</p><p>7.通过 filter 方法实现筛选[0,100,0,200,300,500,0]把数组中不是 0 的数字组成一个新的数组</p><p>8.扩展题:可以查询 MDN 实现,请把下面这个数组中的数据通过 sort 方法进行排序[&quot;adf&quot;,&quot;abdc&quot;,&quot;abc&quot;,&quot;abtg&quot;]</p><p>9.通过 join 方法实现数组中每个元素中间有一个|最终组成一个新的字符串并输出,数组如下:[&quot;小明&quot;,&quot;小红&quot;,&quot;小白&quot;,&quot;小黑&quot;]</p><p>10.通过 slice 方法把该数组[10,20,30,40,50,60,70]中 30,40,50 替换成 300,400,500,最终输出数组的结果为:------&gt;[10,20,300,400,500,60,70]</p><p>11.模拟百度搜索案例</p><p>12.通过三种方式创建下面的对象(属性和方法都需要写出来) 一辆黑色的奔驰车是四个轮子,该车的重量是 500kg,这辆车今天载了两个人在大街上以 120/h 的速度狂奔</p><p>13.动物都有名字,性别,年龄,动物都有打招呼,还有吃和玩的行为,小狗经常咬人,小猫经常抓老鼠,请创建对象及调用方法,并且通过原型添加方法,实现继承</p><p>14.把文件夹中的扩展作业抄写一遍</p><p>15.把文件夹中验证帐号和密码登录实现代码抄写一遍</p><p>16.把文件夹中完整本祝福墙代码抄写一遍(innerHTML 后面的大量字符串拼接可直接复制)</p><p>17.把解析 URL 中的字符串代码抄写一遍</p><p>18.把 JS 高级第一天的面向对象的案例抄写一遍</p><p>19.把文件夹中点赞案例抄写一遍</p><p>20.把文件夹中表格排序案例抄写一遍</p><p>21 为同一个元素注册不同的事件,指向相同的事件处理函数</p><h2 id="js-基础" tabindex="-1">JS 基础 <a class="header-anchor" href="#js-基础" aria-label="Permalink to &quot;JS 基础&quot;">​</a></h2><h3 id="javascript-的应用" tabindex="-1">JavaScript 的应用 <a class="header-anchor" href="#javascript-的应用" aria-label="Permalink to &quot;JavaScript 的应用&quot;">​</a></h3><ul><li><p>前端</p><ul><li>子主题 1</li></ul></li><li><p>后端</p><ul><li>node.js</li></ul></li><li><p>移动端</p></li><li><p>PC 端</p></li><li><p>游戏</p></li></ul><h3 id="javascript-的组成" tabindex="-1">JavaScript 的组成 <a class="header-anchor" href="#javascript-的组成" aria-label="Permalink to &quot;JavaScript 的组成&quot;">​</a></h3><ul><li><p>ECMAScript</p><ul><li>JavaScript 的语法标准规范</li></ul></li><li><p>BOM</p><ul><li>JavaScript 操作浏览器的部分功能的 API 对象模型</li></ul></li><li><p>DOM</p><ul><li>JavaScript 操作网页上的元素的 API 文档对象模型</li></ul></li></ul><h3 id="javascript-语法规范" tabindex="-1">JavaScript 语法规范 <a class="header-anchor" href="#javascript-语法规范" aria-label="Permalink to &quot;JavaScript 语法规范&quot;">​</a></h3><ul><li><p>行内式</p><ul><li>你们好啊</li></ul></li><li><p>页内式</p><ul><li>alert(&quot;你们好啊&quot;)</li></ul></li><li><p>外链式</p><ul><li><code>&lt;script src=&quot;js/index.js&quot;&gt;&lt;/script&gt;</code></li></ul></li></ul><h3 id="javascript-注释" tabindex="-1">JavaScript 注释 <a class="header-anchor" href="#javascript-注释" aria-label="Permalink to &quot;JavaScript 注释&quot;">​</a></h3><ul><li>双斜杠 // 后的内容将会被浏览器忽略： <ul><li>// 我是注释</li></ul></li></ul><h2 id="javascript-基础语法" tabindex="-1">JavaScript 基础语法 <a class="header-anchor" href="#javascript-基础语法" aria-label="Permalink to &quot;JavaScript 基础语法&quot;">​</a></h2><h3 id="字面量-常量-不可改变的值" tabindex="-1">字面量(常量) (不可改变的值) <a class="header-anchor" href="#字面量-常量-不可改变的值" aria-label="Permalink to &quot;字面量(常量) (不可改变的值)&quot;">​</a></h3><ul><li><p>字符串（String）</p><ul><li>可以使用单引号或双引号: <ul><li>&quot;John Doe&quot; &#39;John Doe&#39;</li></ul></li></ul></li><li><p>表达式</p><ul><li>用于计算： <ul><li>5 + 6 5 * 10</li></ul></li></ul></li><li><p>数组（Array）</p><ul><li>定义一个数组：</li><li>[40, 100, 1, 5, 25, 10]</li></ul></li><li><p>对象（Object）</p><ul><li>定义一个对象：</li><li>let obj = {firstName:&quot;John&quot;, lastName:&quot;Doe&quot;, age:50, eyeColor:&quot;blue&quot;}</li></ul></li><li><p>函数（Function）</p><ul><li>定义一个函数： <ul><li>function myFunction(a, b) { return a * b;}</li></ul></li></ul></li><li><p>布尔常量</p><ul><li><p>false</p></li><li><p>true</p></li></ul></li><li><p>特殊字符</p></li></ul><h3 id="变量" tabindex="-1">变量 <a class="header-anchor" href="#变量" aria-label="Permalink to &quot;变量&quot;">​</a></h3><ul><li><p>变量用于存储数据值。</p></li><li><p>JavaScript 使用关键字 var 来定义变量 使用等号来为变量赋值：</p><ul><li>var x, length x = 5 length = 6</li></ul></li><li><p>变量作用域</p><ul><li><p>块级作用域</p><ul><li>在其他语言中，任何一对花括号的语句都属于一个块 在这中定义的所有变量代码块外都是不可见的</li></ul></li><li><p>全局变量</p><ul><li><p>定义在 script 或者 不属于某个函数的变量</p><ul><li>var str = &#39;&#39;;</li></ul></li><li><p>如果在函数内部没有送申声明的变量，也属于全局变量</p><ul><li>num = 100</li></ul></li></ul></li><li><p>局部变量</p><ul><li><p>定义在函数内部的变量</p></li><li><p>函数的形参也可以是局部变量</p></li></ul></li><li><p>注意</p><ul><li><p>函数内部可以访问到该函数所属的外部作用域的变量（作用域链）</p></li><li><p>不使用 var 声明的变量是全局变量，不推荐使用</p></li><li><p>变量退出作用域之后会销毁，全局变量关闭网页或者浏览器才会销毁</p></li></ul></li><li><p>作用域链相关</p><ul><li><p>其他语言中变量 i 只能在 for 循环内部访问(局部变量)</p></li><li><p>全局变量</p><ul><li><p>var name = &quot;111&quot;; function f(){ name=&quot;222&quot;; } f(); console.log(name);</p><ul><li><p>按从上往下执行</p></li><li><p>输出：222</p></li></ul></li></ul></li><li><p>局部变量，现在函数内部的作用域找变量 name， 如果找到则使用，如果找不到则去父级作用域找 name 变量</p></li><li><p>作用域链</p></li></ul></li><li><p>变量提升</p></li></ul></li></ul><h3 id="关键字和保留字和标识符" tabindex="-1">关键字和保留字和标识符 <a class="header-anchor" href="#关键字和保留字和标识符" aria-label="Permalink to &quot;关键字和保留字和标识符&quot;">​</a></h3><ul><li><p>保留字符</p></li><li><p>关键字</p></li><li><p>标识符</p><ul><li><p>命名要求</p><ul><li><p>1.以字母、下划线或者$符号开头</p></li><li><p>2.由字母、下划线、$符号和数字组成</p></li><li><p>3.不能是 ES 中的关键字和保留字</p></li><li><p>一般采用驼峰命名法</p><ul><li><p>首字母小写，每个单词的开头字母大写，其余字母小写</p></li><li><p>addHa</p></li></ul></li></ul></li><li><p>JS 底层保存标识符时实际上是采用的 Unicode 编码， 所以理论上讲，所有 utf-8 中含有的内容都可以作为标识符</p></li></ul></li></ul><h3 id="unicode-编码表" tabindex="-1">Unicode 编码表 <a class="header-anchor" href="#unicode-编码表" aria-label="Permalink to &quot;Unicode 编码表&quot;">​</a></h3><h3 id="运算符-操作符" tabindex="-1">运算符(操作符) <a class="header-anchor" href="#运算符-操作符" aria-label="Permalink to &quot;运算符(操作符)&quot;">​</a></h3><ul><li><p>运算符</p><ul><li><p>算数运算符</p><ul><li><ul><li>加法</li></ul></li><li><ul><li>减法</li></ul></li><li><ul><li>乘法</li></ul></li><li><p>/ 除法</p></li><li><p>% 系数</p></li><li><p>++ 递加</p></li><li><p>-- 递减</p></li><li><p>(a++,++a)</p></li></ul></li><li><p>赋值运算符</p><ul><li><p>= x = y x = y</p></li><li><p>+= x += y 等同于 x = x + y</p></li><li><p>-= x -= y 等同于 x = x - y</p></li><li><p>_= x _= y 等同于 x = x * y</p></li><li><p>/= x /= y 等同于 x = x / y</p></li><li><p>%= x %= y 等同于 x = x % y</p></li></ul></li><li><p>比较(关系)运算符</p><ul><li><p>== 相等</p><ul><li><p>1.如果两个值的类型不同，则会自动进行类型转换， 将其转换为相同的类型，然后再比较</p></li><li><p>2.undefined 衍生自 null，所以这两个值做相等判断时，会返回 true</p></li><li><p>3.NaN 不和任何值相等，包括它本身</p><ul><li>可以通过 isNaN()函数判断一个值是否为 NaN</li></ul></li></ul></li><li><p>!= 不相等</p><ul><li>1.如果两个值的类型不同，则会自动进行类型转换， 将其转换为相同的类型，然后再比较</li></ul></li><li><p>=== 等值等型(全等)</p><ul><li>全等不会自动类型转换</li></ul></li><li><p>!== 不等值或不等型</p><ul><li>不全等不会自动类型转换</li></ul></li><li><p><code>&gt;</code> 大于</p></li><li><p><code>&lt;</code> 小于</p></li><li><p><code>&gt;=</code> 大于或等于</p></li><li><p><code>&lt;=</code> 小于或等于</p></li><li><p>? 三元(条件)运算符</p><ul><li><p>条件表达式 ？ 语句 1 : 语句 2</p></li><li><p>1.条件运算符执行时，首先对条件表达式进行求值</p></li><li><p>1.1 如果该值为 true，则执行语句 1，并返回执行结果</p></li><li><p>1.2 如果该值为 false，则执行语句 2，并返回执行结果</p></li><li><p>1.3 如果条件表达式的求值结果是一个非布尔值，会先把值转成布尔值，再运算</p></li></ul></li></ul></li><li><p>逻辑运算符</p><ul><li><p>&amp;&amp;</p><ul><li><p>逻辑与</p></li><li><p>非布尔类型会自动转换为布尔类型判断</p></li><li><p>两个值中都为 true 才返回 true，否则返回 false</p></li><li><p>短路与运算</p><ul><li><p>true &amp;&amp; alert(&quot;弹出来了&quot;)</p></li><li><p>第一个为 true，则不会检查第二个值</p></li></ul></li></ul></li><li><p>||</p><ul><li><p>逻辑或</p></li><li><p>两个值中有一个为 true 就返回 true， 两个为 false 才返回 false</p></li><li><p>短路或运算</p><ul><li><p>false &amp;&amp; alert(&quot;123&quot;)</p></li><li><p>第一个为 false，则不会检查第二个值</p></li></ul></li></ul></li><li><p>&amp;&amp; || 非布尔值的情况</p><ul><li><p>会先将其转为布尔值，然后再运算，并且返回原值</p></li><li><p>与运算</p><ul><li><p>true &amp;&amp; true</p><ul><li>与运算：如果第一个值为 true，则返回第二个值</li></ul></li><li><p>false &amp;&amp; true</p><ul><li>与运算：如果第一个值为 false，则返回第一个值</li></ul></li><li><p>false &amp;&amp; false</p><ul><li>与运算：如果两个值都是 false，则返回靠前的 false</li></ul></li></ul></li><li><p>或运算</p><ul><li><p>true || true</p><ul><li>与运算：如果第一个值为 true，则直接返回第一个值</li></ul></li><li><p>false || true</p><ul><li>与运算：如果第一个值为 false，则直接返回第二个值</li></ul></li><li><p>false || false</p><ul><li>与运算：如果两个值都是 false，则返回后面的 false</li></ul></li></ul></li></ul></li><li><p>！</p><ul><li><p>逻辑非</p></li><li><p>所谓非运算就是值对一个布尔值进行取反操作， true 变 false，false 变 true</p></li><li><p>如果对一个值进行两次取反，它不会变化</p></li><li><p>如果对非布尔值进行元素，则会将其他转换为布尔值，然后再取反 所以我们可以利用该特点，将一个其他的数据类型转为布尔值 可以为一个任意数据类型取两次反，来将其转为布尔值 原理和 Boolean()一样</p></li></ul></li></ul></li><li><p>类型运算符</p><ul><li><p>typeof</p><ul><li>返回变量的类型。</li></ul></li><li><p>instanceof</p><ul><li>返回 true，如果对象是对象类型的实例。</li></ul></li></ul></li><li><p>位运算符</p><ul><li><p><code>&amp;</code> 与</p></li><li><p><code>|</code> 或</p></li><li><p><code>~</code> 非</p></li><li><p><code>^</code> 异或</p></li><li><p><code>&lt;&lt;</code> 零填充左位移</p></li><li><p><code>&gt;&gt;</code> 有符号右位移</p></li><li><p><code>&gt;&gt;&gt;</code> 零填充右位移</p></li></ul></li><li><p>逗号运算符</p><ul><li><p>表达式 1,表达式 2,......,表达式 4;</p></li><li><p>var a,b,c</p></li><li><p>var a=1, b=2, c=3</p></li></ul></li><li><p>复合赋值运算符</p><ul><li><p><code>+=</code> 加后赋值 变量+=表达式 如 a+=1; 即 a=a+1</p></li><li><p><code>-=</code> 减后赋值 变量-=表达式 如 a-=1; 即 a=a-1</p></li><li><p><code>*=</code> 乘后赋值 变量 =表达式 如 a=1; 即 a=a*1</p></li><li><p><code>/=</code> 除后赋值 变量/ =表达式 如 a/=1; 即 a=a/1</p></li><li><p><code>%=</code> 取模后赋值 变量%=表达式 如 a%=1; 即 a=a%1</p></li><li><p><code>a *= 1+2</code></p><ul><li>先算右边</li></ul></li></ul></li><li><p>自增自减运算符</p><ul><li><p>自增</p><ul><li><p>i++</p></li><li><p>++i</p></li></ul></li><li><p>自减</p><ul><li><p>i--</p></li><li><p>--i</p></li></ul></li><li><p>后缀表达式</p><ul><li>x++，x-- <ul><li>先用 x 的当前值作为表达式的值，再进行自增自减 1 运算， 即“先用后变”也就是先用变量的值参与运算， 变量的值再进行自增自减变化 <ul><li>var numi = 20, num2 = 30&#39; var res=(num1++) + (num2++); console.log(res);//50 console.log(num1);//21 console.log(num2);//31</li></ul></li></ul></li></ul></li><li><p>前缀表达式</p><ul><li>++x,--x <ul><li>先完成变量的自增自减运算再用 x 的值作为表达式的值； 即“先用后变” 也就是变量的值先变，再用变量的值参与运算。 <ul><li>var numi = 20, num2 = 30&#39; var res=(--num1) + (--num2); console.log(res);//48 console.log(num1);//19 console.log(num2);//29</li></ul></li></ul></li></ul></li></ul></li><li><p>三目(三元)运算符</p><ul><li><p>条件 1?值 1 或操作 1: //如果满足条件 1，就返回值 1 或执行操作 1 条件 2?值 2 或操作 2: //否则，如果满足条件 2，就返回值 2 或执行操作 2 ...?..........: 默认值或操作; //否则，（前边条件都不满足） //执行默认操作，或返回默认值</p></li><li><p>总结：多个条件，多件事，多选一执行。</p></li><li><p>如果操作语句比较简单，建议用三目运算替代 if..else 简化代码 但是使用的前提是要必须有一个确定的结构</p></li></ul></li></ul></li><li><p>运算符的优先级</p><ul><li><p>第一位：<code>. [] ()</code></p><ul><li>字段访问、数组下标、函数调用以及表达式分组</li></ul></li><li><p>第二位：<code>!、-+、++、-- 、 ~ !</code></p><ul><li>一元运算符、返回数据类型、对象创建、未定义值</li></ul></li><li><p>第三位：<code>*、/、%</code></p><ul><li>乘法、除法、取模</li></ul></li><li><p>第四位：+、-</p><ul><li>加法、减法、字符串连接</li></ul></li><li><p>第五位：<code>&lt;、&lt;=、&gt;、&gt;=</code></p><ul><li>小于、小于等于、大于、大于等于、instanceof</li></ul></li><li><p>第六位：<code>==、!=、===、!==</code></p><ul><li>等于、不等于、严格相等、非严格相等</li></ul></li><li><p>第七位：<code>&amp;&amp;</code></p><ul><li>逻辑与</li></ul></li><li><p>第八位：<code>||</code></p><ul><li>逻辑或</li></ul></li><li><p>第九位：<code>?:</code></p><ul><li>条件</li></ul></li><li><p>第十位：<code>=、+=、-=、*=、/=、%=</code></p><ul><li>赋值、运算赋值</li></ul></li><li><p>如果优先级搞不清的，可以通过括号()改变优先级</p></li></ul></li><li><p>结合性</p><ul><li><p>两种结合性</p><ul><li><p>自右向左</p></li><li><p>自左向右</p></li></ul></li></ul></li><li><p>内置方法</p><ul><li><p>数学计算方法：Math</p><ul><li><p>Math.random() 随机数[0,1],不用书写参数</p></li><li><p>Math.pow() 幂的计算：第一个参数：底数 第二个参数：指数</p></li><li><p>Math.sqrt() 计算开方数，只需要书写一个要开方的数</p></li></ul></li></ul></li></ul><h3 id="数据类型" tabindex="-1">数据类型 <a class="header-anchor" href="#数据类型" aria-label="Permalink to &quot;数据类型&quot;">​</a></h3><ul><li><p>数据类型</p><ul><li><p>数字型（Number）</p><ul><li><p>JS 中标识数值的最大值</p><ul><li><p>Number.MAX_VALUE</p></li><li><p>1.7976931348623157e+308</p></li></ul></li><li><p>JS 中标识数值的最小值</p><ul><li><p>Number.MIN_VALUE</p></li><li><p>5e-324</p><ul><li>大于 0 的最小值(正最小值)</li></ul></li></ul></li><li><p>如果使用 Number 表示的数字超过了最大值，则会返回一个 Infinity，表示正无穷</p><ul><li><p>typeof Infinity</p></li><li><p>返回 number</p></li></ul></li><li><p>var a = &quot;aa&quot; * &quot;bb&quot; console.log(typeof a)</p><ul><li><p>返回 NaN</p></li><li><p>NaN 是一个特殊的数字，表示 Not A Number</p></li><li><p>使用 console.log(typeof NaN)</p><ul><li>会输出 number</li></ul></li></ul></li><li><p>浮点数计算精度丢失</p><ul><li><p>var c = 0.1+0.2</p></li><li><p>所以关乎支付的不要用前端 JS 进行计算，要用后端计算</p></li></ul></li></ul></li><li><p>字符串型（String）</p><ul><li><p>转义字符</p></li><li><p>检测获取字符串长度</p><ul><li>str.length</li></ul></li><li><p>字符串的拼接</p><ul><li><p>&#39;我是&#39; + &#39;大佬&#39;</p></li><li><p>+ 号：数值是相加的，字符是相连的</p></li></ul></li></ul></li><li><p>布尔型（boolean）</p><ul><li><p>true</p><ul><li>逻辑真</li></ul></li><li><p>false</p><ul><li>逻辑假</li></ul></li></ul></li><li><p>空（Null）</p><ul><li><p>null</p></li><li><p>专门用来表示空对象</p></li></ul></li><li><p>未定义（Undefined）</p><ul><li><p>undefined</p></li><li><p>当声明一个变量，但未赋值，它的值就是 undefined</p></li></ul></li><li><p>对象（object）</p><ul><li>// Object 通过对象字面量赋值 var person = {firstName:&quot;John&quot;, lastName:&quot;Doe&quot;};</li></ul></li><li><p>数组 Array</p><ul><li>// Array 通过数组字面量赋值 var cars = [&quot;Saab&quot;, &quot;Volvo&quot;, &quot;BMW&quot;];</li></ul></li><li><p>Symbol（ES6）</p></li></ul></li><li><p>数据类型检测</p><ul><li><p>typeof(NaN)</p></li><li><p>typeof NaN</p></li></ul></li><li><p>类型转换</p><ul><li><p>转为字符串型</p><ul><li><p>变量.toString()</p><ul><li><p>a.toString()</p></li><li><p>不适用于 undefined 或 null 值的变量，否则会报错</p></li></ul></li><li><p>String(变量)</p><ul><li>除了常见类型，也可以把 undefined 或 null 值的字面量都转成对应的字符串，也就是全部类型都可以转，建议使用</li></ul></li><li><p>拼接方法 （字符串拼接的数值都变成字符串）</p><ul><li>num + &#39; &#39;</li></ul></li></ul></li><li><p>转换为数字型</p><ul><li><p>Number(变量)</p><ul><li><p>1.如果是纯数字的字符串，则直接将其转换为数字</p></li><li><p>2.如果字符串里面含有非数字的字符，则返回 NaN</p></li><li><p>3.如果是空字符串或全是空格的，则转换为 0</p></li><li><p>4.布尔值 --&gt; 数字</p><ul><li><p>1.如果是布尔值 true，则转为 1</p></li><li><p>2.如果是布尔值 false，则转为 0</p></li></ul></li><li><p>5.如果是 Null --&gt; 数字，则转换成 0</p></li><li><p>6.如果是 undefined --&gt; 数字，则转换成 NaN</p></li></ul></li><li><p>parseInt(变量)</p><ul><li><p>1.把一个字符串转换成整数</p></li><li><p>2.可以将一个字符串中的有效整数内容取出来</p></li><li><p>3.如果对非 String 使用 parseInt()或 parseFloat()，会先将其转成 String，然后再操作</p></li><li><p>4.可以用于数字型的浮点数取整</p></li><li><p>5.可以传递第二个参数，指定进制数</p><ul><li><p>parseInt(&#39;070&#39;,10)</p></li><li><p>转成 10 进制的整数</p></li></ul></li></ul></li><li><p>parseFloat(变量)</p><ul><li><p>1.把一个字符串转换成浮点数</p></li><li><p>2.可以将一个字符串中的有效小数内容取出来</p></li><li><p>3.如果对非 String 使用 parseInt()或 parseFloat()，会先将其转成 String，然后再操作</p></li></ul></li><li><p>算术运算转成数字型 (隐式转换)</p><ul><li><p>- * /</p><ul><li><p>(&#39;12&#39; - 0)</p></li><li><p>(&#39;120&#39; - &#39;110&#39;)</p></li><li><p>(&#39;123&#39; * 1)</p></li></ul></li></ul></li></ul></li><li><p>转换为布尔型</p><ul><li><p>Boolean(变量)</p><ul><li><p>1.当数字 --&gt; boolean： 大于或小于 0 或为 Infinity(无穷大)时都为 ture 等于 0 或 NaN 时则为 false</p></li><li><p>2.当字符串 --&gt; boolean: 除了空字符串&#39;&#39;，其余都是 true</p></li><li><p>3.null 或 undefined --&gt; boolean: 都会转成 false</p></li><li><p>4.对象也会转成 true</p></li></ul></li></ul></li><li><p>toExponential()</p><ul><li>把对象的值转换为指数计数法。</li></ul></li><li><p>toFixed()</p><ul><li>把数字转换为字符串，结果的小数点后有指定位数的数字。</li></ul></li><li><p>toPrecision()</p><ul><li>把数字格式化为指定的长度。</li></ul></li><li><p>基本数据类型转换的注意原理</p><ul><li><p>包装类 String()/Number()/Boolean() 会将基本数据类型转换成 对象 (浏览器底层使用的方法)</p></li><li><p>当我们对一些基本数据类型的值去调用属性和方法时 toString()...， 浏览器会临时使用包装类 String()/Number()/Boolean() 将其转换为对象，然后再调用对象属性和方法</p></li><li><p>调用完以后，再将其转换会基本数据类型</p></li></ul></li></ul></li></ul><h3 id="流程控制语句" tabindex="-1">流程控制语句 <a class="header-anchor" href="#流程控制语句" aria-label="Permalink to &quot;流程控制语句&quot;">​</a></h3><ul><li><p>编程思路</p><ul><li><p>问题：从键盘输入一个整数，判断其是否是偶数，如果是偶数就输出 yes，否则输出 no</p></li><li><p><a href="//1.xn--4gqvdzds2xvxkb45f" target="_blank" rel="noreferrer">//1.定义一个变量</a> var xx; <a href="//2.xn--y5qw32bm5a37bmixa152zvjcs89f" target="_blank" rel="noreferrer">//2.接收用户输入的整数</a> xx = +(window.prompt(&quot;请输入一个整数&quot;)) ; <a href="//2.1" target="_blank" rel="noreferrer">//2.1</a> 把字符串转成数值 <a href="//3.xn--8pry5zh9jz84a8pp" target="_blank" rel="noreferrer">//3.合法性验证</a>，数据安全校验 if(isNaN(xx)){ alert(&quot;输入的内容有误！&quot;)； }else{ <a href="//4.xn--4yqpw2rj8dnv3aqneca2a42c75bba3017blyd794i" target="_blank" rel="noreferrer">//4.判断用户输入的整数是否是偶数</a> if(){ }else{ } }</p><ul><li>哪些数值可以作为变量定义</li></ul></li></ul></li><li><p>结构</p><ul><li><p>顺序结构</p><ul><li>默认的流程结构：按照书写顺序从上到下执行</li></ul></li><li><p>选择结构</p><ul><li>对给定的条件进行判断，在根据判断结构来决定执行那一段代码</li></ul></li><li><p>循环结构</p><ul><li>在给定条件成立的情况下，反复执行某一段代码</li></ul></li></ul></li><li><p>条件判断语句</p><ul><li><p>if...else 语句</p><ul><li>if(条件表达式){ 满足条件执行代码块 }else{ 不满足条件执行代码块 }</li></ul></li><li><p>if(){}else if(){}else{} 语句</p></li><li><p>三元表达式</p><ul><li><p>条件表达式? 值 1 : 值 2；</p></li><li><p>如果表达式真，值取值 1。如果表达式假，结果为值 2</p></li></ul></li><li><p>switch 条件分支语句</p><ul><li><p>switch(表达式){ case 值: 执行体; break; case 值 2: 执行体; break; default: 以上情况都不满足后执行 }</p></li><li><p>同样的输出可以合并</p><ul><li>case 条件 1|| 条件 2 ...: 输出执行语句</li></ul></li><li><p>子主题 3</p></li></ul></li></ul></li><li><p>循环语句</p><ul><li><p>for 循环</p><ul><li><p>循环代码块一定的次数</p><ul><li><p>for (① 初始化表达式,② 循环条件表达式,③ 循环后操作表达式){ 被执行的代码块 }</p><ul><li><code>for (var i=0; i&lt;5; i++){ x=x + &quot;该数字为 &quot; + i + &quot;&quot;; }</code></li></ul></li><li><p><code>for(var i = 1;i&lt; 100;i++){ console.log(i) }</code></p></li><li><p>循环变量 i 是全局变量，可以全局使用</p></li><li><p>for 循环嵌套 if(){}语句</p><ul><li><code>for(var i = 1; i &lt;= 20; i++){ if(i % 5 == 0){ console.log(i) } }</code></li></ul></li><li><p>for 循环嵌套 for 循环</p><ul><li><code>for(var i = 1; i &lt;= 5; i++){ for(var j = 1;j &lt;= 10;j++){ console.log(&#39;i = &#39; + i ,&#39;j = &#39; + j) } }</code></li></ul></li></ul></li><li><p>流程</p><ul><li><p>for 循环开始时，会先执行初始化表达式，而且循环过程中只执行一次初始化表达式</p></li><li><p>接着判断循环条件是否为真，如果条件为真，就会执行循环体中的语句</p></li><li><p>循环体执行完毕后，接下来会执行循环后的操作表达式</p></li><li><p>执行完循环后操作表达式，然后再次判断循环条件表达式是否为真，如果为真，就会执行循环体中的语句</p></li><li><p>重复上述过程，直到条件不成立就结束 for 循环</p></li></ul></li><li><p>注意</p><ul><li>死循环 <ul><li><code>for(;;){}</code></li></ul></li></ul></li><li><p>练习</p><ul><li><p>打印好友列表</p><ul><li><code>for(var i=1;i&lt;=3;i++){ console.log(&quot;好友列表&quot;+i); for(var j=0;j&lt;3;j++){ console.log(&quot; 好友&quot;+j); } }</code></li></ul></li><li><p>循环嵌套：利用“*”绘制矩形</p><ul><li><code>//外循环控制行数 for(var i=0;i&lt;3;i++){ //内循环控制列数 for(var j=0;j&lt;3;j++){ window.document.write(&quot;*&quot;); console.log(&quot;(&quot;+i+&quot;,&quot;+j+&quot;)&quot;); } window.document.write(&quot;&quot;); }</code></li></ul></li><li><p>循环嵌套：利用“*”绘制直角三角形</p><ul><li><code>//外循环控制行数 for(var i=0;i&lt;5;i++){ //内循环控制列数 for(var j=0;j&lt;=i;j++){ window.document.write(&quot;*\\t&quot;); } window.document.write(&quot;&quot;); }</code></li></ul></li><li><p>循环嵌套：利用“*”绘制反直角三角形</p><ul><li><code>//外循环控制行数 for(var i=0;i&lt;5;i++){ //内循环控制列数 for(var j=0;j&lt;=5;j++){ window.document.write(&quot;*\\t&quot;); } window.document.write(&quot;&quot;); }</code></li></ul></li><li><p>循环嵌套：打印数字组成的特殊三角形</p><ul><li><code>for(var i=0;i&lt;3;i++){ for(var j=0;j&lt;=i;j++){ window.document.write(j + 1 + &quot; &quot;); } window.document.write(&quot;&quot;); }</code></li></ul></li><li><p>循环嵌套：打印正三角形</p><ul><li><code>for(var i=0;i&lt;6;i++){ for(var j=0; j&lt;5-i; j++){ window.document.write(&quot;-&quot;); } //主 for(var m=0; m&lt;2*i+1; m++){ window.document.write(&quot;-&quot;); } window.document.write(&quot;&quot;); }</code></li></ul></li><li><p>循环嵌套：打印 99 乘法表</p><ul><li><code>//外循环控制行数 for(var i=0;i&lt;=9;i++){ //内循环控制列数 for(var j=1;j&lt;=i;j++){ document.write(&quot;&quot; + j + &quot;*&quot; + i + &quot;=&quot; + i * j+ &quot;&quot;); } window.document.write(&quot;&quot;); }</code></li></ul></li></ul></li></ul></li><li><p>for/in</p><ul><li>循环遍历对象的属性</li></ul></li><li><p>while 循环</p><ul><li><p>当指定的条件为 true 时循环指定的代码块</p></li><li><p>先判断条件表达式，如果为真，再执行循环语句</p></li><li><p>满足条件才执行</p></li><li><p>while (条件) { 需要执行的代码 }</p><ul><li><code>while (i&lt;5) { x=x + &quot;the number is &quot; + i + &quot;&quot;; i++; }</code></li></ul></li><li><p>注意点</p><ul><li><p>死循环</p><ul><li><p><code>while(true){ alert(&quot;666&quot;); }</code></p></li><li><p><code>while(1);</code></p></li></ul></li></ul></li></ul></li><li><p>do while 循环</p><ul><li><p>同样当指定的条件为 true 时循环指定的代码块</p></li><li><p>无论条件满不满足，先执行一次</p></li><li><p>先执行循环语句，再进行 while 条件表达式，语句至少执行一次</p></li><li><p>do { 需要执行的代码 } while (条件);</p><ul><li><code>do { x=x + &quot;The number is &quot; + i + &quot;&quot;; i++; } while (i&lt;5);</code></li></ul></li></ul></li></ul></li><li><p>break、continue 关键字 （跳出或者结束）</p><ul><li><p>break</p><ul><li><p>结束，中断(终止) 所在层循环语句，不再运行</p></li><li><p>break 关键字 可以用来 退出 switch 或循环语句(for/while)</p></li><li><p>不能单在 if 语句中使用 break 或 continue</p></li><li><p>但是在 for()循环里面的 if()里使用</p><ul><li>for(){ if(){ break; } }</li></ul></li><li><p>或可以通过标签控制结束多层嵌套的指定层循环</p><ul><li>waiceng: for(){ for(){ if(){ break waiceng; } } }</li></ul></li><li><p>会立即终止离他最近的那个循环语句</p></li></ul></li><li><p>continue</p><ul><li><p>continue 关键字结束所在层这次循环，进入下一次循环</p></li><li><p>不能单在 if 语句中使用 continue</p></li><li><p>但是在 for()循环里面的 if()里使用</p><ul><li>for(){ if(){ continue; } }</li></ul></li><li><p>或可以通过标签控制结束多层嵌套的指定层循环</p><ul><li>waiceng: for(){ for(){ if(){ continue waiceng; } } }</li></ul></li></ul></li></ul></li></ul><h3 id="函数-function" tabindex="-1">函数(Function) <a class="header-anchor" href="#函数-function" aria-label="Permalink to &quot;函数(Function)&quot;">​</a></h3><ul><li><p>JavaScript 语句可以写在函数内，函数可以重复引用：</p></li><li><p>1.函数定义和调用</p><ul><li><p>函数创建方法</p><ul><li><p>1.命名函数(函数声明)</p><ul><li><p>function fn() {};</p></li><li><p>// 调用 fn(); fn.call()</p></li></ul></li><li><p>2.构造函数</p><ul><li><p>function Function() {}</p></li><li><p>// 实例对象调用 var add1 = new Function(&#39;参数 1&#39;，&#39;参数 2&#39;，&#39;函数体&#39;)；</p><ul><li>都要带引号</li></ul></li></ul></li><li><p>3.匿名函数</p><ul><li><p>var fun = function () {}</p></li><li><p>//调用 fun();</p></li></ul></li></ul></li><li><p>所有的函数都是 Function 的实例对象，都有原型对象，对象能干的事函数也能干，万物皆对象</p></li></ul></li><li><p>2.函数的参数</p><ul><li><p>形参</p><ul><li><p>形式上参与运算的变量，无实际值，为实参占位置，就像一个躯壳一样</p></li><li><p>function f(a,b){} //a,b 是形参</p></li></ul></li><li><p>实参</p><ul><li><p>实际参与运算的变量。真实参与运算的变量。</p></li><li><p>f(x,y); //x,y 实参，有具体的值， 会把 x,y 复制一份给函数内部的 a 和 b， 函数内部的值是复制新值，无法修改外部的 x,y</p></li></ul></li><li><p>参数为函数(一个函数式另一个函数的参数)</p><ul><li><p>fun(next())</p><ul><li><p>带()的</p></li><li><p>调用函数</p></li><li><p>相当于使用函数的返回值</p></li></ul></li><li><p>fun(next)</p><ul><li><p>函数对象</p></li><li><p>相当于直接使用函数对象</p></li></ul></li></ul></li><li><p>arguments 对象参数</p><ul><li><p>是个类数组对象，传入所有参数。</p></li><li><p>其包含一个 length 属性， 可以用 arguments.length 来获得传入函数的参数个数。</p></li></ul></li><li><p>注意</p><ul><li>其他语言实参和形参的个数必须一样， 但在 JS 当中没有函数签名的概念， 实参的个数和形参的个数可以不相等</li></ul></li></ul></li><li><p>3.函数返回值(return)</p><ul><li><p>函数执行完毕以后返回的结果</p></li><li><p>1.若在函数中不指定返回值，则会默认返回 undefined；</p></li><li><p>2.return 语句表示从当前函数退出，并从那个函数返回一个值；执行 return 后，后面的程序不会再执行</p></li><li><p>3.若仅仅写一个 return，则也会返回 undefined，且会终止程序；</p></li><li><p>4.return 后可以跟任意类型的数据， 可以是基本数据类型，也可以是对象，甚至是函数；</p></li><li><p>5.当 return 返回是 false 时，也将会中断操作；</p></li><li><p>6.推荐用法：使用 return 要有一个有效的返回值，要不就不要使用 return;</p></li></ul></li><li><p>4.函数声明的提升</p><ul><li><p>JavaScript 解析器首先会把当前作用域的 函数声明提前到整个作用域的最前面。 而表达式不会，要按顺序先声明</p></li><li><p>变量名和函数名相同，优先提升函数名，变量将名字给函数用</p></li></ul></li><li><p>5.函数作用域链</p><ul><li><p>1.函数作用域的基础概念</p><ul><li><p>函数内定义的变量，不能在函数之外的任何地方访问，而这个函数可以访问其范围内的任意变量和函数，以及其父函数有权访问的任何其他变量。</p></li><li><p>函数不仅可以访问自己内部定义的变量，还可以访问外部函数中的变量，以及外部函数的外部函数的变量</p></li></ul></li><li><p>2.特性</p><ul><li><p>函数作用域内，依旧遵从变量提升（包括函数提升）和顺序执行。</p></li><li><p>顺序执行和变量提升</p></li></ul></li><li><p>PS：变量提升是块级作用域和函数作用域的主要区别。</p></li></ul></li><li><p>6.绑定事件函数</p><ul><li><p>btn.onclick = function() {}</p></li><li><p>点击绑定的元素按钮就会调用</p></li></ul></li><li><p>7.定时器函数</p><ul><li><p>定时器语法</p><ul><li><p>let timeId1 = setTimeout(fn,ms)</p><ul><li><p>在指定的毫秒数后调用函数或计算表达式，函数返回一个定时器的 timeId。</p></li><li><p>参数详解</p><ul><li><p>fn: 自定义函数</p></li><li><p>ms: 函数的间隔调用周期，单位：毫秒</p></li></ul></li></ul></li><li><p>let timeId2 = setInterval(fn,ms)</p><ul><li><p>按照指定的周期（以毫秒计）来调用函数或计算表达式，函数返回一个定时器的 timeId。</p></li><li><p>参数详解</p><ul><li><p>fn: 自定义函数</p></li><li><p>ms: 函数的间隔调用周期，单位：毫秒</p></li></ul></li></ul></li><li><p>两种方法差异</p><ul><li><p>setTimeout 调用一次</p></li><li><p>setInterval 调用多次（以周期为单位重复调用）</p></li></ul></li><li><p>取消定时</p><ul><li><p>clearTimeout(timeId1)</p><ul><li>取消由 setTimeout() 方法设置的 timeId。</li></ul></li><li><p>clearInterval(timeId2)</p><ul><li>取消由 setInterval() 设置的 timeId。</li></ul></li></ul></li></ul></li><li><p>应用场景</p><ul><li>一般用于制作动画效果，比如：轮播动画，倒计时跳转页面。</li></ul></li></ul></li><li><p>8.匿名函数</p><ul><li><p>没有命名的函数，创建一块封闭区域</p></li><li><p>作用</p><ul><li><p>用在绑定事件</p><ul><li>document.onclick = function(){ alert(1); }</li></ul></li><li><p>定时器</p><ul><li>setInterval(function(){ console.log(111); },1000);</li></ul></li><li><p>自调用函数</p><ul><li>(function(){alert(&quot;hello&quot;)})();</li></ul></li></ul></li><li><p>function(){}</p></li></ul></li><li><p>9.回调函数</p><ul><li><p>回调函数就是：通过函数调用的函数</p></li><li><p>如果你把函数的指针(地址)作为参数传递带另一个函数， 当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。</p></li><li><p>一般用于递归</p></li><li><p>高阶函数</p><ul><li><p>高阶函数是对其他函数进行操作的函数，它接收函数作为参数或将函数作为返回值输出。</p></li><li><p>function fn(a,b,callback) {callback &amp;&amp; callback();}</p></li><li><p>fn(1,2,function(){})</p></li></ul></li><li><p>案例</p><ul><li><p>求 Fibonacci 的第 n 个数 1,1,2,3,5,8,13</p></li><li><p>求 n 个数的累加 1+2+3+4+5....</p></li><li><p>从前有座山，山里有座庙，......</p></li></ul></li></ul></li><li><p>10.立即执行函数</p><ul><li><p>函数定义完，立即被调用，这种函数叫做立即执行函数</p></li><li><p>两种语法</p><ul><li><p>(function(形参){}(实参))</p></li><li><p>(function(形参){})(实参)</p></li></ul></li><li><p>原理</p></li><li><p>立即执行函数只会执行一次</p></li><li><p>立即执行函数也可以称为小闭包，因为立即执行函数里面的任何一个函数都可以使用它的 i 这变量</p></li></ul></li><li><p>11.递归函数</p><ul><li><p>函数在内部可以调用其本身，那么这个函数就是递归函数 (函数内部自己调用自己，这个函数就是递归函数)</p></li><li><p>递归代码例子</p><ul><li><p>function fn (n) {};fn();</p></li><li><p>递归里面必须加退出条件 ： return; 来防止栈溢出</p></li><li><p>// 递归函数 : 函数内部自己调用自己, 这个函数就是递归函数 var num = 1; function fn() { console.log(&#39;我要打印 6 句话&#39;); if (num == 6) { return; // 递归里面必须加退出条件 } num++; fn(); } fn();</p></li></ul></li><li><p>运用递归例子</p><ul><li><p>利用递归函数求 1-n 的阶乘</p><ul><li><p>// 利用递归函数求 1~n 的阶乘 1 _ 2 _ 3 _ 4 _ ..n function fn(n) { if (n == 1) { return 1; } return n _ fn(n - 1); } console.log(fn(3)); console.log(fn(4)); // 详细思路 假如用户输入的是 3 //return 3 _ fn(2) //return 3 _ (2 _ fn(1)) //return 3 _ (2 _ 1) //return 3 * (2) //return 6</p></li><li><p>// 利用递归函数求斐波那契数列(兔子序列) 1、1、2、3、5、8、13、21... // 用户输入一个数字 n 就可以求出 这个数字对应的兔子序列值 // 我们只需要知道用户输入的 n 的前面两项(n-1 n-2)就可以计算出 n 对应的序列值 function fb(n) { if (n === 1 || n === 2) { return 1; } return fb(n - 1) + fb(n - 2); } console.log(fb(3)); console.log(fb(6));</p></li></ul></li><li><p>利用递归方法遍历多层数组</p><ul><li><p>var data = [{ id: 1, name: &#39;家电&#39;, goods: [{ id: 11, gname: &#39;冰箱&#39;, goods: [{ id: 111, gname: &#39;海尔&#39; }, { id: 112, gname: &#39;美的&#39; }, ] }, { id: 12, gname: &#39;洗衣机&#39; }] }, { id: 2, name: &#39;服饰&#39; }]; // 我们想要做输入 id 号,就可以返回的数据对象 // 1. 利用 forEach 去遍历里面的每一个对象 function getID(json, id) { var o = {}; json.forEach(function(item) { // console.log(item); // 2 个数组元素 if (item.id == id) { // console.log(item); o = item; // 返回给下面使用 // 2. 我们想要得里层的数据 11 12 可以利用递归函数 // 里面应该有 goods 这个数组并且数组的长度不为 0 } else if (item.goods &amp;&amp; item.goods.length &gt; 0) { o = getID(item.goods, id); } }); return o; } console.log(getID(data, 1)); console.log(getID(data, 2)); console.log(getID(data, 11)); console.log(getID(data, 12)); console.log(getID(data, 111));</p></li><li><p>forEach 到一定条件遍历完成就会退出，所以在 forEach 里面使用递归不用 return</p></li></ul></li></ul></li></ul></li><li><p>12.构造函数和原型</p><ul><li><p>构造函数</p><ul><li><p>在 ES6(2015.06 发版)之前，对象不是基于类创建，而是用一种称为构建函数的特殊函数来定义对象和它们的特征</p></li><li><p>构造函数缺点</p><ul><li>浪费内存空间</li></ul></li><li><p>构造函数 this 指向 实例对象</p></li></ul></li><li><p>原型对象</p><ul><li><p>每一个构造函数都有一个 prototype 属性，指向另一个对象。注意这个 prototype 就是一个对象，这个对象的属性和方法，都会被构造函数所拥有</p></li><li><p>优点</p><ul><li>共享方法，节省内存空间</li></ul></li><li><p>原型对象的 this 指向 实例对象</p></li></ul></li><li><p>代码流程+</p><ul><li><p>构造代码</p><ul><li><p>function Star(uname,age){ this.uname = uname; this.age = age; } Star.prototype.sing = function(){ console.log(&#39;我会唱歌&#39;); }</p><ul><li><p>实例成员</p><ul><li><p>构造函数内部通过 this 添加的成员</p></li><li><p>uname、age、sing 都是实例成员</p></li><li><p>实例成员只能通过实例化对象来访问，不能通过构造函数访问</p></li></ul></li><li><p>静态成员</p><ul><li><p>在构造函数本身上添加成员</p></li><li><p>Star.sex = &#39;男&#39;</p><ul><li>sex，就是静态成员</li></ul></li><li><p>静态成员只能通过构造函数去访问，不能通过对象访问</p></li></ul></li><li><p>Star.prototype</p><ul><li>原型对象，共享方法</li></ul></li></ul></li><li><p>Star.prototype = { constructor: Star, sing: function{} movie: function{} }</p><ul><li><p>如果我们修改了原来的原型对象，给原型对象赋值的是一个对象，则必须手动利用 constructor 指回原来的构造函数</p></li><li><p>constructor: Star,</p><ul><li>手动让 constructor 指向 Star</li></ul></li></ul></li></ul></li><li><p>实例化</p><ul><li>var zhangsan = new Star(&#39;张三&#39;,19);</li></ul></li><li><p>调用</p><ul><li><p>zhangsan.sing()</p><ul><li><p>对象的原型</p><ul><li><p><strong>proto</strong></p></li><li><p>指向原型对象 Star.prototype</p></li><li><p>zhangsan.<strong>proto</strong> === Star.prototype</p></li></ul></li><li><p>constructor: Star</p><ul><li><p>手动让 constructor 指向 Star，让下面两个值相等</p></li><li><p>zhangsan.<strong>proto</strong>.constructor</p></li><li><p>Star.prototype.constructor</p></li></ul></li></ul></li></ul></li></ul></li><li><p>构造函数、原型对象、实例对象的关系</p><ul><li><p>构造函数里面有原型对象，通过构造函数.prototype 指向原型对象</p></li><li><p>原型对象的属性：constructor: 构造函数名</p><ul><li>指向构造函数</li></ul></li><li><p>new 构造函数指向实例对象</p></li><li><p>实例对象里有<strong>proto</strong>.constructor 指向原型对象</p></li><li><p>三者关系图</p></li><li><p>组成的原型链图</p></li></ul></li><li><p>JS 查找机制：</p><ul><li><p>按照原型链关系上一层层往上查找</p></li><li><p>优先级</p><ul><li>本身开始，一层层往上</li></ul></li></ul></li><li><p>扩展内置方法</p></li><li><p>继承</p><ul><li><p>函数.call()</p><ul><li><p>可以调用函数</p></li><li><p>可以改变 this 指向</p><ul><li><p>1.函数.call(另一个函数名)</p></li><li><p>2.this 指向了另一个函数</p></li></ul></li></ul></li><li><p>在子构造函数内使用</p><ul><li><p>1.Father.call(this,属性 1,属性 2)</p></li><li><p>2.达到了继承构造函数里的方法的效果</p></li><li><p>3.如果在父函数 使用了：构造函数.prototype 来拓展父方法，子函数使用这个方法来继承：</p><ul><li><p>Son.prototype = new Father();</p></li><li><p>上面代码 覆盖了父类对象的原型对象 Father.prototype 因此要利用子类对象 Son.prototype.constructor 重新指回 子类的原型对象</p><ul><li>Son.prototype.constructor = Son;</li></ul></li></ul></li></ul></li></ul></li></ul></li><li><p>13.闭包(closure)函数</p><ul><li><p>1.前提：了解变量的作用域</p><ul><li><p>变量根据作用域的不同分为两种：全局变量和局部变量。</p></li><li><ol><li>函数内部可以使用全局变量。</li></ol></li><li><ol start="2"><li>函数外部不可以使用局部变量。</li></ol></li><li><ol start="3"><li>当函数执行完毕，本作用域内的局部变量会销毁。</li></ol></li></ul></li><li><p>2.闭包的概念</p><ul><li>闭包是一个函数；闭包（closure）指有权访问另一个函数作用域中变量的函数，一个作用域可以访问另外一个函数的局部变量。 就形成了闭包</li></ul></li><li><p>3.闭包的主要作用：延伸了变量的作用范围</p></li><li><p>4.代码例子</p><ul><li><p>1、子级访问父级</p><ul><li>// 闭包（closure）指有权访问另一个函数作用域中变量的函数。 // 闭包: 我们 fun 这个函数作用域 访问了另外一个函数 fn 里面的局部变量 num function fn() { var num = 10; function fun() { console.log(num); } fun(); } fn();</li></ul></li><li><p>2、外面的作用域访问：return 返回函数</p><ul><li><p>// 闭包（closure）指有权访问另一个函数作用域中变量的函数。 // 闭包: 我们 fun 这个函数作用域 访问了另外一个函数 fn 里面的局部变量 num function fn() { var num = 10; function fun() { console.log(num); } return fun; } var f = fn(); // 调用，全局作用域 f 访问局部作用域变量 num f();</p></li><li><p>全局作用域 f 访问局部作用域变量 num</p></li></ul></li><li><p>3、立即执行函数闭包 (经典面试题)</p><ul><li><p>立即执行函数也称为小闭包，因为立即执行函数里面的任何一个函数都可以使用它的 i 变量</p></li><li><p>(function(i){})(i)</p></li><li><p>循环注册点击事件 (动态添加属性 和 闭包方法) 但闭包方式更麻烦</p><ul><li><code> 榴莲 臭豆腐 鲱鱼罐头 大猪蹄子 // 闭包应用-点击li输出当前li的索引号 // 1. 我们可以利用动态添加属性的方式 var lis = document.querySelector(&#39;.nav&#39;).querySelectorAll(&#39;li&#39;); for (var i = 0; i &lt; lis.length; i++) { lis[i].index = i; lis[i].onclick = function() { // console.log(i); console.log(this.index); } } // 2. 利用闭包的方式得到当前小li 的索引号 for (var i = 0; i &lt; lis.length; i++) { // 利用for循环创建了4个立即执行函数 // 立即执行函数也称为小闭包 // 因为立即执行函数里面的任何一个函数都可以使用它的i变量 (function(i) { // console.log(i); lis[i].onclick = function() { console.log(i); } })(i); }</code></li></ul></li></ul></li><li><p>4、立即执行函数里的定时器中的闭包 (3 秒钟之后,打印所有 li 元素的内容)</p><ul><li><code> 榴莲 臭豆腐 鲱鱼罐头 大猪蹄子 // 闭包应用-3秒钟之后,打印所有li元素的内容 var lis = document.querySelector(&#39;.nav&#39;).querySelectorAll(&#39;li&#39;); for (var i = 0; i &lt; lis.length; i++) { (function(i) { settimeout(function() { console.log(lis[i].innerhtml); }, 3000) })(i); } </code></li></ul></li><li><p>5、打车价格计算闭包例子 (立即执行函数的返回属性值的方法)</p><ul><li><code>​ // 闭包应用-计算打车价格 // 打车起步价13(3公里内), 之后每多一公里增加 5块钱. 用户输入公里数就可以计算打车价格 // 如果有拥堵情况,总价格多收取10块钱拥堵费 // function fn() {}; // fn(); var car = (function() { var start = 13; // 起步价 局部变量 var total = 0; // 总价 局部变量 return { // 正常的总价 price: function(n) { if (n &lt;= 3) { total = start; } else { total = start + (n - 3) * 5 } return total; }, // 拥堵之后的费用 yd: function(flag) { return flag ? total + 10 : total; } } })(); console.log(car.price(5)); // 23 console.log(car.yd(true)); // 33 console.log(car.price(1)); // 13 console.log(car.yd(false)); // 13 </code></li></ul></li></ul></li><li><p>5.每调用一次 闭包都是独立的 全新闭包赋值，互不影响</p></li></ul></li><li><p>各种函数的 this 指向</p><ul><li><p>普通函数调用</p><ul><li><p>此时 this 是全局的也就是 window</p></li><li><p><code>var c=function(){ alert(this==window) } c()//true</code></p></li><li><p>普通函数、定时器函数、立即执行函数</p><ul><li>this 都是指向 window</li></ul></li></ul></li><li><p>对象的方法调用</p><ul><li><p><code>var myObj={ value:2, inc:function(num){ alert(this.value+num); } } myobject.inc(1); //结果3，因为this指向myObj</code></p></li><li><p>this 指向调用的对象</p></li></ul></li><li><p>对象内部的匿名函数调用</p><ul><li><p><code>var myObj={ name:&#39;myObject&#39;, value:0, increment:function(num){ this.value += typeof(num) ===&#39;number&#39;? num:0; }, toString:function(){ return &#39;[object:&#39;+this.name+&#39;{value:&#39;+this.value+&#39;}]&#39;; }, getInfo:function(){ return (function(){ // 内部匿名函数不属于当前对象的函数， // 因此this指向了全局对象window return this.toString(); })(); } } alert(myObj.getInfo());//[object window];</code></p></li><li><p>内部匿名函数不属于当前对象的函数，因此 this 指向了全局对象 window</p></li><li><p>可以把对象内部的 this 用变量赋值，再用 this 变量指定调用对象的属性</p></li></ul></li><li><p>构造函数调用</p><ul><li><p><code>var fn = Function (status){ this.status = status; } fn.prototype.get_status = function(){ return this.status; } var test = new fn(&#39;my status&#39;); alert(test.get_status);//my status,this指向test</code></p></li><li><p>构造函数的 this 指向的的是它的实例化对象</p></li><li><p>上述代码 this 指向构造函数的实例化对象 test</p></li></ul></li><li><p>绑定事件函数</p><ul><li>this 指向的是函数的调用者(绑定的事件对象)，btn 这个按钮事件</li></ul></li></ul></li><li><p>改变函数 this 指向方法 (函数对象方法)</p><ul><li><p>fn.call(对象，属性 1,属性 2)</p><ul><li><p>1.调用函数执行</p></li><li><p>2.改变函数 this 指向，指向第一个参数对象</p></li><li><p>3.第一个参数指定是什么，this 就是什么</p></li><li><p>4.对象参数之后的两个属性就是函数的实际参数(实参)</p></li><li><p>call 经常用作构造函数的继承</p></li><li><p>代码例子</p><ul><li><code>var o = { name: &#39;andy&#39; } function fn(a, b) { console.log(this); console.log(a + b); }; fn.call(o, 1, 2); // call 第一个可以调用函数 第二个可以改变函数内的this 指向 // call 的主要作用可以实现继承 function Father(uname, age, sex) { this.uname = uname; this.age = age; this.sex = sex; } function Son(uname, age, sex) { Father.call(this, uname, age, sex); } var son = new Son(&#39;刘德华&#39;, 18, &#39;男&#39;); console.log(son);</code></li></ul></li></ul></li><li><p>fn.apply(对象，数组 1, 数组 2)</p><ul><li><p>求数组中的最大值最小值,必须是数组</p></li><li><p>代码例子</p><ul><li><code>var o = { name: &#39;andy&#39; }; function fn(arr) { console.log(this); console.log(arr); // &#39;pink&#39; }; fn.apply(o, [&#39;pink&#39;]); // 1. 也是调用函数 第二个可以改变函数内部的this指向 // 2. 但是他的参数必须是数组(伪数组) // 3. apply 的主要应用 比如说我们可以利用 apply 借助于数学内置对象求数组最大值 // Math.max(); var arr = [1, 66, 3, 99, 4]; var arr1 = [&#39;red&#39;, &#39;pink&#39;]; // var max = Math.max.apply(null, arr); var max = Math.max.apply(Math, arr); var min = Math.min.apply(Math, arr); console.log(max, min);</code></li></ul></li><li><p>作用</p><ul><li><p>1.调用函数</p></li><li><p>2.改变函数 this 指向，指向第一个参数对象</p></li><li><p>3.第一个参数指定是什么，this 就是什么</p></li><li><p>4.对象参数之后的数组参数就是函数的实际参数(实参)</p></li><li><p>5.参数必须是数组</p></li></ul></li><li><p>对象参数</p><ul><li>第一个参数对象可以设置 null ，js 中万物皆对象：可以是函数，可以是方法，可以是对象</li></ul></li></ul></li><li><p>fn.bind(thisArg,arg1,arg2)</p><ul><li><p>bind()不会调用原来的函数：（应用场景） 如果有的函数不需要立即调用，但又想改变这个函数内部的 this 指向时，使用 bind()方法</p></li><li><p>作用</p><ul><li><p>1.可以改变原来内部函数的 this 指向，不会调用原函数</p></li><li><p>2.返回的是 指定 this 和初始化参数改造之后 ，产生的原函数拷贝的新函数</p></li><li><p>3.1.常用于 定时器函数 的 this 指向</p></li><li><p>3.2. 如果有的函数我们不需要立即调用,但是又想改变这个函数内部的 this 指向此时用 bind</p></li><li><p>3.3. 我们有一个按钮,当我们点击了之后,就禁用这个按钮,3 秒钟之后开启这个按钮</p></li></ul></li><li><p>参数</p><ul><li><p>thisArg</p><ul><li>函数运行时 this 指向的对象</li></ul></li><li><p>arg1</p><ul><li>参数 1</li></ul></li><li><p>arg2</p><ul><li>参数 2</li></ul></li></ul></li><li><p>代码例子 1</p><ul><li><code>// 3. bind() 绑定 捆绑的意思 var o = { name: &#39;andy&#39; }; function fn(a, b) { console.log(this); console.log(a + b); }; var f = fn.bind(o, 1, 2); f();</code></li></ul></li><li><p>定时器函数使用场景</p><ul><li><p>1.有一个按钮，点击之后就禁用这个按钮，3 秒后开启这个按钮</p></li><li><p>2.有一个定时器函数，写在定时器外面，绑定定时器</p></li><li><p>代码例子</p><ul><li><p>禁用按钮例子</p><ul><li><code>btn.onclick = function(){ this.disabled = true; // 定时器里的this指向window setTimeout(dunction(){ this.disabled = flase; }.bind(this),3000) // 改变 定时器的this 指向 btn的this }</code></li></ul></li><li><p>批量禁用按钮例子</p><ul><li><code>var btns = document.querySelectorAll(&#39;button&#39;); for (var i = 0; i &lt; btns.length; i++) { btns[i].onclick = function() { this.disabled = true; setTimeout(function() { this.disabled = false; }.bind(this), 2000); } }</code></li></ul></li></ul></li></ul></li></ul></li><li><p>三个方法总结</p><ul><li><p>相同点：都可以改变 this 指向</p></li><li><p>不同点：</p><ul><li><p>call 和 apply 会调用函数, 并且改变函数内部 this 指向</p></li><li><p>call 传递参数使用逗号隔开传递,apply 传递参数使用数组传递</p></li><li><p>bind 不会调用函数</p></li></ul></li><li><p>应用场景:</p><ul><li><p>call 经常做继承</p></li><li><p>apply 经常跟数组有关系. 比如借助于数学对象实现数组最大值最小值</p></li><li><p>bind 不调用函数,但是还想改变 this 指向. 比如改变定时器内部的 this 指向</p></li></ul></li></ul></li></ul></li><li><p>调用函数的隐含参数</p><ul><li><p>在调用函数时， 浏览器每次都会传递两个隐含的参数：</p><ul><li><p>1.函数的上下文对象 this</p></li><li><p>2.封装实参的对象 arguments</p><ul><li><p>arguments 是一个类数组对象，它也可以通过索引操作数据，也可以获取长度</p></li><li><p>在调用函数时，我们所传递的实参都会在 arguments 中保存</p><ul><li><p>可以用数组的元素获取形式来获取实参</p></li><li><p>arguments[0]</p></li><li><p>arguments[1]</p></li></ul></li><li><p>arguments.length 可以用来获取实参的长度</p></li><li><p>arguments 中有一个属性 callee</p><ul><li>这个属性对应一个函数对象，就是当前正在执行的函数的对象</li></ul></li></ul></li></ul></li><li><p><code>function fun(){ console.log(arguments instanceof Array) console.log(Array.isArray(arguments)) console.log(arguments.length) console.log(arguments[1]) console.log(arguments.callee) }</code></p></li></ul></li><li><p>高阶函数</p><ul><li><p>高阶函数是对其他函数的进行操作 的函数，它接收函数作为参数 或 将函数作为返回值输出</p></li><li><p>例子</p><ul><li><p><code>function fn(callback){ callback&amp;&amp;callback(); } fn(function(){ alert(&#39;hello&#39;); })</code></p><ul><li>接收函数作为参数</li></ul></li><li><p>function fn(){ return function(){} } fn();</p><ul><li>函数作为返回值输出</li></ul></li><li><p>此处 两个例子的 fn 就是高阶函数</p></li></ul></li><li><p>运用</p><ul><li><p>函数可以当做参数来进行传递,回调函数</p></li><li><p><code>// 高阶函数- 函数可以作为参数传递 function fn(a, b, callback) { console.log(a + b); callback &amp;&amp; callback(); } fn(1, 2, function() { console.log(&#39;我是最后调用的&#39;); }); // JQuery.js移动变色例子 $(&quot;div&quot;).animate({ left: 500 }, function() { $(&quot;div&quot;).css(&quot;backgroundColor&quot;, &quot;purple&quot;); })</code></p></li></ul></li></ul></li></ul><h3 id="javascript-严格模式" tabindex="-1">JavaScript 严格模式 <a class="header-anchor" href="#javascript-严格模式" aria-label="Permalink to &quot;JavaScript 严格模式&quot;">​</a></h3><ul><li><p>JavaScript 除了提供正常模式外，还提供了 严格模式(strict mode)。ES5 的严格模式采用具有限制性 JavaScript 变体的一种方式，即在严格模式条件下运行 JS 代码 (只兼容 IE10 以上)</p></li><li><p>严格模式的产生：</p><ul><li><p>1.消除了 Javascript 语法的一些不合理、不严谨之处,减少了一些怪异行为。</p></li><li><p>2.消除代码运行的一些不安全之处，保证代码运行的安全。</p></li><li><p>3.提高编译器效率，增加运行速度。</p></li><li><p>4.禁用了在 ECMAScript 的未来版本中可能会定义的一些语法，为未来新版本的 Javascript 做好铺垫。比如一些保留字如：class,enum,export, extends, import, super 不能做变量名</p></li></ul></li><li><p>1、开启严格模式</p><ul><li><p>给整个 script 标签前面开启严格模式</p><ul><li><code>&#39;use strict&#39;</code></li></ul></li><li><p>给某个函数开启严格模式</p><ul><li><code>function() { &#39;use strict&#39; }</code></li></ul></li></ul></li><li><p>2、严格模式规范</p><ul><li><p>变量：</p><ul><li><p>在正常模式中,如果一个变量没有声明就赋值,默认是全局变量.严格模式禁止这种用法,变量都必须先用 var 命令声明,然后再使用</p></li><li><p>严禁删除已经声明变量。例如，delete x; 语法是错误的</p></li></ul></li><li><p>this 指向问题：</p><ul><li><p>严格模式下全局作用域中函数中的 this 是 undefined</p></li><li><p>严格模式下,如果 构造函数不加 new 调用, this 指向的是 undefined 如果赋值,会报错</p></li><li><p>new 实例化的构造函数指向创建的对象实例。</p></li><li><p>定时器 this 还是指向 window</p></li><li><p>事件、对象还是指向调用者</p></li></ul></li><li><p>函数变化</p><ul><li><p>函数不能有重名的参数</p></li><li><p>函数必须声明在最前面.新版本的 JavaScript 会引入“块级作用域”（ ES6 中已引入）为了与新版本接轨，不允许在非函数的代码块内声明函数</p></li></ul></li></ul></li></ul><h3 id="浅拷贝和深拷贝" tabindex="-1">浅拷贝和深拷贝 <a class="header-anchor" href="#浅拷贝和深拷贝" aria-label="Permalink to &quot;浅拷贝和深拷贝&quot;">​</a></h3><ul><li><p>浅拷贝</p><ul><li><p>1、对象简单的 =直接赋值 ， 只是拷贝 内存地址，拷贝和被拷贝的内存地址都指向同一个，所以也是浅拷贝</p></li><li><p>2、浅拷贝的方法</p><ul><li><p>for 循环</p><ul><li><p><code>// 定义一个深层次的对象 var obj = { id: 1, name: &#39;andy&#39;, msg: { age: 18 } }; // 定义一个空对象，遍历obj 赋值空对象 var o = {} for (var k in obj) { // k 是属性名 obj[k] 属性值 o[k] = obj[k]; }</code></p></li><li><p>for 循环浅拷贝只把 obj 更深层次对象 msg 的地址拷贝给了对象 o 的 msg 对象，所以改变了 msg 内属性的值，对应的 obj 对象和 o 对象的 msg 值也会一起改变</p></li></ul></li><li><p>ES6 浅拷贝 assign 方法</p><ul><li><p><code>// 定义一个深层次的对象 var obj = { id: 1, name: &#39;andy&#39;, msg: { age: 18 } }; // 定义一个空对象o，浅拷贝obj给o对象 var o = {} Object.assign(o, obj);</code></p></li><li><p><code>Object.assign(o, obj);</code></p></li></ul></li></ul></li></ul></li><li><p>深拷贝</p><ul><li><p>深拷贝会另外拷贝一份一个一模一样的对象,但是不同的是会从堆内存中开辟一个新的区域存放新对象,新对象跟原对象不再共享内存</p></li><li><p>1.用函数递归的方式</p><ul><li><code>​ // 深拷贝拷贝多层, 每一级别的数据都会拷贝. var obj = { id: 1, name: &#39;andy&#39;, msg: { age: 18 }, color: [&#39;pink&#39;, &#39;red&#39;] }; var o = {}; // 封装函数 function deepCopy(newobj, oldobj) { for (var k in oldobj) { // 判断我们的属性值属于那种数据类型 // 1. 获取属性值 oldobj[k] var item = oldobj[k]; // 2. 判断这个值是否是数组 if (item instanceof Array) { newobj[k] = []; deepCopy(newobj[k], item) } else if (item instanceof Object) { // 3. 判断这个值是否是对象 newobj[k] = {}; deepCopy(newobj[k], item) } else { // 4. 属于简单数据类型 newobj[k] = item; } } } deepCopy(o, obj); console.log(o); var arr = []; console.log(arr instanceof Object); o.msg.age = 20; console.log(obj); </code></li></ul></li><li><p>2.对象 push 方法</p><ul><li><p><code>let object={ repayment:this.ruleForm.repayment, interestType:this.ruleForm.interestType, productDeadline:this.ruleForm.productDeadline, Detention:this.ruleForm.Detention, } this.tableData.push(object);</code></p></li><li><p>缺点</p><ul><li><p>代码很臃肿</p></li><li><p>如果 object 对象需要封装多条非对象属性不适合使用</p></li></ul></li></ul></li><li><p>3.JSON.stringify(JSON.parse()) 方法</p><ul><li><code>var obj = { id: 1, name: &#39;andy&#39;, msg: { age: 18 }, color: [&#39;pink&#39;, &#39;red&#39;] }; var obj2 = JSON.stringify(JSON.parse(obj))</code></li></ul></li></ul></li></ul><h3 id="对象" tabindex="-1">对象 <a class="header-anchor" href="#对象" aria-label="Permalink to &quot;对象&quot;">​</a></h3><p><a href="https://mp.weixin.qq.com/s/LydKMa--EALM-u9VCkSlhg" target="_blank" rel="noreferrer">JavaScript日常开发中常用的Object操作方法总结 (qq.com)</a></p><p>对象的分类</p><ul><li><p>1.内建对象</p><ul><li><p>由 ES 标准中定义的对象，在任何的 ES 的实现中都可以使用</p></li><li><p>比如：Math String Number Boolean Function Object...</p></li></ul></li><li><p>2.宿主对象</p><ul><li><p>由 JS 的运行环境提供的对象，目前来讲主要指的是浏览器提供的对象</p></li><li><p>比如 BOM DOM</p></li></ul></li><li><p>3.自定义对象</p><ul><li>由开发人员自己创建的对象</li></ul></li></ul><p>自定义对象</p><ul><li>let obj = new Object()</li></ul><p>自定义对象的属性的方法</p><ul><li><p>获取对象身上所有的属性名</p><ul><li>Object.keys(obj);</li></ul></li><li><p>对象添加和修改属性的方式</p><ul><li><p>向对象添加的属性，属性名不强制要求遵循标识符的规范，但尽量遵守标识符规范</p></li><li><p>对象的属性值可以是任意的数据类型，甚至也可以是一个对象</p></li><li><p>方式 1：添加或修改属性值都可以</p><ul><li><p>如果有属性则修改，无属性则添加属性和值</p></li><li><p>obj.name = &#39;张三&#39;;</p></li></ul></li><li><p>方式 2：只修改属性值</p><ul><li><code>obj[&quot;属性名&quot;] = 属性值</code></li></ul></li><li><p>方式 3：只修改属性值</p><ul><li><p>Object.defineProperty(obj,&#39;要设置的属性&#39;,{ value: 1000 })</p><ul><li><p>参数 1</p><ul><li>对象</li></ul></li><li><p>参数 2</p><ul><li>要设置的属性</li></ul></li><li><p>参数 3</p><ul><li><p>以对象 { } 形式书写</p></li><li><p>value:</p><ul><li>设置属性的值，默认为 undefined</li></ul></li><li><p>writable:</p><ul><li>值是否可以重写。 true | false ，默认为 false</li></ul></li><li><p>enumerable:</p><ul><li>目标属性是否可以枚举 true | false ，默认为 false</li></ul></li><li><p>configurable:</p><ul><li>目标属性是否可以被删除或是否可以再次修改特性 true | false ，默认为 false</li></ul></li></ul></li></ul></li></ul></li><li><p>方法 4 和 5：</p><ul><li>unshift 和 push</li></ul></li><li><p>方式 6：对象字面量方式创建 直接创建对象 并设置属性和赋值</p><ul><li>{ name: &#39;&#39;, age: 18, }</li></ul></li></ul></li><li><p>检查对象中是否含有某个属性</p><ul><li>&#39;name&#39; in obj</li></ul></li><li><p>枚举对象中的属性</p><ul><li><p>for(let n in obj){ console.log(&quot;属性名：&quot; + n) console.log(&quot;属性值：&quot; + obj[n]) }</p></li><li><p>对象中有几个属性，循环体就会执行几次</p></li><li><p>每次执行时，会将对象中的一个属性名字赋值给变量</p></li></ul></li></ul><p>对象的函数方法</p><ul><li><p>函数也可以称为对象的属性：</p></li><li><p>如果一个函数作为一个对象的属性保存， 那么我们称这个函数为对象的方法</p></li><li><p>调用这个函数就说调用对象的方法</p></li><li><p>obj.sayName = function(){ console.log(&#39;我的名字叫哈哈&#39;) } // 对象的方法 obj.sayName()</p></li></ul><p>两种方法创建对象 和原型对象</p><ul><li><p>工厂方法创建对象</p><ul><li><p>function createPerson(name, age, gender){ var obj = new Object() obj.name = name; obj.age = age; obj.gender = gender; obj.sayName = function(){ alert(this.name); } return obj } const obj1 = createPerson(&quot;张三&quot;,18,&quot;男&quot;) const obj1 = createPerson(&quot;李四&quot;,20,&quot;女&quot;) const obj1 = createPerson(&quot;王五&quot;,22,&quot;男&quot;)</p></li><li><p>使用工厂方法创建的对象，使用的是构造函数 Object 所以创建的都是 Object 这个类型 就导致我们无法区分多种不同类型的对象</p></li><li><p>可以使用构造函数创建区分类型的对象</p></li></ul></li><li><p>构造函数创建对象</p><ul><li><p>function Preson(name, age, gender){ this.name = name this.age = age this.gender = gender this.sayName = function(){ alert(this.name) } } let person1 = new Person(&quot;张三&quot;,18,&quot;男&quot;) let person2 = new Person(&quot;李四&quot;,20,&quot;男&quot;)</p></li><li><p>有 new 是构造函数，没有 new 是普通函数</p></li><li><p>构造函数首字母大写是业内的区分习惯</p></li><li><p>构造函数执行流程</p><ul><li><p>1.调用构造函数会立即创建一个新的对象</p></li><li><p>2.将新建的对象设置为函数中的 this</p><ul><li>在构造函数中可以使用 this 来引用新建的对象</li></ul></li><li><p>3.逐行执行函数中的代码</p></li><li><p>4.将新建的对象作为返回值返回</p></li><li><p>使用同一个构造函数创建的对象，我们称为一类对象，也将一个构造函数称为一个类 我们将通过一个构造函数创建的对象称为该类的实例</p></li></ul></li><li><p>使用 instanceof 可以检查一个对象是否是一个类的实例 如果是：返回 true，否则返回 false</p><ul><li><p>对象 instanceof 构造函数</p></li><li><p>console.log(person instanceof Person)</p></li></ul></li><li><p>所有对象都是 Object 的后代，所以任何对象和 Object 在 instanceof 检查时都会返回 true</p></li><li><p>对象方法优化 将函数内的方法提取到全局作用域</p><ul><li><p>function Preson(name, age, gender){ this.name = name this.age = age this.gender = gender this.sayName = fun } function fun(){ alert(this.name) } let person1 = new Person(&quot;张三&quot;,18,&quot;男&quot;) let person2 = new Person(&quot;李四&quot;,20,&quot;男&quot;)</p></li><li><p>原理</p><ul><li>构造函数的方法，一个实例对象调用就执行一个，一千个实例对象调用就执行 1000 次，消耗内存大，提取到全局，共用一个方法，所有的调用 只调用一次</li></ul></li><li><p>缺点</p><ul><li><p>将函数在全局作用域中，污染了全局作用域的命名空间</p></li><li><p>而且定义在全局作用域中也很不安全</p></li><li><p>解决方法</p><ul><li><p>使用原型对象</p></li><li><p>Person.prototype.sayName = function(){ alert(this.name) }</p></li></ul></li></ul></li></ul></li></ul></li><li><p>原型对象</p><ul><li><p>原型 prototype</p></li><li><p>1.我们所创建的每一个函数，解析器都会 向函数中添加一个属性的 prototype</p><ul><li>这个属性对应着一个对象，这个对象就是原型对象</li></ul></li><li><p>2.如果函数作为普通函数调用 prototype 没有任何作用</p></li><li><p>3.当函数以构造函数形式调用时，它所创建的对象中都会有一个隐含的属性</p></li><li><p>4.指向该构造函数的原型对象，我们可以通过<strong>proto</strong>来访问该属性</p><ul><li><p>function MyClass(){ } let mc = new MyClass(); console.log(mc.<strong>proto</strong> == MyClass.prototype)</p></li><li><p>图解</p></li><li><p>向 MyClass 的原型添加属性 a</p><ul><li>MyClass.prototype.a = 123</li></ul></li><li><p>向 MyClass 的原型添加一个方法</p><ul><li>MyClass.prototype.sayHello = function(){ alert(&quot;hello&quot;) }</li></ul></li></ul></li><li><p>5.当我们访问对象的一个属性和方法时，它会先在对象自身中寻找，如果没有找到则回去原型对象中寻找，如果找到则直接使用</p></li><li><p>6.以后我们创建构造函数时，可以将这些对象共有的属性和方法，统一添加到构造函数的原型对象中， 这样就不用分别为每一个对象添加，也不会影响到全局作用域，就可以使每个对象都具有这些属性和方法了</p></li><li><p>7.检查对象是否有原型</p><ul><li><p>1.不能用 in 检查，name in 实例对象 --&gt; 因为使用 in 检查对象中是否含有某个属性时，如果对象中没有，但是原型中有，也会返回 true</p></li><li><p>2.可以使用：实例对象.hasOwnPrototype(&quot;age&quot;)</p></li><li><p>3.原型对象也是对象，所以它也有原型：</p><ul><li>当我们使用一个对象的属性或方法时，会先在自身中寻找 自身如果有，则直接使用 如果没有则去原型对象中寻找，如果原型对象中有，则使用 如果没有，则去原型的原型中寻找 直到找到 Object 对象的原型 Object 对象的原型没有原型，如果在 Object 中依然没有找到，则返回 undefined 第三层原型为 null</li></ul></li></ul></li></ul></li><li><p>实例对象上的 [Object Object]返回值改变的方法</p><ul><li><p>person..prototype.toString = function(){ return &quot;name=&quot; + this.name + &quot;age=&quot;+this.age+&quot;gender=&quot; + this.gender } let person = new Person(&quot;李四&quot;,20,&quot;男&quot;) let result = person.toString() console.log(person)</p></li><li><p>当我们直接在页面中打印一个对象时，实际上输出的对象的 toString()方法的返回值</p></li><li><p>如果我们希望输出对象时不输出[Object Object]，可以为对象添加一个 toString()方法</p></li></ul></li></ul><p>其他说明</p><ul><li><p>对象间的=相互赋值是根据内存的地址赋值，多个对象使用了同一个地址，把其中对象的值变了，相互=两个对象的值都会变，所以 对象 对 对象 = 赋值，要进行深拷贝</p><ul><li>深拷贝的方法</li></ul></li><li><p>对其他数组除和对象外的基本数据类型赋值 可以直接=相等</p></li><li><p>对象之间比较</p><ul><li>不管是 == 还是 === 都永远不会相等，因为是比较两个对象的内存地址，但可以比较 对象.属性 是否相等</li></ul></li></ul><h4 id="date对象" tabindex="-1">Date对象 <a class="header-anchor" href="#date对象" aria-label="Permalink to &quot;Date对象&quot;">​</a></h4><p>获取当前时间毫秒值</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#7F848E;font-style:italic;">// 方式一</span></span>
<span class="line"><span style="color:#E5C07B;">Date</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">now</span><span style="color:#ABB2BF;">(); </span><span style="color:#7F848E;font-style:italic;">// 1606381881650</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">// 方式二</span></span>
<span class="line"><span style="color:#C678DD;">new</span><span style="color:#61AFEF;"> Date</span><span style="color:#ABB2BF;">() </span><span style="color:#56B6C2;">-</span><span style="color:#D19A66;"> 0</span><span style="color:#ABB2BF;">; </span><span style="color:#7F848E;font-style:italic;">// 1606381881650</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">// 方式三</span></span>
<span class="line"><span style="color:#C678DD;">new</span><span style="color:#61AFEF;"> Date</span><span style="color:#ABB2BF;">().</span><span style="color:#61AFEF;">getTime</span><span style="color:#ABB2BF;">() </span><span style="color:#7F848E;font-style:italic;">// 1606381881650</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>创建<code>Date</code>对象的兼容性问题。</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#7F848E;font-style:italic;">// window和安卓支持，ios和mac不支持</span></span>
<span class="line"><span style="color:#C678DD;">new</span><span style="color:#61AFEF;"> Date</span><span style="color:#ABB2BF;">(</span><span style="color:#98C379;">&#39;2020-11-26&#39;</span><span style="color:#ABB2BF;">); </span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">// window和安卓支持，ios和mac支持</span></span>
<span class="line"><span style="color:#C678DD;">new</span><span style="color:#61AFEF;"> Date</span><span style="color:#ABB2BF;">(</span><span style="color:#98C379;">&#39;2020/11/26&#39;</span><span style="color:#ABB2BF;">);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h3 id="数组" tabindex="-1">数组 <a class="header-anchor" href="#数组" aria-label="Permalink to &quot;数组&quot;">​</a></h3><ul><li><p>数组也是一个对象</p></li><li><p>定义：数组对象用来在单独的变量名中存储一系列的值</p></li><li><p>创建方式</p><ul><li><p>1.构造数组</p><ul><li><p>var myArray=new Array();</p><ul><li>创建了一个空数组</li></ul></li><li><p>var myArray=new Array(20);</p><ul><li>创建了一个长度为 20 的数组</li></ul></li><li><p>var myArray=new Array(&quot;张三&quot;,&quot;男&quot;);</p><ul><li>组</li></ul></li></ul></li><li><p>2.数组字面量</p><ul><li><p>var myArray=[&quot;张三&quot;,18，&quot;男&quot;，&quot;唱、跳、rap&quot;];</p></li><li><p>var myArray=[];</p><ul><li><p>向数组中添加元素，读取元素也是一样的</p></li><li><p>myArray[0]= 1</p></li><li><p>myArray[1]= 2</p></li><li><p>myArray[2]= 3</p></li><li><p>console.log(myArray[0])</p></li></ul></li></ul></li></ul></li><li><p>数组对象方法</p><ul><li><p>toString()</p><ul><li>把数组转换为字符串，并返回结果。</li></ul></li><li><p>push()和 pop()</p><ul><li><p>push() 方法（在数组结尾处）向数组添加一个或多个新的元素：逗号分割，并返回新数组 实例 var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;]; fruits.push(&quot;Kiwi&quot;); // 向 fruits 添加一个新元素 push() 方法返回新数组的长度： 实例 var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;]; var x = fruits.push(&quot;Kiwi&quot;); // x 的值是 5</p></li><li><p>pop() 方法删除数组的最后一个元素，并将删除的元素作为返回值返回 var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;]; fruits.pop(); // 从 fruits 删除最后一个元素（&quot;Mango&quot;） pop() 方法返回“被弹出”(删除)的值 var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;]; var x = fruits.pop(); // x 的值是 &quot;Mango&quot;</p></li></ul></li><li><p>shift() 和 unshift()</p><ul><li><p>shift() 方法会删除数组第一个元素，并把删除的元素作为返回值返回。 实例 var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;]; fruits.shift(); // 从 fruits 删除第一个元素 &quot;Banana&quot; shift() 方法返回被“位移出”的字符串： 实例 var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;]; fruits.shift(); // 返回 &quot;Banana&quot;</p></li><li><p>unshift() 方法（在开头）向数组第一位添加新元素，并返回新数组： 实例 var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;]; fruits.unshift(&quot;Lemon&quot;); // 向 fruits 添加新元素 &quot;Lemon&quot; unshift() 方法返回新数组的长度。 实例 var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;]; fruits.unshift(&quot;Lemon&quot;); // 返回 5</p></li></ul></li><li><p>concat()</p><ul><li><p>连接两个或更多的数组，并将新的数组返回。 该方法不会对原数组产生影响</p></li><li><p>arr1.concat(arr2,arr3,&#39;哈哈哈&#39;,&#39;呵呵呵&#39;)</p></li></ul></li><li><p>join()</p><ul><li><p>将所有数组元素结合为一个字符串。元素通过指定的分隔符进行分隔。</p></li><li><p>它的行为类似 toString()，但是您还可以规定分隔符： 实例 var fruits = [&quot;Banana&quot;, &quot;Orange&quot;,&quot;Apple&quot;, &quot;Mango&quot;]; document.getElementById(&quot;demo&quot;).innerHTML = fruits.join(&quot; _ &quot;); 结果 Banana _ Orange _ Apple _ Mango</p></li></ul></li><li><p>indexOf() 和 lastIndexOf()</p><ul><li><p>indexOf(4,2)：接收两个参数： 要查找的项 和（可选的）表示查找起点位置的索引。 其中， 从数组的开头（位置 0）开始向后查找。</p></li><li><p>lastIndexOf(4,2)：接收两个参数：要查找的项和（可选的） 表示查找起点位置的索引。 其中， 从数组的末尾开始向前查找。</p></li></ul></li><li><p>slice()</p><ul><li><p>从某个已有的数组返回选定的元素，该方法不会影响原数组，而是将取到的元素封装到一个新数组返回(截取元素)</p></li><li><p>arrObj.slice(startIndex, endIndex)</p><ul><li><p>第二个参数可以省略不写，会截取从开始索引往后的元素</p></li><li><p>索引可以传递负值</p></li></ul></li></ul></li><li><p>splice()</p><ul><li><p>删除元素，并向数组添加新元素(用新元素替换删除的元素)。 用于删除数组中的指定元素，删除会影响原数组，将被删除的元素作为返回值返回</p></li><li><p>arrObj.splice(startIndex, endIndex, 替换元素 1, 替换元素 2)</p></li></ul></li><li><p>reverse()</p><ul><li><p>颠倒(反转)数组中元素的顺序。</p></li><li><p>arr.reverse()</p></li></ul></li><li><p>sort()</p><ul><li><p>对数组的元素进行排序，默认会按照 Unicode 编码进行排序，会影响原素组</p></li><li><p>let arr = [5,4] arr.sort()</p></li><li><p>自定义排序规则</p><ul><li><p>可以在 sort()添加一个回调函数，来指定规则 回调函数中需要定义两个形参，浏览器将会分别使用数组中的元素作为实参去调用回调函数 使用哪个元素调用不确定，但是肯定是在数组中 ，a 一定在吧前边</p></li><li><p>浏览器会根据回调函数的返回值来决定元素的顺序， 如果返回一个大于 0 的值，则元素位置会交换， 如果返回一个小于 0 的值，则元素位置不变， 如果返回一个等于 0 的值，则认为两个元素相等，也不交换位置，</p></li></ul></li><li><p>let arr = [5,4] arr.sort(function(a,b)=&gt;{ // 升序 // return a - b // 降序 return b - a })</p></li></ul></li><li><p>toSource()</p><ul><li>返回该对象的源代码。</li></ul></li><li><p>toLocaleString()</p><ul><li>把数组转换为本地数组，并返回结果。</li></ul></li><li><p>valueOf()</p><ul><li>返回数组对象的原始值</li></ul></li><li><p>forEach() 迭代(遍历)</p><ul><li><p>对数组进行遍历循环，对数组中的每一项运行给定函数。 这个方法没有返回值。参数都是 function 类型，默认有传参， 参数分别为：遍历的数组内容；第对应的数组索引，数组本身。</p></li><li><p>数组.forEach(function(value,index,array){ console.log(&#39;每个数组元素&#39; + value); console.log(&#39;每个数组元素的索引号&#39; + index); console.log(&#39;数组本身&#39; + array); })</p><ul><li><p>值</p><ul><li>value</li></ul></li><li><p>索引</p><ul><li>index</li></ul></li><li><p>数组本身</p><ul><li>array</li></ul></li></ul></li><li><p>遍历完全部数据才会终止循环遍历</p></li></ul></li><li><p>some()遍历</p><ul><li><p>判断数组中是否存在满足条件的项，只要找到第一项满足条件，就会返回 true，否则返回 false (只找到一项便终止循环)</p></li><li><p>数组.some(function(value,index,array){ return value &gt;= 20; })</p><ul><li><p>值</p><ul><li>value</li></ul></li><li><p>索引</p><ul><li>index</li></ul></li><li><p>数组本身</p><ul><li>array</li></ul></li></ul></li><li><p>返回值为布尔值</p><ul><li>return true 终止遍历</li></ul></li><li><p>查询唯一的元素，用此方法效率更高</p></li></ul></li><li><p>filter()过滤</p><ul><li><p>“过滤”功能，数组中的每一项运行给定函数，返回满足过滤条件组成的数组。</p></li><li><p>数组.filter(function(value,index,array){ })</p><ul><li><p>值</p><ul><li>value</li></ul></li><li><p>索引</p><ul><li>index</li></ul></li><li><p>数组本身</p><ul><li>array</li></ul></li></ul></li><li><p>返回值为数组</p></li></ul></li><li><p>map()</p><ul><li>指“映射”，对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。</li></ul></li><li><p>every()</p><ul><li>判断数组中每一项都是否满足条件，只有所有项都满足条件，才会返回 true。</li></ul></li><li><p>reduce()和 reduceRight()</p><ul><li>实现迭代数组的所有项，然后构建一个最终返回的值。 reduce()方法从数组的第一项开始，逐个遍历到最后。 reduceRight()则从数组的最后一项开始，向前遍历到第一项。</li></ul></li></ul></li><li><p>数组对象属性</p><ul><li><p>数组名.length = 100;</p><ul><li><p>数组长度为 100</p></li><li><p>长度如果超出，超出的数据会删掉</p></li><li><p>设置或返回数组中元素的数目。</p></li><li><p>可以使用这种方法删除数组一定长度后的元素</p></li></ul></li><li><p>获取数组中的 元素</p><ul><li><p>（通过使用它们的索引号来访问数组元素） 数组中的指定元素 = =数组名[索引值： 从 0 开始，取最后一个数为：arr.length - 1]；</p></li><li><p>数组的索引代表的是数组中的元素在数组中的位置，从 0 开始。</p></li><li><p>如果获取数组中的元素是：数组名[索引值]，没有指定索引(元素没那么多)，系统不报错，而是给定值为 undefined；</p></li></ul></li><li><p>在数组最后添加元素</p><ul><li>arr[arr.length] = 10</li></ul></li><li><p>constructor</p><ul><li>返回对创建此对象的数组函数的引用。</li></ul></li><li><p>prototype</p><ul><li>向对象添加属性和方法。</li></ul></li></ul></li></ul><h3 id="字符串" tabindex="-1">字符串 <a class="header-anchor" href="#字符串" aria-label="Permalink to &quot;字符串&quot;">​</a></h3><ul><li><p><a href="https://www.runoob.com/jsref/jsref-obj-string.html" target="_blank" rel="noreferrer">https://www.runoob.com/jsref/jsref-obj-string.html</a></p></li><li><p>字符串对象属性</p><ul><li><p>str.constructor</p><ul><li>对创建该对象的函数的引用</li></ul></li><li><p>str.length</p><ul><li>字符串的长度</li></ul></li><li><p>str.prototype</p><ul><li>允许向对象添加属性和方法</li></ul></li></ul></li><li><p>字符串对象方法</p><ul><li><p>str.charAt(5)</p><ul><li>返回在指定 5 位置的字符。(索引从 0 开始)</li></ul></li><li><p>str.charCodeAt(5)</p><ul><li>返回在指定的位置 5 的字符的 Unicode 编码。</li></ul></li><li><p>String.fromCharCode()</p><ul><li><p>String 构造函数的对象的方法</p></li><li><p>编码表</p><ul><li><a href="http://www.52unicode.com/" target="_blank" rel="noreferrer">http://www.52unicode.com/</a></li></ul></li><li><p>将 Unicode 编码转为字符。</p></li></ul></li><li><p>str.concat(str1,str2)</p><ul><li>连接两个或更多字符串，并返回新的字符串。</li></ul></li><li><p>str.indexOf(&#39;h&#39;,1)</p><ul><li><p>返回某个指定的字符串值在字符串中首次出现的位置。 （用于检索一个字符串中是否含有指定内容）</p></li><li><p>参数(查找的内容, 从第几个开始找)</p></li><li><p>从前往后找</p></li><li><p>如果找到指定的内容，则返回 -1</p></li></ul></li><li><p>str.lastIndexOf()</p><ul><li><p>从后向前搜索字符串，并从起始位置（0）开始计算返回字符串最后出现的位置。</p></li><li><p>参数(查找的内容, 从第几个开始找)</p></li><li><p>从后往前找</p></li><li><p>如果找到指定的内容，则返回 -1</p></li></ul></li><li><p>str.endsWith()</p><ul><li>判断当前字符串是否是以指定的子字符串结尾的（区分大小写）。</li></ul></li><li><p>str.includes()</p><ul><li>查找字符串中是否包含指定的子字符串。</li></ul></li><li><p>str.match()</p><ul><li>查找找到一个或多个正则表达式的匹配。</li></ul></li><li><p>str.repeat()</p><ul><li>复制字符串指定次数，并将它们连接在一起返回。</li></ul></li><li><p>str.replace()</p><ul><li>在字符串中查找匹配的子串，并替换与正则表达式匹配的子串。</li></ul></li><li><p>str.replaceAll()</p><ul><li>在字符串中查找匹配的子串，并替换与正则表达式匹配的所有子串。</li></ul></li><li><p>str.search()</p><ul><li>查找与正则表达式相匹配的值。</li></ul></li><li><p>str.slice(1,,2)</p><ul><li><p>提取字符串的片断，并在新的字符串中返回被提取的部分。</p></li><li><p>参数(开始位置索引:包括开始位置, 结束位置索引:不包括结束位置)</p></li></ul></li><li><p>str.split(&quot;,&quot;)</p><ul><li><p>把字符串分割为 字符串数组。</p></li><li><p>参数</p><ul><li><p>(&quot;,&quot;)</p><ul><li>(根据什么符号分割)</li></ul></li><li><p>如果传递一个空串作为参数(&quot;&quot;)，则会将每个字符都拆分为数组中的一个元素</p></li></ul></li></ul></li><li><p>str.substr()</p><ul><li><p>从起始索引号提取字符串中指定数目的字符。</p></li><li><p>参数</p><ul><li>(截取开始位置的索引, 截取长度)</li></ul></li></ul></li><li><p>str.substring()</p><ul><li><p>提取字符串中两个指定的索引号之间的字符。</p></li><li><p>参数</p><ul><li>(开始位置索引: 包括开始位置, 结束位置索引: 不包括结束位置)</li></ul></li><li><p>不可以传负值，如果传负值，默认为 0，如果第二个参数小于第一个，自动调整参数的位置</p></li></ul></li><li><p>str.startsWith()</p><ul><li>查看字符串是否以指定的子字符串开头。</li></ul></li><li><p>str.toLowerCase()</p><ul><li>把字符串转换为小写。并返回</li></ul></li><li><p>str.toUpperCase()</p><ul><li>把字符串转换为大写。并返回</li></ul></li><li><p>str.trim()</p><ul><li><p>从一个字符串的两端删除空白字符 (去除字符串两边的空白。)</p></li><li><p>不影响原字符串本身，返回的是一个新字符串</p></li><li><p>使用场景</p><ul><li>文本框获取用户输入很多空格的时候， 去掉空格，判断是否输入了东西</li></ul></li></ul></li><li><p>str.toLocaleLowerCase()</p><ul><li>根据本地主机的语言环境把字符串转换为小写。</li></ul></li><li><p>str.toLocaleUpperCase()</p><ul><li>根据本地主机的语言环境把字符串转换为大写。</li></ul></li><li><p>str.valueOf()</p><ul><li>返回某个字符串对象的原始值。</li></ul></li><li><p>str.toString()</p><ul><li>返回一个字符串。</li></ul></li></ul></li></ul><h3 id="regexp-正则表达式对象" tabindex="-1">RegExp 正则表达式对象 <a class="header-anchor" href="#regexp-正则表达式对象" aria-label="Permalink to &quot;RegExp 正则表达式对象&quot;">​</a></h3><ul><li><p>正则表达式是描述字符模式的对象。</p><ul><li><a href="https://www.runoob.com/jsref/jsref-obj-regexp.html" target="_blank" rel="noreferrer">https://www.runoob.com/jsref/jsref-obj-regexp.html</a></li></ul></li><li><p>正则表达式用于对字符串模式匹配及检索替换，是对字符串执行模式匹配的强大工具。</p></li><li><p>正则表达式对象创建</p><ul><li><p>构造函数创建</p><ul><li><p>var patt= new RegExp(pattern,modifiers);</p></li><li><p>参数(正则表达式模式, 修饰符 匹配)</p></li><li><p>修饰符匹配</p><ul><li><p>全局匹配</p></li><li><p>区分大小写的匹配</p></li><li><p>多行匹配</p></li></ul></li><li><p>优点：更灵活</p></li><li><p>注意：当使用构造函数创造正则对象时，需要常规的字符转义规则（在前面加反斜杠 \\）。比如，以下是等价的：</p><ul><li><p>var re = new RegExp(&quot;\\w+&quot;);</p></li><li><p>var re = /\\w+/;</p></li></ul></li></ul></li><li><p>字面量创建</p><ul><li><p>var patt= /pattern/modifiers;</p></li><li><p>/正则表达式模式/修饰符 匹配</p></li><li><p>修饰符匹配</p><ul><li><p>全局匹配</p></li><li><p>区分大小写的匹配</p></li><li><p>多行匹配</p></li></ul></li><li><p>优点：更简单</p></li></ul></li></ul></li><li><p>语法详解</p><ul><li><p>修饰符</p><ul><li><p>修饰符用于执行区分大小写和全局匹配:</p></li><li><p>i</p><ul><li>执行对大小写不敏感的匹配。</li></ul></li><li><p>g</p><ul><li>执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）。</li></ul></li><li><p>m</p><ul><li>执行多行匹配。</li></ul></li></ul></li><li><p>方括号</p><ul><li><p>方括号用于查找某个范围内的字符：</p></li><li><p>[abc]</p><ul><li>查找方括号之间的任何字符。</li></ul></li><li><p>[^abc]</p><ul><li>查找任何不在方括号之间的字符。</li></ul></li><li><p>[0-9]</p><ul><li>查找任何从 0 至 9 的数字。</li></ul></li><li><p>[a-z]</p><ul><li>查找任何从小写 a 到小写 z 的字符。</li></ul></li><li><p>[A-Z]</p><ul><li>查找任何从大写 A 到大写 Z 的字符。</li></ul></li><li><p>[A-z]</p><ul><li>查找任何从大写 A 到小写 z 的字符。</li></ul></li><li><p>[adgk]</p><ul><li>查找给定集合内的任何字符。</li></ul></li><li><p>[^adgk]</p><ul><li>查找给定集合外的任何字符。</li></ul></li><li><p>(red|blue|green)</p><ul><li>查找任何指定的选项。</li></ul></li></ul></li><li><p>元字符</p><ul><li><p>元字符（Metacharacter）是拥有特殊含义的字符：</p></li><li><p>.</p><ul><li>查找单个字符，除了换行和行结束符。</li></ul></li><li><p>\\w</p><ul><li>查找数字、字母及下划线。</li></ul></li><li><p>\\W</p><ul><li>查找非单词字符。</li></ul></li><li><p>\\d</p><ul><li>查找数字。</li></ul></li><li><p>\\D</p><ul><li>查找非数字字符。</li></ul></li><li><p>\\s</p><ul><li>查找空白字符。</li></ul></li><li><p>\\S</p><ul><li>查找非空白字符。</li></ul></li><li><p>\\b</p><ul><li>匹配单词边界。</li></ul></li><li><p>\\B</p><ul><li>匹配非单词边界。</li></ul></li><li><p>\\0</p><ul><li>查找 NULL 字符。</li></ul></li><li><p>\\n</p><ul><li>查找换行符。</li></ul></li><li><p>\\f</p><ul><li>查找换页符。</li></ul></li><li><p>\\r</p><ul><li>查找回车符。</li></ul></li><li><p>\\t</p><ul><li>查找制表符。</li></ul></li><li><p>\\v</p><ul><li>查找垂直制表符。</li></ul></li><li><p>\\xxx</p><ul><li>查找以八进制数 xxx 规定的字符。</li></ul></li><li><p>\\xdd</p><ul><li>查找以十六进制数 dd 规定的字符。</li></ul></li><li><p>\\uxxxx</p><ul><li>查找以十六进制数 xxxx 规定的 Unicode 字符。</li></ul></li></ul></li><li><p>量词</p><ul><li><p>n+</p><ul><li><p>匹配任何包含至少一个 n 的字符串。</p></li><li><p>例如，/a+/ 匹配 &quot;candy&quot; 中的 &quot;a&quot;，&quot;caaaaaaandy&quot; 中所有的 &quot;a&quot;。</p></li></ul></li><li><p>n*</p><ul><li><p>匹配任何包含零个或多个 n 的字符串。</p></li><li><p>例如，/bo*/ 匹配 &quot;A ghost booooed&quot; 中的 &quot;boooo&quot;，&quot;A bird warbled&quot; 中的 &quot;b&quot;，但是不匹配 &quot;A goat grunted&quot;。</p></li></ul></li><li><p>n?</p><ul><li><p>匹配任何包含零个或一个 n 的字符串。</p></li><li><p>例如，/e?le?/ 匹配 &quot;angel&quot; 中的 &quot;el&quot;，&quot;angle&quot; 中的 &quot;le&quot;。</p></li></ul></li><li><p>n{X}</p><ul><li><p>匹配包含 X 个 n 的序列的字符串。</p></li><li><p>例如，/a{2}/ 不匹配 &quot;candy,&quot; 中的 &quot;a&quot;，但是匹配 &quot;caandy,&quot; 中的两个 &quot;a&quot;，且匹配 &quot;caaandy.&quot; 中的前两个 &quot;a&quot;。</p></li></ul></li><li><p>n{X,}</p><ul><li><p>X 是一个正整数。前面的模式 n 连续出现至少 X 次时匹配。</p></li><li><p>例如，/a{2,}/ 不匹配 &quot;candy&quot; 中的 &quot;a&quot;，但是匹配 &quot;caandy&quot; 和 &quot;caaaaaaandy.&quot; 中所有的 &quot;a&quot;。</p></li></ul></li><li><p>n{X,Y}</p><ul><li><p>X 和 Y 为正整数。前面的模式 n 连续出现至少 X 次，至多 Y 次时匹配。</p></li><li><p>例如，/a{1,3}/ 不匹配 &quot;cndy&quot;，匹配 &quot;candy,&quot; 中的 &quot;a&quot;，&quot;caandy,&quot; 中的两个 &quot;a&quot;，匹配 &quot;caaaaaaandy&quot; 中的前面三个 &quot;a&quot;。注意，当匹配 &quot;caaaaaaandy&quot; 时，即使原始字符串拥有更多的 &quot;a&quot;，匹配项也是 &quot;aaa&quot;。</p></li></ul></li><li><p>n$</p><ul><li>匹配任何结尾为 n 的字符串。</li></ul></li><li><p>^n</p><ul><li>匹配任何开头为 n 的字符串。</li></ul></li><li><p>?=n</p><ul><li>匹配任何其后紧接指定字符串 n 的字符串。</li></ul></li><li><p>?!n</p><ul><li>匹配任何其后没有紧接指定字符串 n 的字符串。</li></ul></li></ul></li></ul></li><li><p>RegExp 对象方法</p><ul><li><p>patt.test(str)</p><ul><li>检测一个字符串是否含有某个模式或字符。返回布尔值 true 或 false。</li></ul></li><li><p>patt.exec()</p><ul><li><p>检索字符串中指定的值。返回找到的值，并确定其位置。</p></li><li><p>执行强大的、通用的模式匹配。</p></li></ul></li><li><p>patt.toString()</p><ul><li>返回正则表达式的字符串。</li></ul></li></ul></li><li><p>支持正则表达式的 String 对象的方法</p><ul><li><p>patt.search</p><ul><li>检索与正则表达式相匹配的值</li></ul></li><li><p>patt.match</p><ul><li>找到一个或多个正则表达式的匹配</li></ul></li><li><p>patt.replace</p><ul><li>替换与正则表达式匹配的子串</li></ul></li><li><p>patt.split</p><ul><li>把字符串分割为字符串数组</li></ul></li></ul></li><li><p>RegExp 对象属性</p><ul><li><p>patt.constructor</p><ul><li>返回一个函数，该函数是一个创建 RegExp 对象的原型。</li></ul></li><li><p>patt.global</p><ul><li>判断是否设置了 &quot;g&quot; 修饰符</li></ul></li><li><p>patt.ignoreCase</p><ul><li>判断是否设置了 &quot;i&quot; 修饰符</li></ul></li><li><p>patt.lastIndex</p><ul><li><p>用于规定下次匹配的起始位置</p></li><li><p>上次匹配后的字符位置,用于一个字符串中进行多次匹配。</p></li></ul></li><li><p>patt.multiline</p><ul><li>判断是否设置了 &quot;m&quot; 修饰符</li></ul></li><li><p>patt.source</p><ul><li>返回正则表达式的匹配模式 正则表达式的源文本。</li></ul></li></ul></li></ul><h3 id="作用域总结" tabindex="-1">作用域总结 <a class="header-anchor" href="#作用域总结" aria-label="Permalink to &quot;作用域总结&quot;">​</a></h3><ul><li><p>全局作用域</p></li><li><p>变量作用域</p></li><li><p>函数作用域</p></li></ul><h3 id="js-对象归纳总结" tabindex="-1">JS 对象归纳总结 <a class="header-anchor" href="#js-对象归纳总结" aria-label="Permalink to &quot;JS 对象归纳总结&quot;">​</a></h3><ul><li><p>基本要求</p><ul><li>定义一个构造函数，创建自定义对象</li></ul></li><li><p>对象</p><ul><li><p>什么是对象</p><ul><li><p>生活中的对象：车、手机、物品....</p></li><li><p>对象的特征和行为</p></li></ul></li><li><p>面向对象和基于对象</p><ul><li><p>面向对象</p><ul><li><p>可以创建自定义的类型，很好的支持和继承多态。面向对象的语言：c++/java/c#...</p></li><li><p>特征：封装、继承、多态</p></li><li><p>万物皆对象：世间的一切事物都可以用对象来描述</p></li></ul></li><li><p>基于对象</p><ul><li><p>无法创建自定义的类型、不能很好的支持和继承多态</p></li><li><p>基于对象的语言：比如：JavaScript</p></li></ul></li></ul></li></ul></li><li><p>JavaScript 常见对象</p><ul><li><p>无序属性的集合</p><ul><li><p>其属性可以包含基本知识、对象或者函数</p></li><li><p>对象就是一组没有顺序的值</p></li><li><p>我们可以把 JavaScript 的对象想象成键值对，其中值可以是数据和函数</p></li></ul></li><li><p>对象的行为和特征</p><ul><li><p>特征--属性</p></li><li><p>行为--方法</p></li></ul></li><li><p>字面量对象</p><ul><li>var p={ name:&quot;&quot;, age:18, sex:true, sayHi:function(){ console.log(this.name); } }; <ul><li>p.sayHi();//对象 p 调用 sayHi()方法， 所以 sayHi()中的 this 是对象 0</li></ul></li></ul></li><li><p>JSON</p><ul><li><p>什么是 JSON</p><ul><li><p>轻量级的数据交换格式</p></li><li><p>基于 ECMAScript 的一个子集</p></li></ul></li><li><p>JSON 和对象字面量的区别</p><ul><li><p>JSON 的属性必须用双引号括起来，对象字面量可以省略</p></li><li><p>JSON 本质上是一种数据交换格式</p><ul><li>JSON 有两种结构：对象 和 数组， 两种结构相互组合从而形成各种复杂的数据结构</li></ul></li></ul></li></ul></li><li><p>遍历对象的属性</p><ul><li>for...in 遍历对象的属性或者方法 <ul><li><code>var obj = {}; for(var i= 0;i&lt;10;i++){ obj[i] = i*2; } for(var key in obj){ console.log(key + &quot;:&quot; + obj[key]); }</code></li></ul></li></ul></li><li><p>构造函数</p><ul><li><p>new Object()</p><ul><li><p>new 后面调用函数，我们称为构造函数</p></li><li><p>Object() 我们把他视为一个构造函数，构造函数的本质就是一个函数，只不过构造函数的目的是为了创新对象，为新对象进行初始化(设置对象的属性)</p></li></ul></li></ul></li><li><p>this</p><ul><li><p>this 所在的函数在哪个对象中，this 就代表这个对象</p></li><li><p>谁调用 this 就是谁</p><ul><li><p>function test(){ console.log(this); } test();<a href="//window.test" target="_blank" rel="noreferrer">//window.test</a>(); //上面的 this 就是 window，实际是 window 调用 test()</p></li><li><p>p.sayHi(); //sayHi()中的 this,是 p,此时 p 是调用 sayHi()</p></li></ul></li><li><p>构造函数中的 this，始终是 new 的当前对象</p></li></ul></li><li><p>构造器(constructor)和原型属性(prototype)</p><ul><li><p>在任何一个对象中都有构造器和原型属性， 包括原生的对象，比如：Date，Array 等</p></li><li><p>constructor：返回创建此对象的构造函数</p></li><li><p>prototype 让我们有能力动态给对象添加属性和方法</p></li></ul></li><li><p>其他语言中的面向对象</p><ul><li>子主题 1</li></ul></li></ul></li><li><p>数据类型和内存分析</p><ul><li><p>堆区和栈区</p><ul><li><p>堆区(heap)</p><ul><li>由编译器自动分配释放、存放函数的参数值、局部变量的值等</li></ul></li><li><p>栈区(stack)</p><ul><li>一般由程序员分配释放，若开发者不释放，程序结束时可能 OS 回收</li></ul></li></ul></li><li><p>JavaScript 中的数据类型</p><ul><li><p>简单(基本)数据类型</p><ul><li><p>Number、String、Boolean、Undefined、Null</p></li><li><p>直接存储值</p><ul><li>子主题 1</li></ul></li></ul></li><li><p>复杂(引用)数据类型</p><ul><li><p>Object、Array、Date...</p></li><li><p>存储引用</p><ul><li>子主题 1</li></ul></li></ul></li></ul></li></ul></li><li><p>JavaScript 中的内置对象</p><ul><li><p>什么是内置对象</p><ul><li><p>js 本身已经帮我们写好的对象</p></li><li><p>我们创建出来以后直接使用，不需要定义</p></li></ul></li><li><p>常见的内置对象 (待补充笔记和练习)</p><ul><li><p>Object 对象</p><ul><li><p>Object 对象 的方法</p><ul><li><p>constructor 对一个 Javascript 函数的引用,该函数是对象的构造函数。</p></li><li><p>hasOwnProperty() 检查对象是否有局部定义的(非继承的)、具有特定名字的属性。</p></li><li><p>isPrototypeOf() 检查对象是否是指定对象的原型。</p></li><li><p>propertyIsEnumerable() 检查指定的属性是否存在,以及是否能用 for/in 循环枚举。</p></li><li><p>toLocaleString() 返回对象地方化的字符串表示。</p></li><li><p>toString() 返回对象的字符串表示。</p></li><li><p>valueOf() 返回对象的原始值(如果存在)。</p></li></ul></li></ul></li><li><p>Date 对象</p><ul><li><p>创建 Date 对象</p><ul><li><p>let date = new Date()</p><ul><li>构造函数创建一个 Date 对象， 封装当前代码执行时间</li></ul></li><li><p>let date = new Date(&#39;12/03/2021 11:10:30&#39;)</p><ul><li><p>指定时间对象</p></li><li><p>日期格式：月份/日/年 时:分:秒</p></li></ul></li></ul></li><li><p>Date 对象方法</p><ul><li><p>获取</p><ul><li><p>getDate() 返回月中的某一天。</p></li><li><p>getDay() 返回一周中的某一天。</p></li><li><p>getFullYear() 返回日期中的年份。</p></li><li><p>getYear() (被废弃) 推荐使用 getFullYear()。</p></li><li><p>getUTCFullYear() 同上。</p></li><li><p>getMouth() 返回对象的月份字段。</p></li><li><p>getUTCMouth() 同上。</p></li><li><p>getMinutes() 返回对象的分钟字段。</p></li><li><p>getUTCMinutes() 同上。</p></li><li><p>getSeconds() 返回对象的秒字段。</p></li><li><p>getUTCSeconds() 同上。</p></li><li><p>getHours() 返回对象的小时字段。</p></li><li><p>getUTCHours() 同上。</p></li><li><p>getMilliseconds() 返回对象的毫秒字段。</p></li><li><p>getUTCMilliseconds() 同上。</p></li><li><p>getTime() 返回对象内部的(1970 年 1 月 1 日 0 分 0 秒到现今)毫秒，返回结果以时间戳表示。</p></li><li><p>获取当前时间戳</p><ul><li><p>let nowTime = new Date().getTime().now()</p></li><li><p>用来测试代码执行时间(性能)</p><ul><li>获取代码执行的开始和结束时间</li></ul></li></ul></li><li><p>getTimezoneoffset() 返回这个日期的本地时间和 UTC 表示之间的时差,以分钟为单位。</p></li></ul></li><li><p>设置</p><ul><li><p>setDate() 设置对象月中的某一天。</p></li><li><p>setUTCDate() 同上。</p></li><li><p>setFullYear() 设置对象中的年份字段。</p></li><li><p>setUTCFullYear() 同上。</p></li><li><p>setHours() 设置对象的小时字段。</p></li><li><p>setUTCHours() 同上。</p></li><li><p>setMilliseconds() 设置对象的毫秒字段。</p></li><li><p>setUTCMilliseconds() 同上。</p></li><li><p>setMinutes() 设置对象的分钟字段。</p></li><li><p>setUTCMinutes() 同上。</p></li><li><p>setMouth() 设置对象的月份字段。</p></li><li><p>setUTCMouth() 同上。</p></li><li><p>setSeconds() 设置对象的秒字段。</p></li><li><p>setUTCSeconds() 同上。</p></li><li><p>setTime() 使用毫秒的形式设置对象的各个字段。</p></li><li><p>setYear() 推荐使用 setFullYear()。</p></li></ul></li><li><p>其他方法</p><ul><li><p>toDateString() 返回日期的日期部分的字符串表示。</p></li><li><p>toGMTString() 推荐使用 toUTCString()。</p></li><li><p>toLacaleDataString() 返回日期的日期部分的字符串表示。</p></li><li><p>toLocaleString() 将对象转换成一个字符串。</p></li><li><p>toLacaleTimeString() 返回日期的时间部分的字符串表示。</p></li><li><p>toString() 将对象转换成一个字符串。</p></li><li><p>toTimeString() 将对象转换成一个字符串。</p></li><li><p>toString() 返回日期的时间部分的字符串表示。</p></li><li><p>toUTCString() 将对象转换成一个字符串。</p></li><li><p>valueOf() 将对象转换成它的内部毫秒格式。</p></li><li><p>parse() 静态方法，解析日期和时间的字符串表示,返回它的内部毫秒表示。</p></li><li><p>UTC() 静态方法，返回指定的 UTC 日期和时间的毫秒表示。</p></li></ul></li></ul></li></ul></li><li><p>Array 对象</p><ul><li><p>Array 对象方法</p><ul><li><p>length 数组包含的元素的个数。</p></li><li><p>concat() 给数组添加元素(此操作原数组的值不变)。</p></li><li><p>join() 把数组中所有元素转换成字符串,然后连接起来。</p></li><li><p>pop() 删除并返回数组最后一个元素。</p></li><li><p>push() 把一个元素添加到数组的尾部,返回值为数组的新长度(Bug:ver1.2 中,将返回数组最后一个元素)。</p></li><li><p>reverse() 在原数组上颠倒数组中元素的顺序。</p></li><li><p>shift() 删除并返回数组的头部元素。</p></li><li><p>slice() 返回数组的一个子数组,该方法不修改原数组(Bug:在 IE4 中 start 不能为负数)。</p></li><li><p>sort() 从原数组上对数组进行排序。</p></li><li><p>splice() 插入,删除,替换一个数组元素。</p></li><li><p>toLocalString() 把数组转换成一个局部字符串。</p></li><li><p>toString() 把数组转换成一个字符串。</p></li><li><p>unshift() 在数组头部插入一个元素, 返回值为数组的新长度。</p></li></ul></li></ul></li><li><p>Math 数学运算对象</p><ul><li><p><a href="https://www.w3school.com.cn/jsref/jsref_obj_math.asp" target="_blank" rel="noreferrer">https://www.w3school.com.cn/jsref/jsref_obj_math.asp</a></p></li><li><p><a href="https://www.runoob.com/jsref/jsref-obj-math.html" target="_blank" rel="noreferrer">https://www.runoob.com/jsref/jsref-obj-math.html</a></p></li><li><p>Math 数学运算对象 属性</p><ul><li><p>Math.E 常量 e,自然对数的底数。</p></li><li><p>Math.LN10 10 的自然对数。</p></li><li><p>Math.LN2 2 的自然对数。</p></li><li><p>Math.LOG10E 以 10 为底的 e 的对数。</p></li><li><p>Math.LOG2E 以 2 为底的 e 的对数。</p></li><li><p>Math.PI 常量 π。</p></li><li><p>Math.SQRT1_2 1/2 的平方根。</p></li><li><p>Math.SQRT2 2 的平方根。</p></li></ul></li><li><p>Math 数学运算对象 方法</p><ul><li><p>Math.abs()</p><ul><li>求绝对值。</li></ul></li><li><p>Math.acos()</p></li><li><p>Math.asin()</p></li><li><p>Math.acos()</p></li><li><p>Math.atan()</p></li><li><p>Math.atan2()</p><ul><li>计算 X 轴到一个点的角度。</li></ul></li><li><p>Math.ceil()</p><ul><li>对一个数上舍入。</li></ul></li><li><p>Math.cos()</p></li><li><p>Math.exp()</p><ul><li>计算 e 的指数。</li></ul></li><li><p>Math.floor()</p><ul><li>对一个数下舍入。</li></ul></li><li><p>Math.log()</p><ul><li>计算自然对数。</li></ul></li><li><p>Math.max()</p></li><li><p>Math.min()</p></li><li><p>Math.pow(1,2)</p><ul><li>计算参数 1 的参数 2 次方。</li></ul></li><li><p>Math.radom()</p></li><li><p>Math.round()</p></li><li><p>Math.sin()</p></li><li><p>Math.sqrt()</p></li><li><p>Math.tan()</p></li></ul></li></ul></li><li><p>Number 对象</p><ul><li><p>Number 对象方法</p><ul><li><p>global 对象是否具有性质 g。</p></li><li><p>ignoreCase 对象是否具有性质 i。</p></li><li><p>lastIndex 上次匹配后的字符位置,用于一个字符串中进行多次匹配。</p></li><li><p>multiline 对象是否具有性质 m。</p></li><li><p>source 正则表达式的源文本。</p></li><li><p>exec() 执行强大的、通用的模式匹配。</p></li><li><p>test() 检测一个字符串是否含有某个模式。</p></li></ul></li></ul></li><li><p>RegExp 正则表达式对象</p><ul><li><p>正则表达式是描述字符模式的对象。</p><ul><li><a href="https://www.runoob.com/jsref/jsref-obj-regexp.html" target="_blank" rel="noreferrer">https://www.runoob.com/jsref/jsref-obj-regexp.html</a></li></ul></li><li><p>正则表达式用于对字符串模式匹配及检索替换，是对字符串执行模式匹配的强大工具。</p></li><li><p>正则表达式对象创建</p><ul><li><p>构造函数创建</p><ul><li><p>var patt= new RegExp(pattern,modifiers);</p></li><li><p>参数(正则表达式模式, 修饰符 匹配)</p></li><li><p>修饰符匹配</p><ul><li><p>全局匹配</p></li><li><p>区分大小写的匹配</p></li><li><p>多行匹配</p></li></ul></li><li><p>优点：更灵活</p></li><li><p>注意：当使用构造函数创造正则对象时，需要常规的字符转义规则（在前面加反斜杠 \\）。比如，以下是等价的：</p><ul><li><p>var re = new RegExp(&quot;\\w+&quot;);</p></li><li><p>var re = /\\w+/;</p></li></ul></li></ul></li><li><p>字面量创建</p><ul><li><p>var patt= /pattern/modifiers;</p></li><li><p>/正则表达式模式/修饰符 匹配</p></li><li><p>修饰符匹配</p><ul><li><p>全局匹配</p></li><li><p>区分大小写的匹配</p></li><li><p>多行匹配</p></li></ul></li><li><p>优点：更简单</p></li></ul></li></ul></li><li><p>语法详解</p><ul><li><p>修饰符</p><ul><li><p>修饰符用于执行区分大小写和全局匹配:</p></li><li><p>i</p><ul><li>执行对大小写不敏感的匹配。</li></ul></li><li><p>g</p><ul><li>执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）。</li></ul></li><li><p>m</p><ul><li>执行多行匹配。</li></ul></li></ul></li><li><p>方括号</p><ul><li><p>方括号用于查找某个范围内的字符：</p></li><li><p>[abc]</p><ul><li>查找方括号之间的任何字符。</li></ul></li><li><p>[^abc]</p><ul><li>查找任何不在方括号之间的字符。</li></ul></li><li><p>[0-9]</p><ul><li>查找任何从 0 至 9 的数字。</li></ul></li><li><p>[a-z]</p><ul><li>查找任何从小写 a 到小写 z 的字符。</li></ul></li><li><p>[A-Z]</p><ul><li>查找任何从大写 A 到大写 Z 的字符。</li></ul></li><li><p>[A-z]</p><ul><li>查找任何从大写 A 到小写 z 的字符。</li></ul></li><li><p>[adgk]</p><ul><li>查找给定集合内的任何字符。</li></ul></li><li><p>[^adgk]</p><ul><li>查找给定集合外的任何字符。</li></ul></li><li><p>(red|blue|green)</p><ul><li>查找任何指定的选项。</li></ul></li></ul></li><li><p>元字符</p><ul><li><p>元字符（Metacharacter）是拥有特殊含义的字符：</p></li><li><p>.</p><ul><li>查找单个字符，除了换行和行结束符。</li></ul></li><li><p>\\w</p><ul><li>查找数字、字母及下划线。</li></ul></li><li><p>\\W</p><ul><li>查找非单词字符。</li></ul></li><li><p>\\d</p><ul><li>查找数字。</li></ul></li><li><p>\\D</p><ul><li>查找非数字字符。</li></ul></li><li><p>\\s</p><ul><li>查找空白字符。</li></ul></li><li><p>\\S</p><ul><li>查找非空白字符。</li></ul></li><li><p>\\b</p><ul><li>匹配单词边界。</li></ul></li><li><p>\\B</p><ul><li>匹配非单词边界。</li></ul></li><li><p>\\0</p><ul><li>查找 NULL 字符。</li></ul></li><li><p>\\n</p><ul><li>查找换行符。</li></ul></li><li><p>\\f</p><ul><li>查找换页符。</li></ul></li><li><p>\\r</p><ul><li>查找回车符。</li></ul></li><li><p>\\t</p><ul><li>查找制表符。</li></ul></li><li><p>\\v</p><ul><li>查找垂直制表符。</li></ul></li><li><p>\\xxx</p><ul><li>查找以八进制数 xxx 规定的字符。</li></ul></li><li><p>\\xdd</p><ul><li>查找以十六进制数 dd 规定的字符。</li></ul></li><li><p>\\uxxxx</p><ul><li>查找以十六进制数 xxxx 规定的 Unicode 字符。</li></ul></li></ul></li><li><p>量词</p><ul><li><p>n+</p><ul><li><p>匹配任何包含至少一个 n 的字符串。</p></li><li><p>例如，/a+/ 匹配 &quot;candy&quot; 中的 &quot;a&quot;，&quot;caaaaaaandy&quot; 中所有的 &quot;a&quot;。</p></li></ul></li><li><p>n*</p><ul><li><p>匹配任何包含零个或多个 n 的字符串。</p></li><li><p>例如，/bo*/ 匹配 &quot;A ghost booooed&quot; 中的 &quot;boooo&quot;，&quot;A bird warbled&quot; 中的 &quot;b&quot;，但是不匹配 &quot;A goat grunted&quot;。</p></li></ul></li><li><p>n?</p><ul><li><p>匹配任何包含零个或一个 n 的字符串。</p></li><li><p>例如，/e?le?/ 匹配 &quot;angel&quot; 中的 &quot;el&quot;，&quot;angle&quot; 中的 &quot;le&quot;。</p></li></ul></li><li><p>n{X}</p><ul><li><p>匹配包含 X 个 n 的序列的字符串。</p></li><li><p>例如，/a{2}/ 不匹配 &quot;candy,&quot; 中的 &quot;a&quot;，但是匹配 &quot;caandy,&quot; 中的两个 &quot;a&quot;，且匹配 &quot;caaandy.&quot; 中的前两个 &quot;a&quot;。</p></li></ul></li><li><p>n{X,}</p><ul><li><p>X 是一个正整数。前面的模式 n 连续出现至少 X 次时匹配。</p></li><li><p>例如，/a{2,}/ 不匹配 &quot;candy&quot; 中的 &quot;a&quot;，但是匹配 &quot;caandy&quot; 和 &quot;caaaaaaandy.&quot; 中所有的 &quot;a&quot;。</p></li></ul></li><li><p>n{X,Y}</p><ul><li><p>X 和 Y 为正整数。前面的模式 n 连续出现至少 X 次，至多 Y 次时匹配。</p></li><li><p>例如，/a{1,3}/ 不匹配 &quot;cndy&quot;，匹配 &quot;candy,&quot; 中的 &quot;a&quot;，&quot;caandy,&quot; 中的两个 &quot;a&quot;，匹配 &quot;caaaaaaandy&quot; 中的前面三个 &quot;a&quot;。注意，当匹配 &quot;caaaaaaandy&quot; 时，即使原始字符串拥有更多的 &quot;a&quot;，匹配项也是 &quot;aaa&quot;。</p></li></ul></li><li><p>n$</p><ul><li>匹配任何结尾为 n 的字符串。</li></ul></li><li><p>^n</p><ul><li>匹配任何开头为 n 的字符串。</li></ul></li><li><p>?=n</p><ul><li>匹配任何其后紧接指定字符串 n 的字符串。</li></ul></li><li><p>?!n</p><ul><li>匹配任何其后没有紧接指定字符串 n 的字符串。</li></ul></li></ul></li></ul></li><li><p>RegExp 对象方法</p><ul><li><p>patt.test(str)</p><ul><li>检测一个字符串是否含有某个模式或字符。返回布尔值 true 或 false。</li></ul></li><li><p>patt.exec()</p><ul><li><p>检索字符串中指定的值。返回找到的值，并确定其位置。</p></li><li><p>执行强大的、通用的模式匹配。</p></li></ul></li><li><p>patt.toString()</p><ul><li>返回正则表达式的字符串。</li></ul></li></ul></li><li><p>支持正则表达式的 String 对象的方法</p><ul><li><p>patt.search</p><ul><li>检索与正则表达式相匹配的值</li></ul></li><li><p>patt.match</p><ul><li>找到一个或多个正则表达式的匹配</li></ul></li><li><p>patt.replace</p><ul><li>替换与正则表达式匹配的子串</li></ul></li><li><p>patt.split</p><ul><li>把字符串分割为字符串数组</li></ul></li></ul></li><li><p>RegExp 对象属性</p><ul><li><p>patt.constructor</p><ul><li>返回一个函数，该函数是一个创建 RegExp 对象的原型。</li></ul></li><li><p>patt.global</p><ul><li>判断是否设置了 &quot;g&quot; 修饰符</li></ul></li><li><p>patt.ignoreCase</p><ul><li>判断是否设置了 &quot;i&quot; 修饰符</li></ul></li><li><p>patt.lastIndex</p><ul><li><p>用于规定下次匹配的起始位置</p></li><li><p>上次匹配后的字符位置,用于一个字符串中进行多次匹配。</p></li></ul></li><li><p>patt.multiline</p><ul><li>判断是否设置了 &quot;m&quot; 修饰符</li></ul></li><li><p>patt.source</p><ul><li>返回正则表达式的匹配模式 正则表达式的源文本。</li></ul></li></ul></li></ul></li><li><p>Error 对象</p><ul><li><p>Error 对象方法</p><ul><li><p>message</p><ul><li>提供异常详细信息的错误消息。</li></ul></li><li><p>name</p><ul><li>声名异常类型的字符串。</li></ul></li><li><p>toString()</p><ul><li>返回一个表示 Error 对象的字符串。</li></ul></li><li><p>子对象类型： 指示具体的错误类型。</p><ul><li><p>EvalError(执行错误)。</p></li><li><p>RangeError(在数字超出合法范围时抛出)。</p></li><li><p>ReferenceError(在读取不存在的变量时抛出)。</p></li><li><p>SyntaxError(抛出该错误用来通知语法错)。</p></li><li><p>TypeError(当一个值的类型错误时,抛出该异常)。</p></li><li><p>URIError(由 URI 的编码和解码方法抛出)。</p></li></ul></li></ul></li></ul></li><li><p>String 字符串对象</p><ul><li><p>String 字符串对象方法</p><ul><li><p>fromCharCode() 静态方法, 用作为参数而传递的字符代码创建一个新的字符串。</p></li><li><p>length 字符串的长度。</p></li><li><p>charAt() 抽取字符串中指定位置的字符。</p></li><li><p>charCodeAt() 返回字符串中指定位置的字符编码。</p></li><li><p>concat() 把一个或多个值连接到字符串上。</p></li><li><p>indexOf() 在字符串中检索一个字符或一个子串。</p></li><li><p>lastIndexOf() 在字符串中向后检索一个字符或一个子串。</p></li><li><p>localeCompare() 用本地特定顺序来比较两个字符串。</p></li><li><p>match() 用正则表达式执行模式匹配。</p></li><li><p>replace() 用正则表达式执行查找、替换操作。</p></li><li><p>search() 检索字符串中与正则表达式匹配的子串。</p></li><li><p>slice() 返回字符串的一个片断或一个子串。</p></li><li><p>split() 把字符串分割成一个字符串数组,在指定的分界字符处或正则表达式处执行分割。</p></li><li><p>substring() 从字符串中抽取一个子串。</p></li><li><p>substr() 从字符串中抽取一个子串。</p></li><li><p>toLowerCase() 把字符串中所有字符转换成小写的,然后返回一个副本。</p></li><li><p>toString() 返回原始的字符串值。</p></li><li><p>toUpperCase() 把字符串中所有字符转换成大写的,然后返回一个副本。</p></li><li><p>valueOf() 返回原始字符串值。</p></li></ul></li></ul></li><li><p>Function 对象</p><ul><li><p>Function 对象方法</p><ul><li><p>arguments Arguments 对象, 反对使用该属性。</p></li><li><p>caller 对调用当前函数的 Funciton 对象的引用,反对使用该属性。</p></li><li><p>length 在声名函数时指定的命名参数个数。</p></li><li><p>prototype 一个对象,用于构造函数,这个对象定义的属性和方法由构造函数创建的所有对象共享。</p></li><li><p>apply() 将函数作为指定对象的方法来调用,传递给它的是指定的参数数组。</p></li><li><p>call() 将函数作为指定对象的方法来调用,传递给它的是指定的参数。</p></li><li><p>toString() 返回函数的字符串表示。</p></li></ul></li></ul></li></ul></li><li><p>全局属性</p><ul><li><p>Infinity 表示正无穷大的数值</p></li><li><p>NaN 非数字值</p></li><li><p>undefined 未定义的值</p></li><li><p>decodeURI() 对 encodeURI()转义的字符串解码。</p></li><li><p>decodeURIComponent() 对 encodeURIComponent()转义的字符串解码。</p></li><li><p>encodeURI() 返回参数的副本,其中某些字符被十六进制的转义序列替换了, 建议使用 encodeURIComponent()对字符串进行编码。</p></li><li><p>encodeURIComponent() 返回参数的副本,其中某些字符被十六进制的转义序列替换了。</p></li><li><p>escape() 用转义序列替换某些字符来字符串编码。</p></li><li><p>eval() 计算 Javascript 代码串,返回结果。</p></li><li><p>isFinite() 检验一个值是否是无穷大的数字。</p></li><li><p>isNaN() 检验一个值是否是非数字的值。</p></li><li><p>parseFloat() 从字符串解析一个数字。</p></li><li><p>parseInt() 从字符串解析一个数字。</p></li><li><p>unescape() 对用 escape()编码的字符串解码。</p></li></ul></li><li><p>Array 高级 API</p><ul><li><p>sort()</p><ul><li><p>按升序排列数组--即最小的值位于最前面，最大的值排在最后面</p></li><li><p>存在问题</p><ul><li>只能通过第一位排列</li></ul></li><li><p>解决办法</p><ul><li><p>通过回调函数进行规制设置</p></li><li><p>a - b 升序</p></li><li><p>b - a 降序</p></li><li><p>内部运用了冒泡排序</p></li></ul></li></ul></li><li><p>slice()</p><ul><li><p>返回值 返回一个新的数组，包含从 start 到 end（不包括该元素）的 arrayObject 中的元素。</p></li><li><p>参数说明</p><ul><li><p>start</p><ul><li>必需（否则没有意义）。规定从何处开始选取，即提取起始处的索引（从 0 开始），从该索引开始提取原数组元素。如果是负数，那么它规定从数组尾部开始算起的位置。也就是说，-1 指最后一个元素，-2 指倒数第二个元素，以此类推。如果没有指定该参数，则从索引 0 开始。如果该参数大于原数组的长度，则会返回空数组。</li></ul></li><li><p>end</p><ul><li>可选。规定从何处结束选取，该参数是数组片断结束处的数组下标，即提取终止处的索引（从 0 开始），在该索引处结束提取原数组元素，该方法会提取原数组中索引从 start 到 end 的所有元素（包含 start，但不包含 end）。如果这个参数是负数，那么它规定的是从数组尾部开始算起的元素。如果没有指定该参数，那么切分的数组包含从 start 到数组结束的所有元素。如果该参数大于数组的长度，也会一直提取到原数组末尾。</li></ul></li></ul></li></ul></li><li><p>splice()</p><ul><li><p>实现删除、插入、替换</p><ul><li><p>删除：删除任意数量的项，只需指定 2 个参数：要删除的第一项位置和要删除的项数。例如：splice(0,2)会删除数组中的前两项</p></li><li><p>插入：可以向指定位置插入任意数量的项，只需提供 3 个参数：起始位置、0 （要删除的项）和要插入的项。例如， splice（2,0,11,12）会从当前数组的位置开始插入 11 和 12</p></li><li><p>替换：可以向指定位置插入任意数量的项。且同时删除任意数量的项，只需要指定三个参数：起始位置、要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等。例如： splice(2,1,4,6) 会删除当前数组位置 2 的项，然后再从位置 2 开始插入 4 和 6</p></li></ul></li><li><p>清空数组</p><ul><li>arr.splice(0);</li></ul></li></ul></li><li><p>forEach()</p><ul><li><p>对数组进行遍历循环，对数组中的每一项运行给定函数</p></li><li><p>格式</p><ul><li>arr.forEach(function(value,index){})</li></ul></li></ul></li><li><p>map()</p><ul><li>&quot;映射&quot;：对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。</li></ul></li><li><p>filter()</p><ul><li>&quot;过滤&quot; 功能，数组中的每一项运行给定函数，返回满足过滤条件组成的数组</li></ul></li><li><p>every()</p><ul><li>判断数组中每一项都是否满足条件，只有所有项都满足条件，才会返回 true。</li></ul></li><li><p>some()</p><ul><li><p>判断数组中每一项都是否满足条件，只要有一项满足条件，才会返回 true。</p></li><li><p>查询数组中唯一元素的方法</p></li></ul></li></ul></li><li><p>定时器</p><ul><li><p><a href="https://www.jb51.net/article/45215.htm" target="_blank" rel="noreferrer">https://www.jb51.net/article/45215.htm</a></p></li><li><p>1.倒计定时器：timename=setTimeout(&quot;function();&quot;,1000);</p></li><li><p>2.循环定时器：timename=setInterval(&quot;function();&quot;,1000);</p></li></ul></li></ul></li></ul><h3 id="javascript-垃圾回收机制-gc" tabindex="-1">JavaScript 垃圾回收机制(GC) <a class="header-anchor" href="#javascript-垃圾回收机制-gc" aria-label="Permalink to &quot;JavaScript 垃圾回收机制(GC)&quot;">​</a></h3><ul><li><p>1.程序运行过程中会产生垃圾，垃圾积攒过多会导致程序运行速度过慢，所以我们需要一个垃圾回收机制，来处理程序运行过程产生的垃圾</p></li><li><p>2.当一个对象没有任何变量或者属性对它引用，此时我们将永远无法操作该对象，此时这种对象就是一个垃圾，这种对象过多会占用大量的内存空间，导致程序运行变慢，所以必须进行垃圾清理</p></li><li><p>3.在 JS 中拥有自动的垃圾回收机制，会自动将这些垃圾从内存中销毁，我们不需要也不能进行垃圾回收的操作</p></li><li><p>4.我们需要做的只是将不再使用的对象设置 null 即可</p></li></ul><h3 id="数据结构" tabindex="-1">数据结构 <a class="header-anchor" href="#数据结构" aria-label="Permalink to &quot;数据结构&quot;">​</a></h3><ul><li><p>堆栈结构</p></li><li><p>队列结构</p></li><li><p>链表</p></li></ul><h3 id="this-指向" tabindex="-1">this 指向 <a class="header-anchor" href="#this-指向" aria-label="Permalink to &quot;this 指向&quot;">​</a></h3><ul><li><p>1.全局作用域或者普通函数中的 this 指向全局对象 window。(定时器里面的 this 也指向 window)</p></li><li><p>2.在以方法的形式调用时，谁调用，this 就指向谁</p></li><li><p>3.构造函数中 ，this 指向构造函数的实例对象</p><ul><li><p>function Fn(){ console.log(this); } var fn = new Fn()</p></li><li><p>this 指向 fn</p></li></ul></li></ul><h3 id="同步、异步-多线程" tabindex="-1">同步、异步 多线程 <a class="header-anchor" href="#同步、异步-多线程" aria-label="Permalink to &quot;同步、异步 多线程&quot;">​</a></h3><ul><li><p>同步任务</p><ul><li>同步任务都在主线程上执行，形成一个执行栈</li></ul></li><li><p>异步任务</p><ul><li><p>JS 异步是通过回调函数实现的</p></li><li><p>一般三种类型</p><ul><li><p>普通事件，如 click、resize 等</p></li><li><p>资源加载，如 load、error 等</p></li><li><p>定时器，包括 setInterval、setTimeout 等</p></li></ul></li><li><p>异步任务相关回调函数添加到任务队列中(任务队列也称消息队列)</p></li></ul></li><li><p>JS 执行机制</p><ul><li><p>1.先执行执行栈中的同步任务</p></li><li><p>2.异步任务(回调函数)放入任务队列中</p></li><li><p>3.一旦执行栈中的所有同步任务执行完毕，系统就会按次序读取任务队列中的异步任务，于是被读取的异步任务结束等待状态，进入执行栈，开始执行</p></li><li><p>由于主线程不断的重复获得任务、执行任务、再获取任务、再执行，所以这种机制被称为事件循环(event loop)</p></li></ul></li><li><p>多线程库</p><ul><li>Concurren.Thread.js</li></ul></li></ul><h2 id="进阶" tabindex="-1">进阶 <a class="header-anchor" href="#进阶" aria-label="Permalink to &quot;进阶&quot;">​</a></h2><h3 id="输入输出" tabindex="-1">输入输出 <a class="header-anchor" href="#输入输出" aria-label="Permalink to &quot;输入输出&quot;">​</a></h3><ul><li><p>输出数据</p><ul><li><p>使用 document.write() 方法将内容写到 HTML 文档中。</p><ul><li>我的第一个 Web 页面 我的第一个段落。 点我 function myFunction() { document.write(Date()); }</li></ul></li><li><p>使用 innerHTML 写入到 HTML 元素。</p><ul><li><p>我的第一个 Web 页面 我的第一个段落 document.getElementById(&quot;demo&quot;).innerHTML = &quot;段落已修改。&quot;;</p><ul><li><p>document.getElementById(&quot;demo&quot;) 是使用 id 属性来查找 HTML 元素的 JavaScript 代码 。</p></li><li><p>innerHTML = &quot;段落已修改。&quot; 是用于修改元素的 HTML 内容(innerHTML)的 JavaScript 代码。</p></li></ul></li></ul></li><li><p>使用 console.log() 写入到浏览器的控制台。</p><ul><li>我的第一个 Web 页面 a = 5; b = 6; c = a + b; console.log(c);</li></ul></li></ul></li><li><p>弹出框</p><ul><li><p>window.alert() 弹出警告框。</p><ul><li>window.alert(5 + 6);</li></ul></li><li><p>弹出数据输入框</p><ul><li>prompt(&#39;请输入你的年龄&#39;)</li></ul></li><li><p>弹出框警示框</p><ul><li>alert(&#39;弹出的数据&#39;)</li></ul></li></ul></li></ul><h3 id="算法" tabindex="-1">算法 <a class="header-anchor" href="#算法" aria-label="Permalink to &quot;算法&quot;">​</a></h3><ul><li><p><a href="https://www.jianshu.com/p/0f56afd5122e" target="_blank" rel="noreferrer">https://www.jianshu.com/p/0f56afd5122e</a></p></li><li><p>1.冒泡排序（Bubble Sort）</p><ul><li>重复地走访过要排序的数列，一次比较两个元素， 如果它们的顺序错误就把它们交换过来 <ul><li>//定义三个变量 a、b、c //用户输入 //冒泡排序 var tamp; if(b &gt; c){ temp=a a=b; b=tamp } if(a &gt; b){ temp=a a=b; b=tamp }</li></ul></li></ul></li><li><p>2.选择排序（Selection Sort）</p></li><li><p>3.插入排序（Insertion Sort）</p></li><li><p>4.希尔排序（Shell Sort）</p></li><li><p>5.归并排序（Merge Sort）</p></li><li><p>6.快速排序（Quick Sort）</p></li><li><p>7.堆排序（Heap Sort）</p></li><li><p>8.计数排序（Counting Sort）</p></li><li><p>9.桶排序（Bucket Sort）</p></li><li><p>10.基数排序（Radix Sort）</p></li></ul><h3 id="bom" tabindex="-1">BOM <a class="header-anchor" href="#bom" aria-label="Permalink to &quot;BOM&quot;">​</a></h3><ul><li><p>简介</p><ul><li><p>JavaScript 操作浏览器的部分功能的 API 对象模型</p></li><li><p>提供了独立内容，而与浏览器窗口进行交互的对象</p></li><li><p>提供了独立用于管理窗口与窗口之间的通讯，因此其核心对象是 window</p></li><li><p>BOM 由一系列相关的对象构成，并且每个对象对提供了很多方法与属性</p></li></ul></li><li><p>需要掌握什么？</p><ul><li><p>掌握与浏览器窗口交互的一些对象</p><ul><li><p>可以移动、调整浏览器大小的 window 对象</p></li><li><p>可以用于导航的 location 对象与 history 对象</p></li><li><p>可以获取浏览器、操作系统与用户屏幕信息的 navigator 与 screen 对象</p></li></ul></li></ul></li><li><p>window 对象</p><ul><li><p>常见事件</p><ul><li><p>加载事件</p><ul><li><p>window.addEventListener(&#39;load&#39;,function(){})</p><ul><li>等页面内容全部加载完毕，包含 dom 元素 图片 flash css 等</li></ul></li><li><p>window.addEventListener(&#39;DOMContentLoaded&#39;,function(){})</p><ul><li>dom 加载完毕，不包含图片 flash css 等就可以执行 加载速度比 load 更快</li></ul></li></ul></li><li><p>调整窗口大小的事件</p><ul><li>window.addEventListener(&#39;resize&#39;,function(){ console.log(window.innerWidth) }) <ul><li>window.innerWidth <ul><li>窗口大小</li></ul></li></ul></li></ul></li><li><p>setTimeout() 定时器</p><ul><li><p>setTimeout(function(){ console.log(&#39;时间到了&#39;) }2000)</p></li><li><p>setTimeout(函数,2000)</p></li><li><p>停止定时器</p><ul><li>clearTimeout(定时器名字)</li></ul></li><li><p>只调用一次</p></li></ul></li><li><p>setInterval() 定时器</p><ul><li><p>setInterval(函数,2000)</p></li><li><p>停止定时器</p><ul><li>clearInterval(定时器名字)</li></ul></li><li><p>默认重复调用</p></li></ul></li><li><p>pageshow</p><ul><li><p>window.addEventListener(&#39;pageshow&#39;,function(){})</p></li><li><p>重新加载页面触发的事件</p></li></ul></li></ul></li><li><p>主要知识点</p><ul><li><p>既是 ECMAscript 规定的全局 global 对象，又是 JavaScript 访问浏览器窗口的一个接口</p></li><li><p>系统对话框</p><ul><li><p>系统对话框，这些对话框外观由操作系统/浏览器决定，css 不起作用，所以很多时候需要自定义对话框</p></li><li><p>alert()</p><ul><li>在当前页面上弹出警告框，并且显示内容</li></ul></li><li><p>confirm()</p><ul><li><p>功能：弹出一个带确定和取消按钮的提示框</p></li><li><p>返回值：</p><ul><li><p>点击确定返回 true</p></li><li><p>点击取消返回 false</p></li></ul></li></ul></li><li><p>prompt()</p><ul><li><p>功能：弹出一个带输入框的提示框</p></li><li><p>参数：</p><ul><li><p>第一个参数：提示面板上的内容。</p></li><li><p>第二个参数：输入框默认的值。</p></li></ul></li><li><p>返回值：</p><ul><li><p>点击确定，返回输入框中的内容</p></li><li><p>点击取消，返回 null</p></li></ul></li></ul></li></ul></li><li><p>移动窗口，调整窗口大小</p></li><li><p>导航和打开窗口</p></li><li><p>时序相关的函数(原来的 BOM 实现，而非 ECMAjavascript)</p></li><li><p>open 方法</p><ul><li><p>1.要加载的 URL</p></li><li><p>2.窗口的名称或者窗口的目标</p></li><li><p>3.一个特性的字符串</p></li></ul></li></ul></li><li><p>属性和方法</p><ul><li><p>所有的全局变量都是 window 的属性</p><ul><li><p>window 正常情况下是省略写</p></li><li><p>var num = 0 window.num</p></li></ul></li><li><p>所有全局的函数都是 window 的方法</p></li></ul></li></ul></li><li><p>document 对象</p><ul><li><p>每个载入浏览器的 HTML 文档都会成为 Document 对象； Document 对象可以对 HTML 页页面中的所有元素进行访问， 常用的操作有：增、删、改、查。</p></li><li><p>Document 对象是 Windows 对象的一部分， 可通过 window.document 属性进行访问</p></li><li><p>常用的对象方法</p><ul><li><p>常规方法</p><ul><li><p>close()</p><ul><li>关闭用 document.open()方法的输出流，并显示选定的数据</li></ul></li><li><p>open()</p><ul><li>打开一个流，以收集任何 document.write() 或者 document.writeIn()方法的输出。</li></ul></li><li><p>write()</p><ul><li>向文档写 HTML 表达式或 JavaScript 代码</li></ul></li><li><p>writeIn()</p><ul><li>等同于 write()方法，不同的是在每个表达式之后的换行符</li></ul></li></ul></li><li><p>内置属性方法</p><ul><li><p>document.head</p><ul><li>获取头部</li></ul></li><li><p>document.body</p><ul><li>获取 body</li></ul></li><li><p>document.title</p><ul><li>获取 title</li></ul></li></ul></li></ul></li></ul></li><li><p>frames</p></li><li><p>location 对象</p><ul><li><p>属性</p><ul><li><p>location.href</p><ul><li><p>获取或者设置整个 URL</p></li><li><p>跳转链接页面</p></li></ul></li><li><p>location.host</p><ul><li>返回主机(域名) www.xxxx.com</li></ul></li><li><p>location.port</p><ul><li>返回端口号，如果没有返回空字符串</li></ul></li><li><p>location.pathname</p><ul><li>返回路径</li></ul></li><li><p>location.search</p><ul><li><p>返回参数</p></li><li><p>页面的值传递</p></li><li><p>参数截取分割</p><ul><li><p>location.search.substr(截取位置,截取几个字符)</p></li><li><p>再分割</p><ul><li>.split(&#39;=&#39;)</li></ul></li></ul></li></ul></li><li><p>location.hash</p><ul><li>返回片段 #后面内容 常见于链接 锚点</li></ul></li></ul></li><li><p>方法</p><ul><li><p>location.assign()</p><ul><li>跟 href 一样，可以跳转页面(也称为重定向页面) 可以后退返回原页面</li></ul></li><li><p>location.replace()</p><ul><li>替换当前页面，可以跳转，但不能退回原页面</li></ul></li><li><p>location.reload()</p><ul><li>重新加载页面，相当于刷新按钮或者 f5 ，如果参数为 true 强制刷新 ctrl+f5</li></ul></li></ul></li></ul></li><li><p>navigator 对象</p><ul><li><p>userAgent</p><ul><li><p>浏览器标识对象</p></li><li><p>返回由客户机发送服务器的 user-agent 头部的值。</p></li><li><p>判断设备环境和浏览器</p><ul><li>实现不同页面的跳转</li></ul></li></ul></li></ul></li><li><p>history 对象</p><ul><li><p>history.length 输出历史记录的条数</p></li><li><p>history.back()</p><ul><li><pre><code>加载 history 列表中的前一个 URL。
</code></pre></li></ul></li><li><p>history.forward()</p><ul><li><pre><code>加载 history 列表中的下一个 URL。
</code></pre></li></ul></li><li><p>history.go()</p><ul><li><p>history.go(1)</p><ul><li><p>前进 1 步</p></li><li><p>正整数 前进对应数字条记录</p></li></ul></li><li><p>history.go(-1)</p><ul><li><p>后退 1 步</p></li><li><p>负整数 后退对应数字条记录</p></li></ul></li><li><p>history.go(0)</p><ul><li>刷新当前页面</li></ul></li><li><p>加载 history 列表中的某个具体页面。</p></li></ul></li></ul></li><li><p>screen</p></li></ul><h3 id="dom" tabindex="-1">DOM <a class="header-anchor" href="#dom" aria-label="Permalink to &quot;DOM&quot;">​</a></h3><ul><li><p>JavaScript 操作网页上的元素的 API 文档对象模型</p></li><li><p>原理分析</p><ul><li>HTML 加载完毕，渲染引擎会在内存中把 HTML 文档，生成一个 DOM 树，getElementById 是获取内中 DOM 上的元素节点、然后操作的时候修改的是该元素的属性</li></ul></li><li><p>DOM 文档对象模型</p><ul><li><p>document 是文档对象模型的一部分</p></li><li><p>DOM 是一个复杂的数据类型</p></li></ul></li><li><p>Event 事件对象</p><ul><li><p>文档参考</p><ul><li><p>JavaScript 是一门以事件驱动为核心的一门语言</p></li><li><p><a href="https://www.runoob.com/jsref/dom-obj-document.html" target="_blank" rel="noreferrer">https://www.runoob.com/jsref/dom-obj-document.html</a></p></li></ul></li><li><p>事件</p><ul><li><p>事件三要素</p><ul><li><p>事件源、事件、事件驱动程序</p></li><li><p>获取事件源、绑定事件、书写事件驱动程序</p></li></ul></li><li><p>事件步骤</p><ul><li><p>事件源：一些 html 标签：比如：div、span、button 等标签</p></li><li><p>事件：鼠标操作：鼠标经过、鼠标移动、鼠标按下...</p></li><li><p>事件驱动：事件成功运行</p></li><li><p>编码</p><ul><li><p>获取事件源</p><ul><li>子主题 1</li></ul></li><li><p>绑定事件</p><ul><li>子主题 1</li></ul></li><li><p>书写事件驱动程序</p><ul><li>DOM 操作</li></ul></li></ul></li></ul></li></ul></li><li><p>四个修改键：</p><ul><li><p>shiftKey 如果按下 shift 键，值就是 true，否则是 false</p></li><li><p>ctrlKey</p></li><li><p>altKey</p></li><li><p>metakey （windows 键 mac 电脑下 command 键）</p></li></ul></li><li><p>获取 html 页面元素 (事件源的获取方式) (DOM 查询)</p><ul><li><p>document.getElementById(&#39;id&#39;)</p><ul><li>获取 id</li></ul></li><li><p>document.getElementsByName()</p><ul><li>查询 name 属性的元素</li></ul></li><li><p>document.getElementByTagName(&#39;li&#39;)</p><ul><li>获取标签名</li></ul></li><li><p>document.getElementByClassName(&#39;btn&#39;)</p><ul><li>获取类名</li></ul></li><li><p>document.querySelector(&#39;#adv&gt;img&#39;)</p><ul><li>获取#adv 的第一个 img 子元素</li></ul></li><li><p>document.querySelectorAll(&#39;#adv&gt;img&#39;)</p><ul><li>获取#adv 的所有 img 子元素</li></ul></li><li><p>document.body</p><ul><li>返回文档的 body 元素</li></ul></li><li><p>document.documentElement</p><ul><li>返回文档的根节点</li></ul></li></ul></li><li><p>元素对象</p></li><li><p>属性对象</p></li><li><p>访问关系</p><ul><li><p>节点的获得</p><ul><li><p>节点的访问关系，以属性的方式存在的</p></li><li><p>DOM 的节点并不是孤立的，因此可以通过 DOM 节点之间的相对关系对它们进行访问</p></li></ul></li><li><p>获取 body、html 节点</p><ul><li><p>获取 body 元素</p><ul><li>document.body</li></ul></li><li><p>获取 html 元素对象</p><ul><li>document.documentElement</li></ul></li></ul></li><li><p>父节点(parentNode)</p><ul><li><p>调用者就是节点，一个节点只有一个父节点</p></li><li><p>节点.parentNode</p></li></ul></li><li><p>兄弟节点</p><ul><li><p>单词</p><ul><li><p>Sibling</p><ul><li>兄弟</li></ul></li><li><p>Next</p><ul><li>下一个</li></ul></li><li><p>Previous</p><ul><li>上一个</li></ul></li></ul></li><li><p>下一个兄弟节点</p><ul><li><p>nextSibling</p><ul><li><p>调用者是节点</p></li><li><p>IE678 下中指下一个元素节点(标签)</p></li><li><p>在火狐谷歌 IE9+以后都是指下一个节点(包括空文档和换行节点)</p></li></ul></li><li><p>nextElementSibling</p><ul><li>在火狐谷歌 IE9+指的是下一个元素节点</li></ul></li><li><p>总结：在 IE678 中用 nextSibling，在火狐谷歌 IE9+以后用 nextElementSibling</p></li><li><p>下一个兄弟节点 = 节点.nextElementSibling || 节点.nextSibling</p></li></ul></li><li><p>上一个兄弟节点</p><ul><li><p>previousSibling</p></li><li><p>previousElementSibling</p></li></ul></li></ul></li><li><p>单个节点</p><ul><li><p>第一个子节点</p><ul><li><p>firstChild</p><ul><li>调用者是父节点，IE678 中指第一个子元素节点（标签） 在火狐谷歌 IE9+以后都是指第一个节点（包括空文档和换行节点）</li></ul></li><li><p>firstElementChild</p><ul><li>在火狐谷歌 IE9 都指的第一个元素节点</li></ul></li><li><p>总结</p><ul><li>第一个子节点 = 父节点.firstElementChild || 父节点.firstChild</li></ul></li></ul></li><li><p>最后一个子节点</p><ul><li><p>latstChild</p><ul><li>调用者是父节点，IE678 中指最后一个子元素节点（标签） 在火狐谷歌 IE9+以后都是指最后一个节点（包括空文档和换行节点）</li></ul></li><li><p>latstElementChild</p><ul><li>在火狐谷歌 IE9 都指的最后一个元素节点</li></ul></li></ul></li><li><p>所有节点</p><ul><li><p>childNodes</p><ul><li><p>标准属性，返回指定元素的子元素集合， 包括 HTML 节点，所有属性，文本节点</p></li><li><p>注意：火狐，谷歌等高版本会把换行也看做是子节点</p><ul><li><p>nodeType == 1</p><ul><li>表示是元素节点 <ul><li>元素是标签</li></ul></li></ul></li><li><p>nodeType == 2</p><ul><li>表示是属性节点</li></ul></li><li><p>nodeType == 3</p><ul><li>表示是文本节点</li></ul></li></ul></li><li><p>获取所有子节点</p><ul><li>子节点数组 = 父节点.childNodes;</li></ul></li></ul></li><li><p>children</p><ul><li><p>非标准属性，返回指定元素的子元素集合</p></li><li><p>但只返回 HTML 节点，不返回文本节点，虽不是标准的 DOM 属性 但和 innerHTML 方法一样，得到了几乎所有浏览器的支持</p></li><li><p>注意</p><ul><li><p>children 在 IE678 中包含注释节点</p></li><li><p>在 IE678 中，注释节点不要写在里面</p></li></ul></li><li><p>获取所有节点</p><ul><li>子节点数组 = 父节点.children;</li></ul></li></ul></li></ul></li></ul></li><li><p>获取任意兄弟节点</p><ul><li>节点自己.parentNode.children[index];</li></ul></li><li><p>获取子节点</p><ul><li>节点自己.childNodes</li></ul></li></ul></li><li><p>节点操作</p><ul><li><p>节点源获取</p><ul><li><p>获取父节点</p><ul><li><p>.parentNode</p><ul><li><p>得到的是离元素最近的父节点</p></li><li><p>如果找不到则返回为 null</p></li></ul></li></ul></li><li><p>获取子节点</p><ul><li><p>.childNodes</p><ul><li><p>返回所有子节点</p><ul><li><p>包括文本节点和元素节点</p></li><li><p>换行为文本节点</p></li></ul></li><li><p>.childNodes[0].nodeType === 1</p><ul><li><p>这个时候会输出第一个元素节点</p></li><li><p>for 循环判断节点是否 相等 从而得到元素子节点</p></li><li><p>不推荐使用</p></li></ul></li></ul></li><li><p>.firstChild</p><ul><li>返回第一个子节点 <ul><li>包括文本节点和元素节点</li></ul></li></ul></li><li><p>.lastChild</p><ul><li>最后一个子节点 <ul><li>包括文本节点和元素节点</li></ul></li></ul></li><li><p>.firstElementChild</p><ul><li>返回第一个子节点 <ul><li>只是元素节点</li></ul></li></ul></li><li><p>.lastElementChild</p><ul><li>最后一个子节点 <ul><li>只是元素节点</li></ul></li></ul></li><li><p>.children[1]</p><ul><li><p>指定第 1+1 个节点</p></li><li><p>.children[ol.children.length - 1]</p><ul><li>获取最后一个节点</li></ul></li></ul></li></ul></li><li><p>获取兄弟节点</p><ul><li><p>div.nextSibling</p><ul><li>获取下一个兄弟节点 <ul><li>包含元素节点和文本节点</li></ul></li></ul></li><li><p>div.nextElenmentSibling</p><ul><li>获取下一个兄弟节点 <ul><li>只包含元素节点</li></ul></li></ul></li><li><p>div.previousSibling</p><ul><li>获取上一个兄弟节点 <ul><li>包含元素节点和文本节点</li></ul></li></ul></li><li><p>div.previousElenmentSibling</p><ul><li>获取上一个兄弟节点 <ul><li>只包含元素节点</li></ul></li></ul></li></ul></li></ul></li><li><p>节点属性(节点.属性)</p><ul><li><p>获取：getAttribute(名称)</p><ul><li>img.getAttribute(&quot;src&quot;)</li></ul></li><li><p>获取属性</p><ul><li><p>ele.dataset.属性 ele.dataset.[&#39;属性&#39;]</p><ul><li><p>h5 新增的属性获取方法</p></li><li><p>如果自定义属性里面有多个-符号连接的单词， 我们获取的时候采取驼峰命名法</p><ul><li><p>l-list</p></li><li><p>lList</p></li></ul></li></ul></li></ul></li><li><p>设置：setAttribute(名称,值)</p><ul><li>img.setAttribute(&quot;src&quot;,&quot;img/img.png&quot;)</li></ul></li><li><p>删除：removeAttribute(名称)</p><ul><li>img.removeAttribute(&quot;src&quot;)</li></ul></li><li><p>注意 IE67 不支持</p></li></ul></li><li><p>节点操作-CRUD(增删改查)</p><ul><li><p>创建节点</p><ul><li>var li = document.createElement(&#39;li&#39;)；</li></ul></li><li><p>添加节点</p><ul><li><p>父节点.appendChild(li)；</p></li><li><p>父节点.insertBefore(新节点 , 参考节点);</p><ul><li><p>在参考节点前插入</p></li><li><p>如果参考节点为 null,那么他将在节点最后插入一个节点</p></li></ul></li><li><p>父节点.insertAdjacentHTML(&#39;位置&#39;,li);</p><ul><li><p>&#39;位置&#39;参数</p><ul><li><p>元素自身的前面</p><ul><li>beforbegin</li></ul></li><li><p>插入元素内部的 第一个子节点前</p><ul><li>afterbegin</li></ul></li><li><p>插入元素内部的 最后一个子节点之后</p><ul><li>beforeend</li></ul></li><li><p>元素自身的后面</p><ul><li>afterend</li></ul></li></ul></li><li><p>参数 2</p><ul><li>要插入的元素</li></ul></li></ul></li></ul></li><li><p>删除节点</p><ul><li><p>父节点.removeChild(子节点)；</p><ul><li><p>需要先找到他的父节点，再删除</p></li><li><p>this.parentNode</p></li></ul></li><li><p>当前节点.remove();</p></li></ul></li><li><p>复制节点</p><ul><li><p>oldNode.cloneNode(true)</p><ul><li><p>想要复制的节点调用这个函数 cloneNode(),得到一个新节点。</p></li><li><p>新节点 = 要复制的节点.cloneNode(参数); 参数可选复制节点</p></li><li><p>方法内部可以传参</p><ul><li><p>如果是 true，深层复制(深拷贝)，复制标签和里面的内容</p></li><li><p>如果是 false，浅层复制(浅拷贝)，只复制节点本身，不复制里面的内容</p></li></ul></li></ul></li></ul></li></ul></li><li><p>其他</p><ul><li><p>表单属性</p><ul><li><p>value</p><ul><li>表单 value 值属性</li></ul></li><li><p>disable</p><ul><li>禁用</li></ul></li><li><p>type</p><ul><li><p>表单类型</p><ul><li><p>text</p></li><li><p>password</p></li></ul></li></ul></li></ul></li><li><p>innerHTML(标准)</p><ul><li><p>获取双闭合标签里面的内容。（识别标签）</p></li><li><p>可以在里面直接写标签</p><ul><li>div.html = &#39;今天是：2021/05/30&#39;</li></ul></li></ul></li><li><p>innerText</p><ul><li>获取双闭合标签里面的内容。（不识别标签）</li></ul></li><li><p>三种动态创建元素的区别</p><ul><li><p>document.write()</p><ul><li>是直接将内容写入页面的内容流 但是页面的文档流执行完毕，则它会导致页面全部重绘</li></ul></li><li><p>element.innerHTML</p><ul><li><p>是将内容写入某个 DOM 节点，不会导致页面重绘</p></li><li><p>创建多个元素效率更高(不要拼接字符串，采取数组形式拼接-array.push(&#39;&#39;))，结构稍微复杂</p></li></ul></li><li><p>document.creareElement()</p><ul><li>创建多个元素效率稍微低一点，但结构更清晰</li></ul></li></ul></li></ul></li></ul></li><li><p>事件绑定</p><ul><li><p>匿名函数绑定</p><ul><li>事件源.事件 = function(){事件驱动程序}</li></ul></li><li><p>函数名绑定</p><ul><li>div.onclick = fn; function fn(){ alert(&quot;hello word!&quot;); }</li></ul></li><li><p>事件监听方式</p><ul><li><p>eventTarget.addEventListener(type,listener[,useCapture])</p><ul><li><p>type</p><ul><li>事件类型字符串，比如 click、mouseover，注意不要带 on</li></ul></li><li><p>listener</p><ul><li>事件处理函数，事件发生时。会调用该监听函数</li></ul></li><li><p>useCapture</p><ul><li>可选参数，是一个布尔值，默认是 false。</li></ul></li></ul></li><li><p>JS 的事件对象 - event</p><ul><li><p>btn.onclick = function(event){ // event 就是当前事件的对象，简称事件对象 var event = event || window.event;//兼容性写法 }</p></li><li></li><li><p>事件常见的属性和方法</p></li><li><p>常用的鼠标事件</p></li><li><p>常用的键盘事件</p></li><li><p>在监听事件 addEventListener 里都没有&#39;on&#39;</p><ul><li>document.addEventListener(&#39;keyup&#39;, function () { alert(&#39;我弹起了&#39;); })</li></ul></li></ul></li><li><p>eventTarget.addEventListener(&#39;click&#39;,function(){})</p></li><li><p>删除事件</p><ul><li>div[1].removeEventListener(&#39;click&#39;,fn)</li></ul></li></ul></li></ul></li><li><p>事件对象</p><ul><li><p>示例</p><ul><li>eventTarget.addEventListener(&#39;click&#39;,function(e){ console.log(e) })</li></ul></li><li><p>排他思想绑定事件</p><ul><li><code>for （var i = 0;i&lt;btns.length;i++）{ btn[i].onclick = function (){ this.style.backgroundColor = &#39;pink&#39;; } this.style.backgroundColor = &#39;blue&#39;; }</code></li></ul></li><li><p>1.onload 事件</p><ul><li><p>页面加载（文本和图片）完毕的时候</p></li><li><p>作用</p><ul><li><p>js 的加载时和 html 同步加载的，如果使用元素在定义元素之间，容易报错</p></li><li><p>整个页面上的所有元素加载完毕 再执行 js 内容</p></li><li><p>window.onload()可以预防使用标签在定义之前</p></li></ul></li></ul></li><li><p>2.常见事件对象</p><ul><li><p>事件合集图</p><ul><li>图解</li></ul></li><li><p>键盘事件</p><ul><li><p>onkeydown</p><ul><li><p>某个键盘按键被按下触发（如果按下不放手，会一直触发）</p></li><li><p>第一执行顺序</p></li><li><p>不区分字母大小写 a 和 A 得到的都是 65</p></li></ul></li><li><p>onkeypress</p><ul><li><p>某个键盘按键被按下时 触发</p></li><li><p>不认识功能键 如 ctrl shit 箭头 等</p></li><li><p>第二执行顺序</p></li><li><p>区分大小写，a 97 和 A 得到的是 65</p></li></ul></li><li><p>onkeyup</p><ul><li><p>某个键盘按键被松开时触发（只支持字符键）</p></li><li><p>第三执行顺序</p></li></ul></li><li><p>keyup</p><ul><li><p>某个键盘按键被松开时触发</p></li><li><p>不区分字母大小写 a 和 A 得到的都是 65</p></li></ul></li></ul></li><li><p>键盘事件对象</p><ul><li><p>e.keyCode</p><ul><li><p>返回该键的 ASCll 值</p></li><li><p>判断按下了什么键</p></li></ul></li></ul></li><li><p>鼠标事件</p><ul><li><p>mouseenter</p><ul><li><p>鼠标移动到元素上触发</p></li><li><p>没有冒泡</p></li></ul></li><li><p>mouseover</p><ul><li><p>鼠标移动到元素上触发</p></li><li><p>有冒泡</p></li></ul></li><li><p>mouseout</p><ul><li>鼠标移出元素</li></ul></li><li><p>mouseleave</p><ul><li>鼠标移出</li></ul></li><li><p>mousemove</p><ul><li>鼠标在目标的上方移动</li></ul></li><li><p>mousedown</p><ul><li>鼠标按键被按下</li></ul></li><li><p>mouseup</p><ul><li>鼠标按键被释放弹起</li></ul></li><li><p>click</p><ul><li>鼠标点击</li></ul></li><li><p>dblclick</p><ul><li>鼠标的按钮被按下</li></ul></li><li><p>contextmenu</p><ul><li>弹出右键菜单</li></ul></li></ul></li><li><p>鼠标事件对象</p><ul><li><p>e.clientX</p><ul><li>返回鼠标相对于浏览器窗口可视区的 X 坐标</li></ul></li><li><p>e.clientY</p><ul><li>返回鼠标相对于浏览器窗口可视区的 Y 坐标</li></ul></li><li><p>e.pageX</p><ul><li>返回鼠标相对于文档页面的 X 坐标 IE9+支持</li></ul></li><li><p>e.pageY</p><ul><li>返回鼠标相对于文档页面的 Y 坐标 IE9+支持</li></ul></li><li><p>e.screenX</p><ul><li>返回鼠标相对于电脑屏幕的 X 坐标</li></ul></li><li><p>e.screenY</p><ul><li>返回鼠标相对于电脑屏幕的 Y 坐标</li></ul></li></ul></li><li><p>移动端事件</p><ul><li><p>触屏(触摸)事件</p><ul><li><p>div.addEventListener(&#39;touchstart&#39;,function(){})</p></li><li><p>touchstart</p><ul><li><p>手指触摸到一个 DOM 元素时触发</p></li><li><p>事件对象 TouEvent</p><ul><li><p>e.touches</p><ul><li>正在触摸屏幕的所有手指列表</li></ul></li><li><p>e.targetTouches</p><ul><li><p>正在触摸当前 DOM 的手指列表</p></li><li><p>如果侦听的是和 e.touches 同一个元素，结果是一样的</p></li><li><p>拥有的元素</p><ul><li><p>坐标</p><ul><li><p>pageX</p></li><li><p>pageY</p></li></ul></li><li><p>子主题 3</p></li></ul></li></ul></li><li><p>e.changedTouches</p><ul><li><p>手指状态发生了改变的列表 从无到有 或者 从有到无</p></li><li><p>手指操作后，离开了屏幕 会有此元素</p></li></ul></li></ul></li></ul></li><li><p>touchmove</p><ul><li><p>手指在一个 DOM 元素上滑动时触发</p></li><li><p>事件对象 TouEvent</p><ul><li>子主题 1</li></ul></li></ul></li><li><p>touchend</p><ul><li><p>手指从一个 DOM 元素上移开时触发</p></li><li><p>事件对象 TouEvent</p><ul><li>子主题 1</li></ul></li></ul></li><li><p>滑动距离计算</p><ul><li>移动手指后的坐标 - 触摸手指的初始坐标</li></ul></li></ul></li></ul></li><li><p>HTML 事件</p><ul><li><p>1、window 事件</p><ul><li><p>load 当页面加载完成以后会触发</p></li><li><p>unload 当页面解构的时候触发(刷新页面，关闭当前页面) IE 浏览器兼容</p></li><li><p>scroll 页面滚动</p></li><li><p>resize 窗口大小发生变化的时候触发</p></li></ul></li><li><p>2、表单事件</p><ul><li><p>blur 失去焦点</p></li><li><p>focus 获取焦点</p></li><li><p>select 当我们在输入框内选中文本的时候触发</p></li><li><p>change 当我们对输入框的文本进行修改并且失去焦点的时候</p></li><li><p>submit 当我们点击 submit 上的按钮才能触发</p></li><li><p>reset 当我们点击 reset 上的按钮才能触发</p></li></ul></li></ul></li><li><p>常用事件补充</p><ul><li><p>修改元素样式</p><ul><li><p>行内样式操作</p><ul><li>this.style.CSS 属性 = &#39;&#39;</li></ul></li><li><p>写好样式，再 js 添加类名</p><ul><li><p>this.className = &#39;类名&#39;</p></li><li><p>如果原来有类名，把原来类名添加上， 以空格分隔</p></li></ul></li></ul></li><li><p>禁止右键菜单</p><ul><li><p>document.addEventListener(&#39;selectstart&#39;,function(e){ e.preventDefault() })</p><ul><li><p>e.preventDefault()</p><ul><li>阻止默认行为</li></ul></li><li><p>selectstart</p><ul><li>禁止选择</li></ul></li></ul></li></ul></li><li><p>onfocus</p><ul><li>获得焦点</li></ul></li><li><p>onblur</p><ul><li>失去焦点</li></ul></li><li><p>parseInt</p><ul><li>解析一个字符串，并返回一个整数</li></ul></li><li><p>parseFloat</p><ul><li>参数 string 要读取并转换为浮点数的字符串。 返回 无。</li></ul></li></ul></li></ul></li><li><p>3.常见的事件对象属性</p><ul><li><p>e.target</p><ul><li><p>返回事件触发对象 标准</p></li><li><p>点击了哪个对象就指向返回的点击的元素</p></li><li><p>与 this.currentTatget 作用相似</p></li></ul></li><li><p>e.srcElement</p><ul><li>返回触发事件对象， 非标准 ie6-8</li></ul></li><li><p>e.type</p><ul><li>返回事件的类型，比如 click、mouseover 不带 on</li></ul></li><li><p>e.cancelBubble = true</p><ul><li>阻止冒泡 非标准 ie6-8</li></ul></li><li><p>e.returnValue</p><ul><li>阻止默认事件(默认行为) 非标准 ie6-8</li></ul></li><li><p>e.preventDefault()</p><ul><li>阻止默认事件(默认行为) 标准</li></ul></li><li><p>e.stopPropagation()</p><ul><li>阻止冒泡 标准</li></ul></li></ul></li></ul></li><li><p>事件冒泡和事件捕获</p><ul><li><p>事件捕获</p></li><li><p>事件冒泡</p><ul><li><p>事件的传播过程</p></li><li><p>没有冒泡的事件</p><ul><li>onblur、onfocus、onmouseenter、onmouseleave</li></ul></li></ul></li><li><p>阻止冒泡</p><ul><li><p>addEvenListener(&#39;click&#39;,function(){}flase)</p><ul><li>flase</li></ul></li><li><p>e.preventDefault()</p><ul><li>阻止默认事件(默认行为) 标准</li></ul></li><li><p>e.stopPropagation()</p><ul><li>阻止冒泡 标准</li></ul></li></ul></li><li><p>事件委托</p><ul><li><p>事件监听器设置在父节点上，然后利用冒泡原理影响设置每个子节点</p></li><li><p>var ul = document.querySelector(&#39;ul&#39;); ul.addEventListener(&#39;click&#39;,function(e){ e.target.style.backgroundColor = &#39;pink&#39;; })</p></li><li><p>优点：不需要 for 循环来为一个个元素注册事件，提升了程序运行效率</p></li></ul></li></ul></li><li><p>数据结构</p><ul><li></li><li><p>DOM 可以做什么？</p><ul><li><p>找对象（元素）</p></li><li><p>设置元素的属性</p></li><li><p>设置元素的样式</p></li><li><p>动态创建和删除元素</p></li><li><p>事件-触发响应</p></li></ul></li></ul></li></ul></li><li><p>重点核心 节点操作</p><ul><li><p>创建</p><ul><li><p>document.write()</p><ul><li>是直接将内容写入页面的内容流 但是页面的文档流执行完毕，则它会导致页面全部重绘</li></ul></li><li><p>element.innerHTML</p><ul><li><p>是将内容写入某个 DOM 节点，不会导致页面重绘</p></li><li><p>创建多个元素效率更高(不要拼接字符串，采取数组形式拼接-array.push(&#39;&#39;))，结构稍微复杂</p></li></ul></li><li><p>document.creareElement()</p><ul><li>创建多个元素效率稍微低一点，但结构更清晰</li></ul></li></ul></li><li><p>删</p><ul><li>removeChild()</li></ul></li><li><p>改</p><ul><li><p>修改 dom 的元素属性，dom 元素的内容，属性，表单的值等</p></li><li><p>1.修改元素属性</p><ul><li>src、href、title 等</li></ul></li><li><p>2.修改普通元素的内容</p><ul><li>innerHTML、innerText</li></ul></li><li><p>3.修改表单元素</p><ul><li>value、type、disable 等</li></ul></li><li><p>4.修改元素样式</p><ul><li><p>style、className</p></li><li><p>oDiv.style.width</p></li><li><p>oDiv.style.backgroundColor</p></li></ul></li></ul></li><li><p>查</p><ul><li><p>1.DOM 提供的 API 方法：getElementById、getElementsByTagName 等古老用法，不太推荐</p></li><li><p>2.H5 提供的新方法：querySelect、querySelectAll， 推荐使用</p></li><li><p>3.利用节点操作获取元素：父(parentNode)、子(children)、兄(previousElementSibling、nextElementSibling)，推荐使用</p></li></ul></li><li><p>节点操作的方法</p><ul><li><p>document.write(&quot;hello world&quot;);</p></li><li><p>document.createElement(标签的类型)</p></li><li><p>appendChild()</p><ul><li><pre><code>格式：node1.appendChild(node2);
</code></pre></li><li><pre><code>功能：将node2插入到node1的子节点末尾
</code></pre></li></ul></li><li><p>insertBefore()</p><ul><li><p>格式：box1.parentNode.insertBefore(box2, box1);</p></li><li><p>功能：将 box2 插入到 box1 的前面</p></li></ul></li><li><p>createTextNode()</p><ul><li><p>格式：document.createTextNode()</p></li><li><p>参数：文本内容</p></li><li><p>功能：创建文本节点</p></li></ul></li><li><p>replaceChild()</p><ul><li><p>格式：box1.parentNode.replaceChild(box2, box1);</p></li><li><p>功能：用 box2 节点，将 box1 节点替换。</p></li></ul></li><li><p>removeChild()</p><ul><li><p>格式：box1.parentNode.removeChild(box1);</p></li><li><p>功能：将 box1 删除</p></li></ul></li><li><p>cloneNode()</p><ul><li><p>格式：node.cloneNode()/node.cloneNode(true)</p></li><li><p>功能：克隆节点,默认克隆节点本身</p></li><li><p>返回值：新克隆出来的节点。</p></li></ul></li></ul></li><li><p>元素节点子节点</p><ul><li><p>childNodes 获取某一个元素节点所有的子节点。 伪数组</p></li><li><p>firstChild 快速获取到第一个子节点</p></li><li><p>lastChild 快速获取到最后一个子节点</p></li><li><p>nextSibling 找到兄弟节点中的下一个节点</p></li><li><p>previousSibling 找到兄弟节点中的上一个节点</p></li><li><p>【注】只获取子节点中的元素节点。</p><ul><li><p>children</p></li><li><p>firstElementChild</p></li><li><p>lastElementChild</p></li><li><p>nextElementtSibling</p></li><li><p>previousElementSibling</p></li></ul></li><li><p>parentNode 可以快速获取到当前节点的父节点</p></li></ul></li></ul></li></ul><h3 id="元素家族-元素可视化区域" tabindex="-1">元素家族 (元素可视化区域) <a class="header-anchor" href="#元素家族-元素可视化区域" aria-label="Permalink to &quot;元素家族 (元素可视化区域)&quot;">​</a></h3><ul><li><p>offSet 家族(元素偏移量)</p><ul><li><p>offSet 自己的，用于获取元素位置+尺寸：包括内边距+内容的宽度和高度</p></li><li><p>内置对象 document 浏览器兼容模式</p><ul><li>CSS1Compat：标准兼容模式开启 浏览器宽度:document.documentElement.clientWidth</li></ul></li><li><p>offSet 元素 子级居于父级定位，若父级无定位，则基于 body 为准</p></li><li><p>元素</p><ul><li><p>网页可见区域宽： document.body.clientWidth;</p></li><li><p>网页可见区域高： document.body.clientHeight;</p></li><li><p>.offsetParent</p><ul><li><p>返回当前对象的父级（带有定位）盒子， 可能是父亲、也可能是爷爷</p></li><li><p>子级居于父级定位，若父级无定位，则基于 body 为准</p></li><li><p>和 parentNode 的区别</p><ul><li>parentNode <ul><li>返回父级，最近一级的父级</li></ul></li></ul></li></ul></li><li><p>.offsetTop</p><ul><li>返回元素相对带有定位的父元素上方的偏移</li></ul></li><li><p>.offsetLeft</p><ul><li>返回元素相对带有定位的父元素左边框的偏移</li></ul></li><li><p>网页可见区域宽： document.body.offsetWidth (内容、边框和内边距);</p></li><li><p>网页可见区域高： document.body.offsetHeight (内容、边框和内边距);</p></li></ul></li><li><p>可以和 e.pageX、e.pageY 配合使用</p><ul><li>商品放大镜效果</li></ul></li><li><p>offsetXXX 和 style.XXX 的区别</p><ul><li><p>用 offsetLeft 和 style.left 来分析，其他的以此类推：</p></li><li><p>a) style.left 只能获取行内的，而 offsetLeft 则可以获取到所有的；</p></li><li><p>b) offsetLeft 可以返回没有定位盒子距离左侧的位置；而 style.left 不可以，其只能返回有定位盒子的 left;</p></li><li><p>c) offsetLeft 返回的是数字，而 style.left 返回的是字符串，除了数字外还带有单位：px;</p></li><li><p>注意：可以用 parseInt 进行转化；比如：styleLeft=&#39;300px&#39; ---&gt; parseInt(styleLft) ---&gt; 300</p></li><li><p>d) offsetLeft 是只读的，而 style.left 是可读写；</p></li><li><p>e) 如果没有给 当前 元素指定过 top 样式，则 style.top 返回的是空字符串。</p></li></ul></li></ul></li><li><p>client 家族(元素可视区)</p><ul><li><p>用于获取元素大小</p></li><li><p>可见区域的尺寸 padding 和内容宽度 (不包括边框)返回数值不带单位</p><ul><li><p>clientWidth</p></li><li><p>clientHeight</p></li></ul></li><li><p>元素边框的宽</p><ul><li><p>clientLeft</p><ul><li>左边边框的宽度</li></ul></li><li><p>clientTop</p><ul><li>上边边框的宽度</li></ul></li></ul></li></ul></li><li><p>scroll 家族(元素滚动区)</p><ul><li><p>用于获取滚动距离</p></li><li><p>自身实际宽度，返回数值不带单位</p></li><li><p>元素</p><ul><li><p>网页正文全文宽： document.body.scrollWidth;</p></li><li><p>网页正文全文高： document.body.scrollHeight;</p></li><li><p>网页被卷去的头部： window.pageYOffset;</p></li><li><p>网页被卷去的左：window.pageXOffset;</p></li><li><p>网页被卷去的头部： document.body.scrollTop(x,y);</p></li><li><p>网页被卷去的左： document.body.scrollLeft;</p></li><li><p>元素被卷去的头部：element.scrollTop(x,y);</p></li><li><p>元素被卷去的左： element.scrollLeft;</p></li></ul></li><li><p>页面滚动距离</p><ul><li>window.pageXOffset</li></ul></li><li><p>对应的滚动事件</p><ul><li>div.addEventListener(&#39;scroll&#39;,function(){console.log(div.scrollTop)})</li></ul></li><li><p>处理 scroll 家族浏览器适配问题</p></li><li><p>ie9+ 和 最新浏览器 window.pageXOffset; （scrollLeft） window.pageYOffset; （scrollTop）</p></li><li><p>Firefox 浏览器 和 其他浏览器 document.documentElement.scrollTop;</p></li><li><p>Chrome 浏览器 和 没有声明 DTD <code>&lt;doctype &gt;</code> document.body.scrollTop;</p></li><li><p>兼容写法 var scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0; var scrollLeft = window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0;</p></li></ul></li><li><p>offset、client 和 scroll 的区别分析</p><ul><li><p>left 和 top 分析：</p><ul><li><p>clientLeft: 左边边框的宽度；clientTop: 上边边框的宽度</p></li><li><p>offsetLeft: 当前元素距离有定位的父盒子左边的距离； offsetTop: 当前元素距离有定位的父盒子上边的距离</p></li><li><p>scrollLeft: 左边滚动的长度; scrollTop: 上边滚动的长度;</p></li></ul></li><li><p>width 和 height 分析</p><ul><li><p>clientWidth/Height: 内容 + 内边距</p></li><li><p>offsetWidth/Height: 内容 + 内边距 + 边框</p></li><li><p>scrollWidth/Height: 滚动内容的宽度和高度</p></li></ul></li></ul></li><li><p>获取屏幕的可视区域(兼容性)</p><ul><li><p>//ie9 及其以上的版本、最新浏览器 window.innerWidth, window.innerHeight</p></li><li><p>//标准模式浏览器 document.documentElement.clientWidth, document.documentElement.clientHeight</p></li><li><p>//怪异模式 document.body.clientWidth, document.body.clientHeight</p></li><li><p>//通用写法 function client() { if(window.innerWidth){ // ie9 及其以上的版本 return{ width: window.innerWidth, height: window.innerHeight } }else if(document.compatMode != &#39;CSS1Compat&#39;){ // 怪异模式 return{ width: document.body.clientWidth, height: document.body.clientHeight } } // 标准 return{ width: document.documentElement.clientWidth, height: document.documentElement.clientHeight } }</p></li></ul></li><li><p>常用窗口事件-onresize</p></li></ul><h3 id="数据存储" tabindex="-1">数据存储 <a class="header-anchor" href="#数据存储" aria-label="Permalink to &quot;数据存储&quot;">​</a></h3><ul><li><p>本地存储</p><ul><li><p>特征</p><ul><li><p>1.数据存储在用户浏览器中</p></li><li><p>2.设置、读取方便、甚至页面刷新不丢数据</p></li><li><p>3.容量较大，sessionStorage 约 5M、localStorage 约 20M</p></li><li><p>4.只能存储字符串，可以将对象的 Json.stringify()编码后存储</p></li></ul></li><li><p>window.sessionStorage</p><ul><li><p>对象</p><ul><li><p>sessionStorage.setItem(&#39;uname&#39;,val)</p><ul><li>存储数据</li></ul></li><li><p>sessionStorage.getItem(&#39;uname&#39;)</p><ul><li>获取数据</li></ul></li><li><p>sessionStorage.removeItem(&#39;uname&#39;)</p><ul><li>移除数据</li></ul></li><li><p>sessionStorage.clear();</p><ul><li>清空所有数据</li></ul></li></ul></li><li><p>生命周期和特性</p><ul><li><p>1.关闭浏览器窗口便没有了</p></li><li><p>2.同一个窗口(页面)的数据可以共享</p></li><li><p>3.以键值对的形式存储使用</p></li></ul></li><li><p>sessionStorage 常用于结合后台使用</p></li></ul></li><li><p>window.localStorage</p><ul><li><p>HTML5 中，新加入了一个 localStorage 特性</p><ul><li><p>localStorage 中一般浏览器支持的是 5M 大小</p></li><li><p>在不同的浏览器中 localStorage 会有所不同。</p></li></ul></li><li><p>对象</p><ul><li><p>localStorage.setItem(&#39;uname&#39;,val)</p><ul><li>存储数据</li></ul></li><li><p>localStorage.getItem(&#39;uname&#39;)</p><ul><li>获取数据</li></ul></li><li><p>localStorage.removeItem(&#39;uname&#39;)</p><ul><li>移除数据</li></ul></li><li><p>localStorage.clear();</p><ul><li>清空所有数据</li></ul></li></ul></li><li><p>生命周期和特性</p><ul><li><p>1.生命周期永久生效，除非手动删除 ，否则关闭页面也会存在</p></li><li><p>2.可以多窗口(页面)共享（统一浏览器共享使用）</p></li><li><p>3.以键值对的形式存储使用</p></li></ul></li><li><p>localStorage 的优势</p><ul><li><p>localStorage 拓展了 cookie 的 4K 限制。</p></li><li><p>localStorage 会可以将第一次请求的数据直接存储到本地，这个相当于一个 5M 大小的针对于前端页面的数据库，相比于 cookie 可以节约带宽，但是这个却是只有在高版本的浏览器中才支持的</p></li></ul></li><li><p>localStorage 的局限</p><ul><li><p>浏览器的大小不统一，并且在 IE8 以上的 IE 版本才支持 localStorage 这个属性。</p></li><li><p>前所有的浏览器中都会把 localStorage 的值类型限定为 string 类型，这个在对我们日常比较常见的 JSON 对象类型需要一些转换。</p></li><li><p>localStorage 在浏览器的隐私模式下面是不可读取的。</p></li><li><p>localStorage 本质上是对字符串的读取，如果存储内容多的话会消耗内存空间，会导致页面变卡。</p></li><li><p>localStorage 不能被爬虫抓取到。</p></li><li><p>localStorage 属于永久性存储。</p></li></ul></li></ul></li><li><p>cookie</p><ul><li><p>特性</p><ul><li><p>1、可以设置过期时间</p></li><li><p>2、最大可以存 4KB</p></li><li><p>3、每一个域名下面最多可以存储 50 条数据</p></li></ul></li></ul></li></ul></li></ul><h3 id="代码实战" tabindex="-1">代码实战 <a class="header-anchor" href="#代码实战" aria-label="Permalink to &quot;代码实战&quot;">​</a></h3><ul><li><p>代码实战 1</p><ul><li><p>代码例子</p><ul><li><p>图片切换</p></li><li><p>图片的显示和隐藏</p></li><li><p>百度换肤</p></li><li><p>选中和取消选中</p></li><li><p>transform 的运用</p></li><li><p>输入框焦点处理</p></li><li><p>表单验证</p><ul><li><p>parseInt</p><ul><li>解析一个字符串，并返回一个整数</li></ul></li><li><p>parseFloat</p><ul><li>参数 string 要读取并转换为浮点数的字符串。 返回 无。</li></ul></li><li><p>function $(id){ return typeof id===&quot;string&quot;?document.getElementById(id):null }</p><ul><li>$ 函数名。 id 参数 如果传入的 id 是字符串类型的。返回 document.getElementById(id) 如果不是 直接返回 null</li></ul></li></ul></li><li><p>选项卡</p></li><li><p>简化微博</p><ul><li>01-九宫格布局 <ul><li>求出当前盒子所在的行和列 <ul><li>var row = parseInt(i / allCols); var col = parseInt(i % allCols);</li></ul></li></ul></li></ul></li><li><p>定时器</p><ul><li><p>01-Date</p><ul><li><p>基本属性</p><ul><li>console.log(date.getDate()); // 日 console.log(date.getDay()); // 星期几 console.log(date.getMonth() + 1); // 月 console.log(date.getFullYear() ); // 完整的年份 console.log(date.getHours() ); // 小时 console.log(date.getMinutes() ); // 分钟 console.log(date.getSeconds() ); // 秒 console.log(date.getMilliseconds() ); // 毫秒 console.log(date.getTime() ); // 时间戳</li></ul></li><li><p>简单日历效果</p></li></ul></li><li><p>02-定时器</p><ul><li><ol><li>需求</li></ol><ul><li><ol><li>JS 的程序的执行速度是非常快的, 如果希望一段程序，可以每间隔一段时间执行一次，可以使用定时调用</li></ol></li><li><ol start="2"><li>某一段程序需要在延迟多少时间后执行，可以使用定时器调用</li></ol></li></ul></li><li><ol start="2"><li>使用</li></ol><ul><li><p>循环执行</p><ul><li>var timeid = window.setInterval（“方法名或方法”，“延时”）; window.clearInterval(timeid);</li></ul></li><li><p>定时执行</p><ul><li><p>var timeid = window.setTimeout(“方法名或方法”, “延时”); window.clearTimeout(timeid);</p></li><li><p>当方法执行完成定时器停止(但是定时器还在,只不过没用了)</p></li></ul></li><li><p>一次定时器</p><ul><li>setTimeout</li></ul></li></ul></li><li><ol start="3"><li>实操</li></ol></li></ul></li><li><p>03-时钟表实战</p><ul><li><p>时钟</p></li><li><p>思路</p><ul><li><p>时间戳</p><ul><li><p>先求出毫秒</p></li><li><p>秒</p></li><li><p>分钟</p></li><li><p>小时</p></li></ul></li><li><p>再用 CSS 旋转属性</p></li></ul></li></ul></li><li><p>04-长图滚动效果</p></li><li><p>05-随机点名册</p></li><li><p>06-匀速动画</p></li><li><p>07-缓动动画</p></li><li><p>08-轮播</p></li></ul></li></ul></li><li><p>代码封装</p></li><li><p>排他思想</p><ul><li><code>btnList[0].onclick = function () { //遍历清除所有的 claaName for (var i = 0; i&lt; btnList.length; i++){ btnList[i].className=&#39;&#39; } //将响应事件的按钮，再单独设置 btnList[0].className=&#39;current&#39; };</code></li></ul></li><li><ol><li>字符串 API</li></ol><ul><li><p>charAt()</p><ul><li>返回在指定位置的字符。</li></ul></li><li><p>charCodeAt()</p><ul><li>返回在指定的位置的字符的 Unicode 编码。</li></ul></li><li><p>concat()</p><ul><li>连接字符串</li></ul></li><li><p>indexOf()</p><ul><li>检索字符串</li></ul></li><li><p>lastIndexOf()</p><ul><li>从后向前搜索字符串</li></ul></li><li><p>toLowerCase()</p><ul><li>把字符串转换为小写。</li></ul></li><li><p>toUpperCase()</p><ul><li>把字符串转换为大写。</li></ul></li></ul></li><li><ol start="2"><li>编码</li></ol><ul><li><p>URI</p><ul><li><p>统一资源标识符，或叫做 URI，是用来标识互联网上的资源（例如，网页或文件）和怎样访问这些资源的传输协议（例如，HTTP 或 FTP）的字符串。</p></li><li><p>除了 encodeURI、encodeURIComponent、decodeURI、decodeURIComponent 四个用来编码和解码 URI 的函数之外 ECMAScript 语言自身不提供任何使用 URL 的支持。</p></li></ul></li><li><p>encodeURI 和 decodeURI</p><ul><li>这两个函数操作的是完整的 URI；这俩函数假定 URI 中的任何保留字符都有特殊意义，所有不会编码它们。</li></ul></li><li><p>encodeURIComponent</p><ul><li><p>可把字符串作为 URI 组件进行编码</p></li><li><p>该方法不会对 ASCII 字母和数字进行编码，也不会对这些 ASCII 标点符号进行编码： - _ . ! ~ * &#39; ( )</p></li></ul></li><li><p>decodeURIComponent</p><ul><li>可把字符串作为 URI 组件进行解码</li></ul></li></ul></li><li><p>面试作业-1</p><ul><li><ol><li>浏览器请求一个资源的过程?</li></ol></li><li><ol start="2"><li>页面渲染的过程?</li></ol></li><li><ol start="3"><li>请描述计算机网络的 OSI 七层模型? css 渲染是在这七层的那一层?</li></ol></li><li><ol start="4"><li>浏览器输入一个网址，得到页面的具体过程?</li></ol></li><li><ol start="5"><li>什么是 TCP 三次握手、四次挥手?</li></ol></li><li><ol start="6"><li>找 100 亿个数中最小的 1000 个数?</li></ol></li><li><ol start="7"><li>两个文件各有 100 亿个 URL，如何找到两个文件中相同的 URL ?</li></ol></li><li><ol start="8"><li>八个铁球，七个一样重，一个要重一些， 请问最少几次找出那个重的 ?</li></ol></li></ul></li><li><p>面试作业-2</p><ul><li><ol><li>var 的变量提升的底层原理是什么?</li></ol></li><li><ol start="2"><li>JS 如何计算浏览器的渲染时间?</li></ol></li><li><ol start="3"><li>JS 的回收机制?</li></ol></li><li><ol start="4"><li>垂直水平居中的方式?</li></ol></li><li><ol start="5"><li>实现一个三栏布局，中间版块自适应方法有哪些?</li></ol></li><li><ol start="6"><li>如何判断一个对象是否为数组?</li></ol></li><li><ol start="7"><li>行内元素和块级元素有哪些? img 属于什么元素?</li></ol></li><li><ol start="8"><li>margin 坍塌?</li></ol></li><li><ol start="9"><li>说说 BFC 原理?</li></ol></li><li><ol start="10"><li>写一下节点增删改?</li></ol></li><li><ol start="11"><li>如何获取元素的父节点和兄弟节点，写一下?</li></ol></li><li><ol start="12"><li>给你一个乱序数组，你怎么排序?</li></ol></li></ul></li><li><p>面试作业-3</p><ul><li><ol><li>一个圆上随机三点，求形成锐角三角形概率？</li></ol></li><li><ol start="2"><li>请说说伪元素，伪类？</li></ol></li><li><ol start="3"><li>dom 操作有哪些？</li></ol></li></ul></li></ul></li><li><p>代码实战 2</p><ul><li><p>1.星空特效</p><ul><li><p>1.css 写好动效</p></li><li><p>2.js 求出屏幕的尺寸</p><ul><li><p>clientWidth</p></li><li><p>clientHeight</p></li></ul></li><li><p>3.动态创建星星</p><ul><li><p>遍历循环</p><ul><li><p>for(var i=0;i=200;i++){ }</p></li><li><p>遍历创建星星</p></li><li><p>随机数创建随机坐标</p></li><li><p>随机数创建星星的随机缩放</p></li><li><p>随机数创建星星闪烁的频率</p></li><li><p>鼠标经过星星旋转：用 JS 或者 css3 做</p></li></ul></li></ul></li></ul></li><li><p>2.照片墙特效</p><ul><li><p>1.写一个 ul 标签</p></li><li><p>2.JS 获取标签</p></li><li><p>3.js 创建标签</p><ul><li><p>for 循环动态</p><ul><li><p>创建 li 标签</p><ul><li>放 img 标签</li></ul></li><li><p>创建 img 标签</p><ul><li>放图片</li></ul></li></ul></li></ul></li><li><p>4.求出屏幕宽度和高度</p></li><li><p>5.随机分布角度</p><ul><li><p>for 循环遍历</p><ul><li><p>取出单个 li 标签</p></li><li><p>随机分布</p><ul><li>随机的屏幕宽度高度</li></ul></li><li><p>随机角度</p></li></ul></li></ul></li><li><p>6.点击图片选中事件</p><ul><li><p>加选中的 CSS 动效</p></li><li><p>JS 点击监听事件</p><ul><li>循环遍历</li></ul></li></ul></li></ul></li><li><p>3.弹性导航</p><ul><li><p>使用事件</p><ul><li>offSet 家族 <ul><li>一定要用定位</li></ul></li></ul></li><li><p>1.新建 ul&gt;li 导航标签</p></li><li><p>2..获取标签</p></li><li><p>3.for 循环 li 标签的遍历</p><ul><li><p>监听鼠标进入事件</p></li><li><p>监听鼠标按下事件</p></li><li><p>监听鼠标离开事件</p></li><li><p>缓动动画</p><ul><li><p>定义一个开始和结束的函数</p></li><li><p>定时器计算</p><ul><li>数值的移动</li></ul></li></ul></li></ul></li></ul></li><li><p>4.放大镜特效</p><ul><li><p>JS 的事件对象 - event</p><ul><li>btn.onclick = function(event){ // event 就是当前事件的对象，简称事件对象 var event = event || window.event;//兼容性写法 }</li></ul></li><li><p>1.写 Html 元素和 css 布局</p><ul><li>小图、中图(显示的图)、大图(鼠标滑动放大图)、遮罩</li></ul></li><li><p>2.JS 获取 6 个标签</p></li><li><p>3.鼠标监听</p><ul><li><p>进入监听</p><ul><li><p>隐藏的遮罩显示</p></li><li><p>鼠标移动监听</p><ul><li><p>JS 的事件对象 - event</p><ul><li>small_box.onmouseover = function(event){ // event 就是当前事件的对象，简称事件对象 var event = event || window.event;//兼容性写法 }</li></ul></li><li><p>求出鼠标坐标</p><ul><li>使用 event 事件的自带函数计算</li></ul></li><li><p>移动的边界检测</p><ul><li>宽和高计算：if(){}else{}</li></ul></li><li><p>让放大镜移动起来</p></li><li><p>让大图移动起来</p><ul><li>求出中图移动多少，大图跟着移动</li></ul></li></ul></li></ul></li><li><p>离开监听</p></li></ul></li><li><p>4.遍历列表图片切换</p></li></ul></li><li><p>5.橱窗特效</p></li><li><p>6.瀑布流布局</p></li><li><p>7.中部导航吸顶特效</p></li><li><p>8.侧边横幅特效</p></li></ul></li><li><p><a href="https://egame.qq.com/5837682" target="_blank" rel="noreferrer">https://egame.qq.com/5837682</a></p></li></ul><h3 id="正则表达式" tabindex="-1">正则表达式 <a class="header-anchor" href="#正则表达式" aria-label="Permalink to &quot;正则表达式&quot;">​</a></h3><ul><li><p>用于匹配字符串中字符组合的模式</p></li><li><p>1.创建 正则表达式</p><ul><li><p>1.通过 new RegExp 对象 创建</p><ul><li>var regexp = new RegExp(/123/);</li></ul></li><li><p>2.省略 new 运算符去声明</p><ul><li>var box1 = RegExp(&quot;hello&quot;, &quot;ig&quot;);</li></ul></li><li><p>3.利用字面量常量赋值创建</p><ul><li>var reg = /123/</li></ul></li></ul></li><li><p>2.检测正则</p><ul><li><p>test</p><ul><li><p>格式：正则.test(字符串)</p></li><li><p>功能：在字符串中匹配这个正则是否存在</p></li><li><p>返回值：如果匹配成功返回 true，匹配失败返回 false。</p></li><li><p>test() 方法用来检测字符串是否符合 正则表达式要求的规范</p><ul><li><p>console.log(reg.test(123));</p></li><li><p>console.log(reg.test(&#39;abc&#39;));</p></li></ul></li></ul></li><li><p>exec</p><ul><li><p>格式：正则.exec(字符串)</p></li><li><p>功能：在字符串中匹配这个正则是否存在</p></li><li><p>返回值：返回匹配到的串，匹配成功，返回一个装有字符串的数组</p></li><li><p>匹配失败，返回 null</p></li></ul></li></ul></li><li><p>作用</p><ul><li><p>表单验证（匹配）</p><ul><li><p>表达式</p><ul><li><p>普通类</p><ul><li><p>只要包含</p><ul><li>/a/</li></ul></li><li><p>以什么开头</p><ul><li>/^a/</li></ul></li><li><p>以什么结尾</p><ul><li>/a$/</li></ul></li><li><p>精确匹配</p><ul><li>/^a$/</li></ul></li></ul></li><li><p>字符串类</p><ul><li><p>只要包含</p><ul><li>/[a]/</li></ul></li><li><p>多选 1,只要有一个</p><ul><li>/^[abcde]$/</li></ul></li><li><p>限定字母 a 到 z 范围 之内只要有一个（字符组合）</p><ul><li><p>/^[a-z]$/</p></li><li><p>/^[a-zA-Z]$/</p><ul><li>大写和小写都可以</li></ul></li><li><p>/^[0-9]$/</p><ul><li>数字 0-9</li></ul></li></ul></li><li><p>取反（括号里面有^符号，表示取反）</p><ul><li>/^[^0-9]$/</li></ul></li></ul></li></ul></li><li><p>量词符（出现的次数）</p><ul><li><p>* 相当于 &gt;=0 可以出现 0 次或者很多次</p><ul><li>/^a*$/</li></ul></li><li><p>+ 相当于 &gt;=1 可以出现 1 次或者很多次</p><ul><li>/^a+$/</li></ul></li><li><p>? 相当于 1||0</p><ul><li>/^a?$/</li></ul></li><li><p>{3} 重复 3 次</p><ul><li>/^a{3}$/</li></ul></li><li><p>{3, } 大于等于 3</p><ul><li>/^a{3,}$/</li></ul></li><li><p>{3, 16} 大于等于 3 并且小于等于 16</p><ul><li>/^a{6,16}$/</li></ul></li><li><p>某个模式出现的次数</p><ul><li>/^[a-zA-Z0-9_-]{6,16}$/</li></ul></li></ul></li><li><p>元字符(预定义类)</p><ul><li>图解</li></ul></li></ul></li><li><p>敏感词过滤（替换）</p><ul><li><p>text.value.replace (/激情/,&#39;**&#39;);</p><ul><li>只替换一个</li></ul></li><li><p>text.value.replace (/激情/g,&#39;**&#39;);</p><ul><li>全局匹配</li></ul></li><li><p>text.value.replace (/激情/i,&#39;**&#39;);</p><ul><li>忽略大小写</li></ul></li><li><p>text.value.replace (/激情/gi,&#39;**&#39;);</p><ul><li>全局匹配+忽略大小写</li></ul></li><li><p>text.value.replace (/激情 | 贱/,&#39;**&#39;);</p><ul><li>多个关键词</li></ul></li></ul></li><li><p>字符串的函数：</p></li><li><p>从字符串中获取我们想要的特定部分（提取）</p><ul><li>提取</li></ul></li><li><p>match()</p><ul><li><p>格式：字符串.match(正则)</p></li><li><p>功能：在字符串匹配是否有符合正则表达式，</p></li><li><p>返回值：匹配成功，返回装有匹配到子串的数组</p></li><li><p>匹配失败，返回 null</p></li></ul></li><li><p>replace()</p><ul><li><p>格式：字符串.replace(oldStr/正则, newStr);</p></li><li><p>功能：用 newStr 将 oldStr 替换，</p></li><li><p>返回值：替换成功的新字符串。</p></li></ul></li><li><p>split()</p><ul><li><p>格式：字符串.split(分割符/正则);</p></li><li><p>功能：用分割符将原字符串进行分割</p></li><li><p>返回值：分割剩下的子串组成的数组。</p></li></ul></li><li><p>search()</p><ul><li><p>格式：字符串.search(子串/正则)</p></li><li><p>功能：找到符合条件的子串第一次出现的位置</p></li><li><p>返回值：</p></li><li><p>如果找到，返回&gt;=0 的下标</p></li><li><p>否则，返回-1</p></li></ul></li><li><p>单个数字和字符的元字符</p><ul><li><p>. 匹配单个的任意字符</p></li><li><p>[范围] 匹配单个范围内的字符</p></li><li><p>[0-9]</p></li><li><p>[a-zA-Z0-9_] 匹配单个的数字、字母下划线</p></li><li><p>[^范围] 匹配任意一个除括号范围内的字符</p></li><li><p>[^0-9] 匹配任意一个非数字字符</p></li><li><p>\\w 匹配单个的数字、字母下划线 等价于 [a-zA-Z0-9_]</p></li><li><p>\\W 匹配单个非数字、字母下划线</p></li><li><p>\\d 匹配单个数字 等价于 [0-9]</p></li><li><p>\\D 匹配单个非数字 等价于 [^0-9]</p></li></ul></li><li><p>空白字符</p><ul><li><p>\\s 匹配任意单个的空白字符</p></li><li><p>\\S 匹配任意单个非空白字符</p></li></ul></li><li><p>重复字符 x（任意的单个字符）</p><ul><li><p>x? 匹配 0 个或者 1 个 x</p></li><li><p>x+ 匹配至少一个 x 字符</p></li><li><p>x* 匹配任意个 x 字符</p></li><li><p>x{m,n}匹配至少 m 个，最多 n 个 x 字符，包括 n</p></li><li><p>x{n} 必须匹配 n 个 x 字符</p></li><li><p>(xyz)+ 小括号括起来的部分是当做单个字符处理</p></li></ul></li><li><p>锚字符</p><ul><li><p>^ 行首匹配 必须以这个正则开头</p></li><li><p>$ 行尾匹配 必须以这个正则结尾</p></li></ul></li></ul></li><li><p>注意</p><ul><li>正则表达式不需要加引号， 不管是数字类型还是字符串类型</li></ul></li><li><p>表达式字母或符号详解</p><ul><li><p><a href="https://www.runoob.com/js/js-regexp.html" target="_blank" rel="noreferrer">https://www.runoob.com/js/js-regexp.html</a></p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions" target="_blank" rel="noreferrer">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions</a></p></li></ul></li></ul>`,117)]))}const f=i(t,[["render",o]]);export{h as __pageData,f as default};
