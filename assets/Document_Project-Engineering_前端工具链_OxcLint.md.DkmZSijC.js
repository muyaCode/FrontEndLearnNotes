import{_ as o,c as s,o as n,ah as a}from"./chunks/framework.DqD713j2.js";const c="/FrontEndLearnNotes/assets/944f82bc7693bd1b2fab47415f381f36.DgbnXcbS.png",l="/FrontEndLearnNotes/assets/33a3bd8940d4bffd439abd248a91f8ae.CMCfnYr4.png",m=JSON.parse('{"title":"OxcLint","description":"","frontmatter":{},"headers":[],"relativePath":"Document/Project-Engineering/前端工具链/OxcLint.md","filePath":"Document/Project-Engineering/前端工具链/OxcLint.md","lastUpdated":1750954157000}'),t={name:"Document/Project-Engineering/前端工具链/OxcLint.md"};function p(r,e,d,i,u,b){return n(),s("div",null,e[0]||(e[0]=[a(`<h1 id="oxclint" tabindex="-1">OxcLint <a class="header-anchor" href="#oxclint" aria-label="Permalink to &quot;OxcLint&quot;">​</a></h1><h2 id="代码检查器" tabindex="-1">代码检查器 <a class="header-anchor" href="#代码检查器" aria-label="Permalink to &quot;代码检查器&quot;">​</a></h2><p>ESLint 是目前前端工程中非常常用的一个工具，它可以帮助我们检查代码中的潜在问题，比如变量未使用、函数未使用、变量未定义等等。ESLint 本身是基于 JavaScript 开发的，但是它的性能一直是个问题，随着项目规模的扩大，ESLint 的性能问题也逐渐暴露出来。</p><p>因此近几年诞生了基于 Rust 的 Lint 工具 <code>OxcLint</code>。</p><p><code>OxcLint</code> 就是基于 <code>Oxc</code> 开发的，而且 OxcLint 的性能比 ESLint 快了 50 倍以上。</p><p><code>oxlint</code>是<code>Oxc</code>项目旗下的一款产品，<code>Oxc</code>作为一款<code>Rust</code>实现的前端工具链集合，包括：</p><ul><li><code>linter</code>，即<code>oxlint</code>，对标<code>Eslint</code>，本文的主角</li><li><code>Parser</code>，即<code>oxc_parser</code>，用于解析<code>.js(x)</code>和<code>.ts(x)</code>，对标<code>swc</code>，<strong>基准测试</strong>[1]据称比<code>swc</code>快 2 倍。</li><li><code>Resolver</code>，解析<code>esm</code>、<code>cjs</code>文件路径，对标<code>webpack/enhanced-resolve</code>，<strong>基准测试</strong>[2]据称比<code>webpack</code>快 28 倍</li><li><code>formatter</code>，对标<code>Prettier</code>，还未公布</li><li><code>transpiler</code>，对标<code>babel</code>，用于将高级语法转译为低级语法，还未公布</li><li><code>minifier</code>，代码压缩工具，还未公布</li></ul><p>与<code>Oxc</code>抱有同样设计理念（都是基于<code>Rust</code>开发的工具链工具）的还有<code>Biome</code>与<code>Ruff</code>，其中：</p><ul><li><code>Biome</code>比较命途多舛。他的前身是<code>Rome</code>，由<code>Babel</code>作者**「Sebastian McKenzie」**开发，和<code>Oxc</code>一样目标语言是<code>JS</code></li><li><code>Ruff</code>的目标语言是<code>Python</code></li></ul><h3 id="oxlint-的介绍" tabindex="-1"><strong>Oxlint 的介绍</strong> <a class="header-anchor" href="#oxlint-的介绍" aria-label="Permalink to &quot;**Oxlint 的介绍**&quot;">​</a></h3><p><code>Oxlint</code>之所以引发热烈讨论，主要原因是**「他的性能太炸裂了」**。</p><p>尤大用<code>Oxlint</code>跑了<code>Vue3</code>仓库，～ 590 个文件跑～ 200 条规则，仅用时 50ms。</p><p>当然，除了**「性能优势」**，<code>Oxlint</code>与老大哥<code>Eslint</code>还有很多区别。接下来我们从 3 个角度对比<code>Oxlint</code>与<code>Eslint</code>：</p><ol><li>易用性</li><li>诊断可读性</li><li>参与成本</li></ol><h4 id="易用性" tabindex="-1"><strong>易用性</strong> <a class="header-anchor" href="#易用性" aria-label="Permalink to &quot;**易用性**&quot;">​</a></h4><p><code>Eslint</code>诞生于 2013 年，他相比于竞争对手（<code>JSHint</code>、<code>JSHint</code>）最大的优势是**「提供了大量可选的规则，并且一些场景下对于不符合规则的代码可以自动修复」**。</p><p>但是，随着时代的进步，他的优势逐渐变为劣势 —— 开发者不再需要大量自定义规则，而是需要**「开箱即用的规则集的最佳实践」**。在此理念下诞生了很多新产品，比如：</p><ul><li>仅针对**「代码风格」**做出检查和格式化的<code>Prettier</code></li><li>antfu 定制版规则集<strong>eslint-plugin-antfu</strong>[3]</li></ul><p><code>Oxlint</code>吸取了上述产品的优点，默认提供了一套开箱即用的规则集。这套规则集主要关注**「代码的正确性」<strong>（比如</strong>「语法错误」<strong>、</strong>「冗余代码」<strong>、</strong>「容易造成误解的语法」<strong>）而不是</strong>「代码的细节优化」**（比如语法的性能、风格）。</p><p>所以，你只需要在项目执行如下命令，就能满足常规的校验：</p><div class="language-bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#61AFEF;">npx</span><span style="color:#98C379;"> oxlint@latest</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>从易用性上看，<code>Oxlint</code>比<code>Eslint</code>强很多。</p><h4 id="诊断可读性" tabindex="-1"><strong>诊断可读性</strong> <a class="header-anchor" href="#诊断可读性" aria-label="Permalink to &quot;**诊断可读性**&quot;">​</a></h4><p>当<code>linter</code>诊断出问题后，会给开发者提供相关信息。<code>Eslint</code>给的信息通常比较简短，只告诉你**「为什么报错」**。比如对于如下代码：</p><div class="language-javascript line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#C678DD;">let</span><span style="color:#E06C75;"> a</span><span style="color:#ABB2BF;">;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>通过信息**「a is defined but never used」<strong>可以知道报错原因是</strong>「a 定义了但未使用」**。</p><p>但如果是更复杂的规则，简短的信息可能并不能直观表达**「具体哪里报错」<strong>以及</strong>「解决办法」**，很多时候我们还需要查下规则文档，看看这条规则的具体含义，再结合报错的<a href="https://cloud.tencent.com/product/tcap?from_column=20065&amp;from=20065" target="_blank" rel="noreferrer">代码分析</a>。</p><p>相比于<code>Eslint</code>，<code>Oxlint</code>的信息更直观与准确。举个例子，下面的代码执行后会得到**「数字翻倍的数组」**：</p><div class="language-javascript line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#C678DD;">const</span><span style="color:#E5C07B;"> numbers</span><span style="color:#56B6C2;"> =</span><span style="color:#ABB2BF;"> [</span><span style="color:#D19A66;">1</span><span style="color:#ABB2BF;">, </span><span style="color:#D19A66;">2</span><span style="color:#ABB2BF;">, </span><span style="color:#D19A66;">3</span><span style="color:#ABB2BF;">, </span><span style="color:#D19A66;">4</span><span style="color:#ABB2BF;">, </span><span style="color:#D19A66;">5</span><span style="color:#ABB2BF;">];</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C678DD;">const</span><span style="color:#E5C07B;"> result</span><span style="color:#56B6C2;"> =</span><span style="color:#E5C07B;"> numbers</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">reduce</span><span style="color:#ABB2BF;">((</span><span style="color:#E06C75;font-style:italic;">accumulator</span><span style="color:#ABB2BF;">, </span><span style="color:#E06C75;font-style:italic;">current</span><span style="color:#ABB2BF;">) </span><span style="color:#C678DD;">=&gt;</span><span style="color:#ABB2BF;"> {</span></span>
<span class="line"><span style="color:#C678DD;">	return</span><span style="color:#ABB2BF;"> [...</span><span style="color:#E06C75;">accumulator</span><span style="color:#ABB2BF;">, </span><span style="color:#E06C75;">current</span><span style="color:#56B6C2;"> *</span><span style="color:#D19A66;"> 2</span><span style="color:#ABB2BF;">];</span></span>
<span class="line"><span style="color:#ABB2BF;">}, []);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">// [ 2, 4, 6, 8, 10 ]</span></span>
<span class="line"><span style="color:#E5C07B;">console</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">log</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;">result</span><span style="color:#ABB2BF;">);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>复制</p><p>这里每次执行<code>reduce</code>回调都会将数组展开，当数组比较长时会造成性能问题。</p><p>对此，<code>Oxlint</code>的信息包括三部分：</p><ul><li>为什么报错</li><li>具体哪里报错</li><li>怎么解决</li></ul><p><img src="`+c+'" alt="img"></p><p>这段示例代码比较简短，可能体现不出<code>Oxlint</code>信息的价值，让我们看看下面这段报错信息：</p><p><img src="'+l+'" alt="img"></p><p>一眼就能看出是哪个<code>reduce</code>（紫色字体）中的哪个展开操作（青色字体）引发的问题。</p><p>虽然有些同学会说：如果项目大了，<code>lint</code>信息这么详细看的人脑袋痛。</p><p>但我们要知道 —— **「你能提供，但我不用」<strong>和</strong>「你不能提供」**完全是两个概念。</p><p>从**「诊断可读性」**看，<code>Oxlint</code>比<code>Eslint</code>更优秀。</p><h4 id="参与成本" tabindex="-1"><strong>参与成本</strong> <a class="header-anchor" href="#参与成本" aria-label="Permalink to &quot;**参与成本**&quot;">​</a></h4><p>**「参与成本」**是指开发者自定义规则的成本。<code>Oxlint</code>是<code>Rust</code>编写的，如果开发者自定义规则也得写<code>Rust</code>，那成本就太高了。相比之下，<code>Eslint</code>的规则都是<code>JS</code>编写的，成本低很多。</p><p><code>Oxlint</code>从 2 个角度出发尝试解决这个问题：</p><ol><li>你别自己写了，官方将常用的规则都写好了</li></ol><h2 id="相关网址" tabindex="-1">相关网址 <a class="header-anchor" href="#相关网址" aria-label="Permalink to &quot;相关网址&quot;">​</a></h2><p>官网：<a href="https://oxc-project.github.io/" target="_blank" rel="noreferrer">https://oxc-project.github.io/</a></p><p>开源地址：<a href="https://github.com/oxc-project/oxc" target="_blank" rel="noreferrer">https://github.com/oxc-project/oxc</a></p><p>Oxc 提供了 VCode 插件供开发者使用：搜索 Oxc</p>',48)]))}const g=o(t,[["render",p]]);export{m as __pageData,g as default};
