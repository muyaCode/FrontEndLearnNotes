import{_ as t,c as r,o as e,ah as i}from"./chunks/framework.DqD713j2.js";const l="/FrontEndLearnNotes/assets/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.DElY3fOU.png",o="/FrontEndLearnNotes/assets/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B.7EWuY7s8.jpg",n="/FrontEndLearnNotes/assets/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8%E5%92%8CJavaScript%E5%BC%95%E6%93%8E%E7%9A%84%E5%85%B3%E7%B3%BB.DxWNkxRG.jpg",s="/FrontEndLearnNotes/assets/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84.DyU7zwEj.jpg",c="/FrontEndLearnNotes/assets/V8%E5%BC%95%E6%93%8E%E5%8E%9F%E7%90%86%E5%9B%BE.CywPaJt6.jpg",p="/FrontEndLearnNotes/assets/v8%E5%BC%95%E6%93%8E%E7%9A%84%E5%AE%98%E6%96%B9%E8%A7%A3%E6%9E%90%E5%9B%BE.DNM7q3qN.jpg",m=JSON.parse('{"title":"JavaScript 的运行环境","description":"","frontmatter":{},"headers":[],"relativePath":"Document/JavaScript笔记/JavaScript的运行和原理/JavaScript的运行环境.md","filePath":"Document/JavaScript笔记/JavaScript的运行和原理/JavaScript的运行环境.md","lastUpdated":1750954157000}'),h={name:"Document/JavaScript笔记/JavaScript的运行和原理/JavaScript的运行环境.md"};function v(d,a,g,u,E,S){return e(),r("div",null,a[0]||(a[0]=[i('<h1 id="javascript-的运行环境" tabindex="-1">JavaScript 的运行环境 <a class="header-anchor" href="#javascript-的运行环境" aria-label="Permalink to &quot;JavaScript 的运行环境&quot;">​</a></h1><h2 id="浏览器的工作原理、核心" tabindex="-1">浏览器的工作原理、核心 <a class="header-anchor" href="#浏览器的工作原理、核心" aria-label="Permalink to &quot;浏览器的工作原理、核心&quot;">​</a></h2><h3 id="浏览器工作原理图例" tabindex="-1">浏览器工作原理图例 <a class="header-anchor" href="#浏览器工作原理图例" aria-label="Permalink to &quot;浏览器工作原理图例&quot;">​</a></h3><p><img src="'+l+'" alt="浏览器工作原理"></p><h3 id="浏览器内核" tabindex="-1">浏览器内核 <a class="header-anchor" href="#浏览器内核" aria-label="Permalink to &quot;浏览器内核&quot;">​</a></h3><p>我们经常会说：不同的浏览器有不同的内核组成</p><ul><li><strong>Gecko</strong>：早期被 Netscape 和 Mozilla Firefox 浏览器浏览器使用；</li><li><strong>Trident</strong>：微软开发，被 IE4~IE11 浏览器使用，但是 Edge 浏览器已经转向 Blink；</li><li><strong>Webkit</strong>：苹果基于 KHTML 开发、开源的，用于 Safari，Google Chrome 之前也在使用；</li><li><strong>Blink</strong>：是 Webkit 的一个分支，Google 开发，目前应用于 Google Chrome、Edge、Opera 等;</li></ul><p>事实上，我们经常说的浏览器内核指的是浏览器的排版引擎</p><ul><li><strong>排版引擎</strong>(layout engine)，也称为<strong>浏览器引擎</strong>( browser engine )、<strong>页面染引擎</strong>(rendering engine)或<strong>样版引擎</strong>。</li></ul><h3 id="浏览器渲染过程" tabindex="-1">浏览器渲染过程 <a class="header-anchor" href="#浏览器渲染过程" aria-label="Permalink to &quot;浏览器渲染过程&quot;">​</a></h3><p>但是在浏览器执行过程中，HTML 解析的时候遇到了 JavaScript 标签，应该怎么办呢? 会停止解析 HTML，而去加载和执行 JavaScript 代码<img src="'+o+'" alt="浏览器渲染过程"></p><h2 id="javascript-引擎的解析" tabindex="-1">JavaScript 引擎的解析 <a class="header-anchor" href="#javascript-引擎的解析" aria-label="Permalink to &quot;JavaScript 引擎的解析&quot;">​</a></h2><h3 id="javascript-引擎就是-执行-javascript-的代码" tabindex="-1">JavaScript 引擎就是 执行 JavaScript 的代码 <a class="header-anchor" href="#javascript-引擎就是-执行-javascript-的代码" aria-label="Permalink to &quot;JavaScript 引擎就是 执行 JavaScript 的代码&quot;">​</a></h3><ul><li>JavaScript 是高级语言，高级的编程语言都是需要转成最终的机器指令来执行的</li><li>事实上我们编写的 JavaScript 无论你交给浏览器或者 Node 执行，最后都是需要被 CPU 执行的</li><li>但是 CPU 只认识自己的指令集，实际上是机器语言，才能被 CPU 所执行</li><li>所以我们需要<strong>JavaScript 引擎</strong>帮助我们<strong>将 JavaScript 代码翻译成 CPU 指令来执行</strong></li></ul><h3 id="常见的-javascript-引擎" tabindex="-1">常见的 JavaScript 引擎 <a class="header-anchor" href="#常见的-javascript-引擎" aria-label="Permalink to &quot;常见的 JavaScript 引擎&quot;">​</a></h3><ul><li><strong>SpiderMonkey</strong>：第一款 JavaScript 引擎，由 Brendan Eich 开发(也就是 JavaScript 作者);</li><li><strong>Chakra</strong>：微软开发，用于 IT 浏览器;</li><li><strong>JavaScriptCore</strong>：WebKit 中的 JavaScript 引擎，Apple 公司开发</li><li><strong>V8</strong>：Google 开发的强大 JavaScript 引擎，也帮助 Chrome 从众多浏览器中脱颖而出，Node 和 Chrome 谷歌浏览器都是使用的这个引擎;</li></ul><h3 id="浏览器内核和-javascript-引擎的关系" tabindex="-1">浏览器内核和 JavaScript 引擎的关系 <a class="header-anchor" href="#浏览器内核和-javascript-引擎的关系" aria-label="Permalink to &quot;浏览器内核和 JavaScript 引擎的关系&quot;">​</a></h3><p>这里我们先以 WebKit 为例，WebKit 事实上由两部分组成的</p><ul><li>WebCore：负责 HTML 解析、布局、染等等相关的工作</li><li>JavaScriptCore：解析、执行 JavaScript 代码;</li></ul><p><img src="'+n+'" alt="浏览器内核和JavaScript引擎的关系"></p><p>小程序的引擎架构</p><p><img src="'+s+'" alt="小程序的引擎架构"></p><h2 id="v8-引擎的工作原理" tabindex="-1">V8 引擎的工作原理 <a class="header-anchor" href="#v8-引擎的工作原理" aria-label="Permalink to &quot;V8 引擎的工作原理&quot;">​</a></h2><p>官方地址：<a href="https://developers.google.com/v8/" target="_blank" rel="noreferrer">https://developers.google.com/v8/</a></p><p>GitHub：<a href="https://github.com/v8/v8" target="_blank" rel="noreferrer">https://github.com/v8/v8</a></p><h3 id="v8-引擎的介绍" tabindex="-1">V8 引擎的介绍 <a class="header-anchor" href="#v8-引擎的介绍" aria-label="Permalink to &quot;V8 引擎的介绍&quot;">​</a></h3><ul><li>V8 是用 C ++编写的 Google 开源高性能 JavaScript 和 WebAssembly 引擎，它用于 Chrome 和 Nodejs 等。</li><li>它实现 ECMAScript 和 WebAssembly，并在 Windows 7 或更高版本，macOS 10.12+和使用 x64，IA-32，ARM 或 MIPS 处理器的 Linux 系统上运行。</li><li>V8 可以独立运行，也可以嵌入到任何 C ++应用程序中。</li></ul><h4 id="v8-引擎解析-javascript-代码原理" tabindex="-1">V8 引擎解析 JavaScript 代码原理 <a class="header-anchor" href="#v8-引擎解析-javascript-代码原理" aria-label="Permalink to &quot;V8 引擎解析 JavaScript 代码原理&quot;">​</a></h4><p>AST 抽象语法树生成网站：<a href="https://astexplorer.net/" target="_blank" rel="noreferrer">AST explorer</a></p><p><img src="'+c+'" alt="V8引擎原理图"></p><p>babel 下：</p><p>语法树运行顺序：ts --&gt; js --&gt; ast --&gt; generate code --&gt; js 代码</p><p>vue 的编译顺序：vue template --&gt; ast --&gt; createVNode</p><p>ES6 转 ES5 也是使用 AST 抽象语法树转换</p><h3 id="v8-引擎解析的架构" tabindex="-1">V8 引擎解析的架构 <a class="header-anchor" href="#v8-引擎解析的架构" aria-label="Permalink to &quot;V8 引擎解析的架构&quot;">​</a></h3><p>V8 引擎本身的源码非常复杂，大概有超过 100w 行 C++代码，通过了解它的架构，我们可以知道它是如何对 JavaScript 执行的：</p><p><strong>Parse</strong>模块会将 JavaScript 代码转换成 AST(抽象语法树)，这是因为解释器并不直接认识 JavaScript 代码;</p><ul><li>如果函数没有被调用，那么是不会被转换成 AST 的</li><li>Parse 的 V8 官方文档：<a href="https://v8.dev/blog/scanner" target="_blank" rel="noreferrer">https://v8.dev/blog/scanner</a></li></ul><p><strong>Ignition</strong>是一个解释器，会将 AST 转换成 ByteCode(字节码)</p><ul><li>同时会收集 TurboFan 优化所需要的信息(比如函数参数的类型信息，有了类型才能进行真实的运算)</li><li>如果函数只调用一次，Ignition 会执行解释执行 ByteCode;</li><li>Ignition 的 V8 官方文档：<a href="https://v8.dev/blog/ignition-interpreter" target="_blank" rel="noreferrer">https://v8.dev/blog/ignition-interpreter</a></li></ul><p><strong>TurboFan</strong>是一个编译器，可以将字节码编译为 CPU 可以直接执行的机器码;</p><ul><li>如果一个函数被多次调用，那么就会被标记为<strong>热点函数</strong>，那么就会经过 TurboFan 转换成优化的机器码，提高代码的执行性能</li><li>但是，<strong>机器码实际上也会被还原为 Bvteode</strong>，这是因为如果后续执行函数的过程中，类型发生了变化(比如 sum 函数原来执行的是 number 类型，后来执行变成了 string 类型)，之前优化的机器码并不能正确的处理运算，就会逆向的转换成字节码；</li><li>TurboFan 的 V8 官方文档：<a href="https://v8.dev/blog/turbofan-iit" target="_blank" rel="noreferrer">https://v8.dev/blog/turbofan-iit</a></li></ul><h3 id="v8-引擎的官方解析图" tabindex="-1">V8 引擎的官方解析图 <a class="header-anchor" href="#v8-引擎的官方解析图" aria-label="Permalink to &quot;V8 引擎的官方解析图&quot;">​</a></h3><p><img src="'+p+'" alt="v8引擎的官方解析图"></p><h3 id="v8-引擎执行的细节" tabindex="-1">V8 引擎执行的细节 <a class="header-anchor" href="#v8-引擎执行的细节" aria-label="Permalink to &quot;V8 引擎执行的细节&quot;">​</a></h3><h4 id="javascript-源码是如何被解析-parse-过程-的" tabindex="-1">JavaScript 源码是如何被解析(Parse 过程)的 <a class="header-anchor" href="#javascript-源码是如何被解析-parse-过程-的" aria-label="Permalink to &quot;JavaScript 源码是如何被解析(Parse 过程)的&quot;">​</a></h4><ul><li>1.Blink 浏览器内核将源码交给 V8 引擎，Stream 获取到源码并且进行编码转换;</li><li>2.Scanner 会进行词法分析(lexicalanalysis)，词法分析会将代码转换成 tokens;</li><li>3.接下来 tokens 会被转换成 AST 树，经过 Parser 和 PreParser: <ul><li>Parser 就是直接将 tokens 转成 AST 树架构;</li><li>PreParser 称之为<strong>预解析</strong>，为什么需要预解析呢? <ul><li>这是因为并不是所有的 JavaScript 代码，在一开始时就会被执行。那么对所有的 JavaScript 代码进行解析，必然会影响网页的运行效率;</li><li>所以 V8 引擎就实现了<strong>Lazy Parsing( 延迟解析)<strong>的方案，它的作用是将不必要的函数进行预解析，也就是只解析暂时需要的内容，而对</strong>函数的全量解析</strong>是在函数被调用时才会进行；</li><li>比如我们在一个函数 outer 内部定义了另外一个函数 inner，那么 inner 函数就会进行预解析</li></ul></li></ul></li><li>4.生成 AST 树后，会被 Ignition 转成字节码（bytecode），之后的过程就是代码的执行过程--&gt;后续会详细分析</li></ul><h4 id="javascript-代码在-v8-引擎中的运行过程" tabindex="-1">JavaScript 代码在 V8 引擎中的运行过程 <a class="header-anchor" href="#javascript-代码在-v8-引擎中的运行过程" aria-label="Permalink to &quot;JavaScript 代码在 V8 引擎中的运行过程&quot;">​</a></h4><ul><li>1.代码被解析，v8 引擎内部会帮助我们创建一个对象：Global Object（全局对象） -&gt; Go <ul><li>该对象 所有的作用域( scope )都可以访问;</li><li>里面会包含<code>Date、Array、String、Number、setTimeout、setInterval</code>等等</li><li>其中还有一个<code>window属性</code>指向自己</li></ul></li><li>2.运行代码 <ul><li>2.1. v8 为了执行代码，v8 引肇内部会有一个执行上下文栈(Execution Context Stack，ECStack)(函数调用栈) <ul><li>执行的是全局的代码块：</li><li>1.全局的代码块为了执行会构建一个 Global Execution Context(GEC)</li><li>2.GEC 会 被<strong>放入到 ECS</strong>中执行；</li><li>GEC 被放入到 ECS 中里面包含两部分内容 <ul><li>第一部分：在代码执行前，在<code>parser转成AST的过程</code>中，会将<code>全局定义的变量、函数</code>等加入到<code>GlobalObject</code>中但是<code>并不会赋值</code>； √ 这个过程也称之为变量的作用域提升( hoisting )</li><li>第二部分：在代码执行中，对变量赋值，或者执行其他的函数；</li></ul></li></ul></li><li>2.2. 因为我们执行的是全局代码，为了全局代码能够正常的执行，需要创建 全局执行上下文(Global Execution Cntext)(全局代码需要被执行时才会创建)</li></ul></li></ul>',49)]))}const J=t(h,[["render",v]]);export{m as __pageData,J as default};
