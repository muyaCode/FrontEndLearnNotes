import{_ as i,c as p,o as t,ah as o}from"./chunks/framework.DqD713j2.js";const g=JSON.parse('{"title":"JavaScript高级学习指南","description":"","frontmatter":{},"headers":[],"relativePath":"Document/JavaScript笔记/JavaScript高级/JavaScript高级学习指南.md","filePath":"Document/JavaScript笔记/JavaScript高级/JavaScript高级学习指南.md","lastUpdated":1750954157000}'),a={name:"Document/JavaScript笔记/JavaScript高级/JavaScript高级学习指南.md"};function r(e,l,u,s,n,c){return t(),p("div",null,l[0]||(l[0]=[o('<h1 id="javascript高级学习指南" tabindex="-1">JavaScript高级学习指南 <a class="header-anchor" href="#javascript高级学习指南" aria-label="Permalink to &quot;JavaScript高级学习指南&quot;">​</a></h1><p>MDN工具书网站查询：<a href="https://developer.mozilla.org/zh-CN/" target="_blank" rel="noreferrer">MDN Web Docs (mozilla.org)</a></p><h2 id="_1-javascript-面向对象opp编程" tabindex="-1">1.JavaScript 面向对象OPP编程 <a class="header-anchor" href="#_1-javascript-面向对象opp编程" aria-label="Permalink to &quot;1.JavaScript 面向对象OPP编程&quot;">​</a></h2><h3 id="简介" tabindex="-1">简介 <a class="header-anchor" href="#简介" aria-label="Permalink to &quot;简介&quot;">​</a></h3><ul><li><p>面向对象介绍</p><ul><li>面向对象把事务分解成一个个对象，然后由对象之间分工与合作</li></ul></li><li><p>面向对象优点</p><ul><li>代码灵活、可复用、容易维护和开发，适合多人合作的大型软件项目</li></ul></li><li><p>面向对象特性</p><ul><li><p>封装性</p><ul><li><p>我们平时所用的方法和类都是一种封装，当我们在项目开发中，遇到一段功能的代码在好多地方重复使用的时候，我们可以把他单独封装成一个功能的方法，这样在我们需要使用的地方直接调用就可以了。</p></li><li><p>封装的优势在于定义只可以在类内部进行对属性的操作，外部无法对这些属性指手画脚，要想修改，也只能通过你定义的封装方法；</p></li></ul></li><li><p>继承性</p><ul><li><p>继承在我们的项目开发中主要使用为子类继承父类</p></li><li><p>继承减少了代码的冗余，省略了很多重复代码，开发者可以从父类底层定义所有子类必须有的属性和方法，以达到耦合的目的；</p></li><li><p>特别提醒：继承会继承父类的实例属性和实例方法，并不会继承静态属性和静态方法，并且静态方法只能通过类名去调用。</p></li></ul></li><li><p>多态性</p><ul><li><p>多态的具体表现为方法重载和方法重写：</p></li><li><p>方法重载：重载是指不同的函数使用相同的函数名，但是函数的参数个数或类型不同。调用的时候根据函数的参数来区别不同的函数</p></li><li><p>方法重写：重写（也叫覆盖）是指在派生类中重新对基类中的虚函数（注意是虚函数）重新实现。即函数名和参数都一样，只是函数的实现体不一样</p></li><li><p>多态实现了方法的个性化，不同的子类根据具体状况可以实现不同的方法，光有父类定义的方法不够灵活，遇见特殊状况就捉襟见肘了</p></li></ul></li></ul></li><li><p>面向对象和面向过程概念总结比较</p><ul><li><p>总结</p><ul><li><p>面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候再一个一个的依次调用就可以了。</p></li><li><p>面向对象是把事务分解成为一个个对象，然后由对象之间分工与合作。</p></li></ul></li><li><p>比较</p><ul><li><p>面向过程性能比面向对象高，适合跟硬件联系很紧密的东西,但是不易维护、不易复用、不易扩展。</p></li><li><p>面向对象易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统 更加灵活、更加易于维护，但是性能比面向过程低。</p></li></ul></li></ul></li></ul><h3 id="类和对象" tabindex="-1">类和对象 <a class="header-anchor" href="#类和对象" aria-label="Permalink to &quot;类和对象&quot;">​</a></h3><ul><li><p>对象</p><ul><li><p>在JavaScript中，对象是一组无序的相关属性的方法的集合，所有的事物都是对象</p><ul><li>例如：字符串、数组、函数、数值</li></ul></li><li><p>对象是由属性和方法组成</p><ul><li><p>属性</p><ul><li>事物的特征，在对象中用属性来表示</li></ul></li><li><p>方法</p><ul><li>事物的行为，在对象中用方法来表示</li></ul></li></ul></li></ul></li><li><p>类class</p><ul><li><p>ES6中增加了类的概念，可以使用class关键字声明一个类，之后以这个类实例化对象</p></li><li><p>类抽象了对象的公共部分，它泛指某一大类（class）对象特指某一个，通过类实例化一个具体的对象</p></li><li><p>类的实例化</p><ul><li><p>class Name{ constructor(uname){ this.uname } sing(){ console.log(this.uname) } }</p></li><li><p>var zs = new Name(&#39;张三&#39;);</p></li><li><p>zs.sing()</p></li></ul></li><li><p>类的继承</p><ul><li><p>代码</p><ul><li><p>class Father{ constructor(uname){ this.uname } say(){ return &#39;111&#39;; } }</p></li><li><p>class Son extends Father { constructor(x){ super(x) } say(){ super.say() } }</p><ul><li><p>super(x)</p><ul><li><p>先调用父类的构造函数</p></li><li><p>子类调用必须写在子类this之前调用</p></li><li><p>然后才可以调用父类的方法</p></li></ul></li><li><p>super.say()</p><ul><li>调用父类的普通函数</li></ul></li></ul></li></ul></li><li><p>继承中的属性或者方法查找原则</p><ul><li><p>就近原则</p></li><li><p>1.继承中，如果实例化子类输出一个方法，先看子类有没有这个方法，如果有就先执行子类</p></li><li><p>2.继承中，如果子类里面没有，就去查找父类有没有这个方法，如果有，就执行父类的这个方法(就近原则)</p></li></ul></li></ul></li><li><p>注意</p><ul><li><p>1.在ES6中类没有变量提升，所以必须先定义类，才能通过实例化对象</p></li><li><p>2.公有的属性和方法调用要在构造函数里加this.</p></li><li><p>3.类里面的this指向问题</p></li><li><p>4.constructor 里面的this指向实例化对象， 方法里面的this指向这个方法的调用者</p></li></ul></li></ul></li></ul><h3 id="类的使用" tabindex="-1">类的使用 <a class="header-anchor" href="#类的使用" aria-label="Permalink to &quot;类的使用&quot;">​</a></h3><ul><li><p>基本使用</p><ul><li><p>1.创建类 class</p><ul><li>class Name { // 在类中使用constructor来放置属性 construtor(name,age) { this.name = name this.age= age } // 在类中添加方法 sing(song){ console.log(this.name + song) } }</li></ul></li><li><p>2.实例化类对象</p><ul><li>let zs = new Name(&#39;张三&#39;,18)</li></ul></li><li><p>3.实例化后调用类的方法</p><ul><li>zs.sing(&#39;我爱你你却爱着他&#39;)</li></ul></li></ul></li><li><p>类的继承</p><ul><li><p>子类继承父类基本示例</p><ul><li><p>extends 关键字可以实现子类继承父类</p></li><li><p>​ class Father { constructor() { } money(){ console.log(&#39;钱钱钱&#39;) } } class Son extends Father { } let son = new Son() son.money();</p></li></ul></li><li><p>super关键字的使用</p><ul><li><p>super 关键字 用于访问和调用对象父类上的函数 可以调用父类的构造函数，也可以调用父类的普通函数</p></li><li><p>​ class Father { constructor(x,y) { this.x = x this.y = y } sum(){ console.log(this.x + this.y) } say(){ return &#39;我是父类&#39; } } class Son extends Father { constructor(x,y){ // 调用了父类中的构造函数 super(x, y); } say(){ // super.say()调用了父类的say方法 console.log(super.say() + &#39;的子类&#39;) } } let son = new Son(1,2) son.sum(); son.say();</p></li></ul></li><li><p>子类继承父类方法同时扩展方法</p><ul><li>​ class Father { constructor(x,y) { this.x = x this.y = y } sum(){ console.log(this.x + this.y) } } class Son extends Father { constructor(x,y){ // 利用super调用父类的构造函数 // 必须写在子类this之前调用操作 super(x,y) this.x = x this.y = y } substrcact(x,y){ console.log(this.x + this.y) } } let son = new Son(5,2) son.substrcact(); son.sum();</li></ul></li></ul></li><li><p>类和对象的三个注意点</p><ul><li><p>1.在 ES6 中类没有变量提升，必须先定义类，才能通过类实例化对象</p></li><li><p>2.类里面共有的属性和方法一定要加this调用</p></li><li><p>3.类里面的this指向问题</p></li><li><p>this指向示例说明</p><ul><li>​ 点击 class Star { constructor(name,age) { const that = this // constructor里面的this指向的是 创建的实例对象 this.name = name this.age = age this.btn = document.querySelector(&#39;button&#39;) this.btn.onclick = this.sing; } sing(){ // 这个方法的this 指向的是 btn 这个按钮 // 因为这个按钮调用了这个函数 console.log(this) // that是constructor的this是要打印出名字 console.log(that.name) } dance(){ // 这个方法里面的this指向的是实例对象 ldh console.log(this) } } let ldh = new Star(&#39;刘德华&#39;);</li></ul></li></ul></li></ul><h3 id="面向对象案例" tabindex="-1">面向对象案例 <a class="header-anchor" href="#面向对象案例" aria-label="Permalink to &quot;面向对象案例&quot;">​</a></h3><ul><li>tab栏切换</li></ul><h2 id="_2-javascript-函数进阶—构造函数和原型实现类的机制" tabindex="-1">2.JavaScript 函数进阶—构造函数和原型实现类的机制 <a class="header-anchor" href="#_2-javascript-函数进阶—构造函数和原型实现类的机制" aria-label="Permalink to &quot;2.JavaScript 函数进阶—构造函数和原型实现类的机制&quot;">​</a></h2><h3 id="构造函数和原型" tabindex="-1">构造函数和原型 <a class="header-anchor" href="#构造函数和原型" aria-label="Permalink to &quot;构造函数和原型&quot;">​</a></h3><ul><li><p>使用构造函数创建对象</p><ul><li><p>对象的创建三种方式</p><ul><li><p>new 关键字</p><ul><li>var obj1 = new Object()</li></ul></li><li><p>字面量方式</p><ul><li>var obj2 = {}</li></ul></li><li><p>自定义构造函数创建对象</p><ul><li>function Star(uname, age){ this.uname = uname; this.age = age; this.sing = function() { console.log(&quot;哈哈哈来了&quot;) } } // 实例化调用 var ldh = new Star(&#39;刘德华&#39;, 18); ldh.sing();</li></ul></li></ul></li><li><p>1.构造函数创建对象的new 执行做的事情</p><ul><li><p>在内存中创建一个新的空对象。</p></li><li><p>让 this 指向这个新的对象。</p></li><li><p>执行构造函数里面的代码，给这个新对象添加属性和方法。</p></li><li><p>返回这个新对象（构造函数里面不需要 return ）。</p></li></ul></li><li><p>2.构造函数的实例成员和静态成员</p><ul><li><p>成员：在构造函数中的属性和方法我们统称为成员</p></li><li><p>1、什么是实例成员</p><ul><li><p>实例成员 是构造函数内部通过this添加的成员,实例成员只能通过实例化的对象来访问</p><ul><li><p>ldh.uname</p></li><li><p>ldh.sing()</p></li></ul></li></ul></li><li><p>2、什么是静态成员</p><ul><li><p>静态成员是 在构造函数本身上添加的成员,只能通过构造函数来访问,不能通过由构造函数创建的实例访问</p><ul><li><p>Star.sex = &quot;男&quot;</p></li><li><p>sex就是静态成员</p></li></ul></li></ul></li></ul></li><li><p>3.构造函数的弊端：存在浪费内存的问题。</p><ul><li><p>实例化一个对象就开辟一个新内存</p></li><li><p>解决方法</p><ul><li>使用prototype原型</li></ul></li></ul></li></ul></li><li><p>1.构造函数的原型对象 prototype</p><ul><li><p>原型：每一个构造函数都有一个 prototype 属性，指向另一个对象。这个 prototype 就是一个对象，这个对象的所有属性和方法，都会被构造函数所拥有。</p></li><li><p>我们可以把那些不变的方法，直接定义在prototype 对象上，这样所有对象的实例就可以共享这些方法</p></li><li><p>示例</p><ul><li><p>function Star(uname, age){ this.uname = uname; this.age = age; } Star.prototype.sing = function(){ console.log(&quot;哈哈哈来了&quot;) } // 实例化调用 var ldh = new Star(&#39;刘德华&#39;, 18); ldh.sing();</p></li><li><p>Star.prototype.sing = function(){ console.log(&quot;哈哈哈来了&quot;) }</p><ul><li><p>把公共的方法 ，定义在在原型对象上</p></li><li><p>所有对象的实例就都可以使用这个方法</p></li></ul></li></ul></li></ul></li><li><p>2.对象的原型 <strong>proto</strong></p><ul><li><p>示例</p><ul><li><p>function Star(uname, age){ this.uname = uname; this.age = age; } Star.prototype.sing = function(){ console.log(&quot;哈哈哈来了&quot;) } // 实例化调用 var ldh = new Star(&#39;刘德华&#39;, 18); ldh.sing(); console.log(ldh) console.log(ldh.<strong>proto</strong> === Star.prototype)</p></li><li><p>console.log(ldh)</p><ul><li><p>对象身上系统自己添加一个__proto__ 属性，它指向构造函数的原型对象</p></li><li><p>console.log(ldh.<strong>proto</strong> === Star.prototype)</p><ul><li>返回true</li></ul></li></ul></li></ul></li><li><p>实例对象原型总结</p><ul><li><p>1.实例对象原型：实例对象有一个属性 <strong>proto</strong> 指向构造函数的 prototype 原型对象。</p></li><li><p>2.实例对象原型__proto__ 和 构造函数的prototype 是等价的。</p></li><li><p>3.方法的查找规则：首先 先看实例对象身上是否有方法,如果有就执行这个实例对象上的方法，如果没有这个方法，因为有__proto__ 的存在，就去 构造函数原型对象prototype 身上去查找方法。</p></li></ul></li><li><p>__proto__对象原型的意义就在于 为对象的查找机制提供一个方向，或者说一个路线，但它是一个非标准属性，因此在实际开发中，不可以使用这个属性，它只是内部指向原型对象 prototype</p></li></ul></li><li><p>3.原型里的 constructor 构造函数</p><ul><li><p>constructor 手动指回原来的构造函数</p></li><li><p>原因</p><ul><li><p>实例对象原型（ <strong>proto</strong>）和构造函数原型对象（prototype）里面都有一个属性 constructor 属性 ，constructor 我们称为构造函数，因为它指回构造函数本身。</p></li><li><p>一般情况下，对象的方法都在构造函数的原型对象中设置。 如果有多个对象的方法，我们可以给原型对象采取对象形式赋值，但是这样就会覆盖构造函数原型对象原来的内容，这样修改后的原型对象 constructor 就不再指向当前构造函数了。 此时，我们可以在修改后的原型对象中，添加一个 constructor 指向原来的构造函数。</p></li></ul></li><li><p>示例</p><ul><li><p>function Star(uname, age){ this.uname = uname; this.age = age; } // 以对象形式添加的方法， // 要用constructor手动指回构造函数 Star.prototype={ constructor: Star, sing: function(){ console.log(&quot;我会唱歌&quot;) } movie: function(){ console.log(&quot;看电影咯&quot;) } } // 实例化调用 var ldh = new Star(&#39;刘德华&#39;, 18); console.log(Star.prototype) console.log(ldh.<strong>proto</strong>)</p></li><li><p>constructor: Star,</p><ul><li>用constructor手动指回构造函数Star</li></ul></li></ul></li></ul></li><li><p>4.构造函数和原型总结</p><ul><li><p>三者总结</p><ul><li><p>prototype: 每一个构造函数都有一个prototype属性,指向的是该构造函数的原型对象。</p></li><li><p><strong>proto</strong>: 每一个实例对象都有一个__proto__属性,指向构造函数的原型对象。</p></li><li><p>constructor: 实例对象原型__proto__和构造函数prototype原型对象里面都有一个属性 constructor 属性 ，都指向了构造函数。</p><ul><li>如果用对象形式 定义方法，就要使用 (constructor:构造函数名) 重新指回构造函数</li></ul></li></ul></li><li><p>三者关系:</p><ul><li><p>1.构造函数的prototype属性指向了构造函数原型对象。</p></li><li><p>2.实例对象是由构造函数创建的,实例对象的__proto__属性指向了构造函数的原型对象。</p></li><li><p>3.构造函数的原型对象的constructor属性指向了构造函数, 实例对象的原型的constructor属性也指向了构造函数。</p></li></ul></li></ul></li><li><p>5.原型链</p><ul><li><p>1.只要是对象就有 <strong>proto</strong> 原型，指向原型对象</p></li><li><p>2.构造函数Star原型对象里面的__proto__ 原型指向的是Object.prototype</p></li><li><p>3.Object.prototype原型对象里面的 <strong>proto</strong> 原型 ，指向为 null</p></li><li><p>每一个实例对象又有一个__proto__属性，指向的构造函数的原型对象，构造函数的原型对象也是一个对象，也有__proto__属性，这样一层一层往上找就形成了原型链。</p></li></ul></li><li><p>6.对象成员查找规则 (JavaScript的成员查找机制)</p><ul><li>1.当访问一个对象的属性（包括方法）时，首先查找这个对象自身有没有该属性。 2.如果没有就查找它的原型（也就是 __proto__指向的 prototype 原型对象）。 3.如果还没有就查找原型对象的原型（Object的原型对象）。 4.依此类推一直找到 Object 为止（null），按照原型链的方式去查找。</li></ul></li><li><p>7.原型对象this指向</p><ul><li><p>构造函数中的this 与 原型对象的this 都是指向的是 new出来的实例对象 (ldh)</p></li><li><p>示例</p><ul><li><p>function Star(uname, age){ this.uname = uname; this.age = age; } Star.prototype.sing = function(){ console.log(&quot;哈哈哈来了&quot;) } // 实例化调用 var ldh = new Star(&#39;刘德华&#39;, 18);</p></li><li><p>现在的this指向的是 ldh 这个实例对象</p></li></ul></li></ul></li><li><p>8.原型对象的应用</p><ul><li><p>扩展内置对象方法</p><ul><li><p>Array.prototype.sum = function(){}</p></li><li><p>注意</p><ul><li>数组和字符串内置对象不能给原型对象覆盖操作 Array.prototype = {}，只能是 Array.prototype.xxx = function(){} 的方式，否则会覆盖了该原型的方法</li></ul></li></ul></li></ul></li></ul><h3 id="继承" tabindex="-1">继承 <a class="header-anchor" href="#继承" aria-label="Permalink to &quot;继承&quot;">​</a></h3><ul><li><p>1.call方法的使用</p><ul><li><p>作用</p><ul><li><p>1.call() 可以调用函数</p></li><li><p>2.call() 可以改变这个函数的this指向</p></li></ul></li><li><p>示例</p><ul><li>function fn(x,y) { console.log(&#39;调用了函数&#39;) console.log(this) console.log(x + y) } var obj = { name: &#39;憨憨&#39;, } fn() // 调用函数 fn.call() // 改变这个函数的this指向，指向obj 对象 fn.call(obj ,1,2) // 可以传参数：1,2 分别是x,y</li></ul></li><li><p>1.子构造函数继承父构造函数属性</p><ul><li><p>function Father(uname, age) { // this指向父构造函数的对象实例 this.uname = uname this.age= age } function Son(uname, age, score) { // this指向子构造函数的对象实例 // 子构造函数继承父构造函数属性 Father.call(this, uname, age) this.score = score } var son = new Son(&#39;刘德华&#39;, 18, 100) console.log(son)</p></li><li><p>// this指向子构造函数的对象实例 // 和子构造函数继承父构造函数属性 Father.call(this, uname, age)</p></li></ul></li><li><p>2.子构造函数继承父构造函数方法</p><ul><li><p>利用原型对象继承方法</p><ul><li><p>function Father(uname, age) { // this指向父构造函数的对象实例 this.uname = uname this.age= age } function Son(uname, age, score) { // this指向子构造函数的对象实例 // 和子构造函数继承父构造函数属性 Father.call(this, uname, age) this.score = score } // 子构造函数的原型指向new出来的父构造函数 Son.prototype = new Father(); // constructor 指回原来的原型对象 Son.prototype.constructor = Son; // 子构造函数专属方法 Son.prototype.exam = functio(){ console.log(&#39;孩子要考试&#39;) } var son = new Son(&#39;刘德华&#39;, 18, 100) console.log(son)</p></li><li><p>// 子构造函数的原型指向new出来的父构造函数 Son.prototype = new Father(); // 不能直接父子构造函数的prototype赋值，相当于复制地址指向，后面各种方法都会共用，没有独立的方法</p></li></ul></li><li><p>子构造函数继承父构造函数方法总结</p><ul><li><p>1.定义父构造函数，为父元素添加方法</p></li><li><p>2.定义子构造函数，子构造函数要继承父构造函数中的方法</p></li><li><p>3.在子构造函数中通过 call() 把父类型的 this 指向子类型的 this ，这样就可以实现子类型继承父类型的属性</p></li><li><p>4.将子构造函数的原型对象指向父构造函数的实例</p></li><li><p>5.因为修改了子构造函数原型对象,一定要利用constructor 指回子构造函数</p></li></ul></li></ul></li></ul></li></ul><h3 id="es5中新增的方法" tabindex="-1">ES5中新增的方法 <a class="header-anchor" href="#es5中新增的方法" aria-label="Permalink to &quot;ES5中新增的方法&quot;">​</a></h3><ul><li><p>数组方法</p><ul><li><p>迭代(遍历数组) forEach</p><ul><li><p>forEach是用来遍历数组的</p><ul><li>常用语遍历出数组的值，再添加到元素节点上</li></ul></li><li><p>arr.forEach(function(value, index, array) {})</p><ul><li><p>参数 value 是数组元素</p></li><li><p>参数 index 是数组元素的索引</p></li><li><p>参数 array 是当前遍历的数组</p></li></ul></li></ul></li><li><p>筛选数组 filter 方法</p><ul><li><p>filter是用来过滤数组的，会将满足条件的数组元素保存到一个新数组中，返回值为新数组</p><ul><li>常用于条件查询，把满足条件的显示相应的列表筛选出来</li></ul></li><li><p>var newArr = arr.filter(function(currentValue, index, arr) {})</p><ul><li><p>参数 currentValue 是数组当前项的值</p></li><li><p>参数 index 是当前数组的索引</p></li><li><p>参数 arr 是数组对象本身</p></li></ul></li></ul></li><li><p>some方法</p><ul><li><p>some 也是查找满足条件的元素是否存在 ，返回的是一个布尔值（true，false）， 如果查找到第一个满足条件的元素就终止循环</p><ul><li>用于查询唯一的元素</li></ul></li><li><p>arr.some(function(currentValue, index, arr) {})</p><ul><li><p>参数 currentValue 是数组当前项的值</p></li><li><p>参数 index 是当前数组的索引</p></li><li><p>参数 arr 是数组对象本身</p></li></ul></li></ul></li><li><p>区别总结</p><ul><li><p>some和forEach区别</p><ul><li><p>如果查询数组中唯一的元素,用some更合适,some遇到true就会终止循环,效率更高</p></li><li><p>forEach中return不会终止迭代</p></li></ul></li><li><p>数组的forEach、some、filter区别</p><ul><li><p>forEach一般应用于数组的遍历,没有返回值</p></li><li><p>some一般应用于查询数组中唯一的元素, 用some方法更合适,遇到 return true 就是终止遍历 迭代效率更高,返回值是布尔值</p></li><li><p>filter一般应用于数据的筛选,遇到return不会终止迭代,返回值是一个新数组</p></li></ul></li></ul></li><li><p>其他相似方法</p><ul><li><p>arr.map()</p></li><li><p>arr.every()</p></li></ul></li></ul></li><li><p>字符串方法</p><ul><li><p>str.trim()方法 去除字符串两侧空格</p><ul><li><p>str.trim() 方法会从一个字符串的两端删除空白字符。</p></li><li><p>str.trim() 方法并不影响原字符串本身，它返回的是一个新的字符串。</p></li></ul></li></ul></li><li><p>对象方法</p><ul><li><p>Object.keys(obj)获取对象属性名</p><ul><li><p>对象方法Object.keys() 方法，返回一个对象的所有的属性并保存到一个数组中</p></li><li><p>var arr = Object.keys(obj)</p></li></ul></li><li><p>Object.defineProperty(obj, prop, descriptor) 定义新属性或修改原有的属性 方法。</p><ul><li><p>参数 obj 是 当前设置的对象。（必须）</p></li><li><p>参数 prop 是 需定义或修改的属性的名字。（必须）</p></li><li><p>参数 descriptor 是一个对象。 对象中有多个属性。（必须）</p><ul><li><p>{ value: 100, writable: true, enumerable: true, configurable: true, }</p></li><li><p>属性一 value: 设置属性的值</p></li><li><p>属性二 writable: false/true 如果值为false ，不允许修改这个属性值， 默认值也是false</p></li><li><p>属性三 enumerable: false/true 如果值为false ，则不允许遍历，默认的值是 false</p></li><li><p>属性四 configurable: false/true 如果为false， 则不允许删除这个属性， 不允许在修改第三个参数里面的特性 ，默认为false</p></li></ul></li></ul></li></ul></li></ul><h2 id="_3-javascript-正则表达式" tabindex="-1">3.JavaScript 正则表达式 <a class="header-anchor" href="#_3-javascript-正则表达式" aria-label="Permalink to &quot;3.JavaScript 正则表达式&quot;">​</a></h2><h2 id="_4-javascript的promise" tabindex="-1">4.JavaScript的Promise <a class="header-anchor" href="#_4-javascript的promise" aria-label="Permalink to &quot;4.JavaScript的Promise&quot;">​</a></h2><h2 id="_5-javascript的canvas学习" tabindex="-1">5.JavaScript的Canvas学习 <a class="header-anchor" href="#_5-javascript的canvas学习" aria-label="Permalink to &quot;5.JavaScript的Canvas学习&quot;">​</a></h2>',21)]))}const m=i(a,[["render",r]]);export{g as __pageData,m as default};
