import{_ as n,c as a,o as l,ah as p}from"./chunks/framework.DqD713j2.js";const b=JSON.parse('{"title":"Node原理和机制","description":"","frontmatter":{},"headers":[],"relativePath":"Document/Node/Node原理和机制.md","filePath":"Document/Node/Node原理和机制.md","lastUpdated":1750954157000}'),e={name:"Document/Node/Node原理和机制.md"};function o(r,s,c,t,i,y){return l(),a("div",null,s[0]||(s[0]=[p(`<h1 id="node原理和机制" tabindex="-1">Node原理和机制 <a class="header-anchor" href="#node原理和机制" aria-label="Permalink to &quot;Node原理和机制&quot;">​</a></h1><p>指南：<a href="https://nodejs.org/zh-cn/docs/guides" target="_blank" rel="noreferrer">指南 | Node.js (nodejs.org)</a></p><p>Node的依赖和原理：<a href="https://nodejs.org/zh-cn/docs/meta/topics/dependencies" target="_blank" rel="noreferrer">所有依赖项 | Node.js (nodejs.org)</a></p><h2 id="核心剖析javascript事件循环" tabindex="-1">核心剖析JavaScript事件循环 <a class="header-anchor" href="#核心剖析javascript事件循环" aria-label="Permalink to &quot;核心剖析JavaScript事件循环&quot;">​</a></h2><p>包括浏览器和Node中的事件循环、宏队列、微队列</p><p>防抖、节流等等</p><h2 id="node事件轮询机制" tabindex="-1">Node事件轮询机制 <a class="header-anchor" href="#node事件轮询机制" aria-label="Permalink to &quot;Node事件轮询机制&quot;">​</a></h2><p>官网文档：<a href="https://nodejs.org/zh-cn/docs/guides/event-loop-timers-and-nexttick" target="_blank" rel="noreferrer">Node.js 事件循环，定时器和 process.nextTick() | Node.js (nodejs.org)</a></p><div class="language-bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#61AFEF;">   ┌───────────────────────────┐</span></span>
<span class="line"><span style="color:#61AFEF;">┌─</span><span style="color:#ABB2BF;">&gt;</span><span style="color:#98C379;">│</span><span style="color:#98C379;">           timers</span><span style="color:#98C379;">          │</span><span style="color:#98C379;">  本阶段执行setTimeout</span><span style="color:#ABB2BF;">() </span><span style="color:#98C379;">和</span><span style="color:#98C379;"> setInterval</span><span style="color:#ABB2BF;">()</span></span>
<span class="line"><span style="color:#61AFEF;">│</span><span style="color:#98C379;">  └─────────────┬─────────────┘</span></span>
<span class="line"><span style="color:#61AFEF;">│</span><span style="color:#98C379;">  ┌─────────────┴─────────────┐</span></span>
<span class="line"><span style="color:#61AFEF;">│</span><span style="color:#98C379;">  │</span><span style="color:#98C379;">     pending</span><span style="color:#98C379;"> callbacks</span><span style="color:#98C379;">     │</span><span style="color:#98C379;">  这个阶段执行一些诸如TCP错误之类的系统操作的回调</span></span>
<span class="line"><span style="color:#61AFEF;">│</span><span style="color:#98C379;">  └─────────────┬─────────────┘</span></span>
<span class="line"><span style="color:#61AFEF;">│</span><span style="color:#98C379;">  ┌─────────────┴─────────────┐</span></span>
<span class="line"><span style="color:#61AFEF;">│</span><span style="color:#98C379;">  │</span><span style="color:#98C379;">       idle,</span><span style="color:#98C379;"> prepare</span><span style="color:#98C379;">       │</span><span style="color:#98C379;">  只内部使用</span></span>
<span class="line"><span style="color:#61AFEF;">│</span><span style="color:#98C379;">  └─────────────┬─────────────┘</span><span style="color:#98C379;">      ┌───────────────┐</span></span>
<span class="line"><span style="color:#61AFEF;">│</span><span style="color:#98C379;">  ┌─────────────┴─────────────┐</span><span style="color:#98C379;">      │</span><span style="color:#98C379;">   incoming:</span><span style="color:#98C379;">   │</span></span>
<span class="line"><span style="color:#61AFEF;">│</span><span style="color:#98C379;">  │</span><span style="color:#98C379;">           poll</span><span style="color:#98C379;">            │</span><span style="color:#ABB2BF;">&lt;</span><span style="color:#98C379;">─────┤</span><span style="color:#98C379;">  connections,</span><span style="color:#98C379;"> │</span><span style="color:#98C379;"> 获取新的</span><span style="color:#98C379;"> I/0</span><span style="color:#98C379;"> 事件，查找已经到时的定时器</span></span>
<span class="line"><span style="color:#61AFEF;">│</span><span style="color:#98C379;">  └─────────────┬─────────────┘</span><span style="color:#98C379;">      │</span><span style="color:#98C379;">   data,</span><span style="color:#98C379;"> etc.</span><span style="color:#98C379;">  │</span></span>
<span class="line"><span style="color:#61AFEF;">│</span><span style="color:#98C379;">  ┌─────────────┴─────────────┐</span><span style="color:#98C379;">      └───────────────┘</span></span>
<span class="line"><span style="color:#61AFEF;">│</span><span style="color:#98C379;">  │</span><span style="color:#98C379;">           check</span><span style="color:#98C379;">           │</span><span style="color:#98C379;">  setImmediate</span><span style="color:#ABB2BF;">()</span></span>
<span class="line"><span style="color:#61AFEF;">│</span><span style="color:#98C379;">  └─────────────┬─────────────┘</span></span>
<span class="line"><span style="color:#61AFEF;">│</span><span style="color:#98C379;">  ┌─────────────┴─────────────┐</span></span>
<span class="line"><span style="color:#61AFEF;">└──┤</span><span style="color:#98C379;">      close</span><span style="color:#98C379;"> callbacks</span><span style="color:#98C379;">      │</span><span style="color:#98C379;">  关闭事件的回调</span><span style="color:#98C379;"> socket.close事件</span></span>
<span class="line"><span style="color:#61AFEF;">   └───────────────────────────┘</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>先看一段node执行的代码</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#7F848E;font-style:italic;">// </span></span>
<span class="line"><span style="color:#61AFEF;">setImmediate</span><span style="color:#ABB2BF;">(</span><span style="color:#C678DD;">function</span><span style="color:#ABB2BF;"> () {</span><span style="color:#E5C07B;">console</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">log</span><span style="color:#ABB2BF;">(</span><span style="color:#98C379;">&#39;setImmediate( )&#39;</span><span style="color:#ABB2BF;">});</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">// 定时器                    </span></span>
<span class="line"><span style="color:#61AFEF;">setTimeout</span><span style="color:#ABB2BF;">(</span><span style="color:#C678DD;">function</span><span style="color:#ABB2BF;"> () {</span><span style="color:#E5C07B;">console</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">log</span><span style="color:#ABB2BF;">(</span><span style="color:#98C379;">&#39;setTimeout()&#39;</span><span style="color:#ABB2BF;">);</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">// Node的process.nextTick</span></span>
<span class="line"><span style="color:#E5C07B;">process</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">nextTick</span><span style="color:#ABB2BF;">(</span><span style="color:#C678DD;">function</span><span style="color:#ABB2BF;"> () {</span><span style="color:#E5C07B;">console</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">log</span><span style="color:#ABB2BF;">(</span><span style="color:#98C379;">&#39;process.nextTick()&#39;</span><span style="color:#ABB2BF;">);</span></span>
<span class="line"><span style="color:#ABB2BF;">                      </span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">/*</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">* 不管上面方法如何排序都是按这个顺序执行：</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">* 1.process.nextTick()</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">* 2.setTimeout()</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">* 3.setImmediate()</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">*/</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>nodejs的事件轮询机制：借助libuv库实现的：<a href="https://github.com/libuv/libuv" target="_blank" rel="noreferrer">libuv/libuv: Cross-platform asynchronous I/O (github.com)</a></p><p><strong>概括事件轮询机制</strong>，分为 6个阶段:</p><p>1.timers定时器阶段</p><p>计时和执行到点的定时器回调函数</p><p>2.pending callbacks</p><p>某些系统操作(例如TCP错误类型)的回调函数</p><p>3.idle，prepare</p><p>准备工作</p><p>4.poll 轮询阶段 (轮询队列)</p><p><strong>如果轮询队列不为空</strong>，依次同步取出轮询队列中第一个回调函数执行，直到轮询队列为空或者达到系统最大的限制</p><p><strong>如果轮询队列为空，则会进入以下流程</strong>：</p><ul><li>如果之前设置过setImmediate函数 <ul><li>直接进入下一个check阶段</li></ul></li><li>如果之前没有设置过setImmediate函数</li><li>在当前poll阶段等待 <ul><li>直到轮询队列添加回调函数，就去第一个情况执行</li><li>如何定时器到点了，也会去下一阶段</li></ul></li></ul><p>5.check 查阶段</p><p>执行setImmediate设置的回调函数</p><p>6.close callbacks 关闭阶段</p><p>执行close事件回调函数</p><p><strong><code>process.nextTick()</code> 会在任意阶段优先执行</strong></p><h2 id="同步和异步" tabindex="-1">同步和异步 <a class="header-anchor" href="#同步和异步" aria-label="Permalink to &quot;同步和异步&quot;">​</a></h2>`,29)]))}const u=n(e,[["render",o]]);export{b as __pageData,u as default};
