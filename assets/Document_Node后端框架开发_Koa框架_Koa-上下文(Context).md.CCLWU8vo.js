import{_ as s,c as t,o as a,ah as o}from"./chunks/framework.DqD713j2.js";const B=JSON.parse('{"title":"Koa-上下文(Context)","description":"","frontmatter":{},"headers":[],"relativePath":"Document/Node后端框架开发/Koa框架/Koa-上下文(Context).md","filePath":"Document/Node后端框架开发/Koa框架/Koa-上下文(Context).md","lastUpdated":1750954157000}'),n={name:"Document/Node后端框架开发/Koa框架/Koa-上下文(Context).md"};function l(r,e,c,p,d,i){return a(),t("div",null,e[0]||(e[0]=[o(`<h1 id="koa-上下文-context" tabindex="-1">Koa-上下文(Context) <a class="header-anchor" href="#koa-上下文-context" aria-label="Permalink to &quot;Koa-上下文(Context)&quot;">​</a></h1><p>Koa Context 将 node 的 <code>request</code> 和 <code>response</code> 对象封装到单个对象中，为编写 Web 应用程序和 API 提供了许多有用的方法。</p><p>这些操作在 HTTP 服务器开发中频繁使用，它们被添加到此级别而不是更高级别的框架，这将强制中间件重新实现此通用功能。</p><p><em>每个</em> 请求都将创建一个 <code>Context</code>，并在中间件中作为接收器引用，或者 <code>ctx</code> 标识符，如以下代码片段所示：</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#E5C07B;">app</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">use</span><span style="color:#ABB2BF;">(</span><span style="color:#C678DD;">async</span><span style="color:#E06C75;font-style:italic;"> ctx</span><span style="color:#C678DD;"> =&gt;</span><span style="color:#ABB2BF;"> {</span></span>
<span class="line"><span style="color:#E06C75;">  ctx</span><span style="color:#ABB2BF;">; </span><span style="color:#7F848E;font-style:italic;">// 这是 Context</span></span>
<span class="line"><span style="color:#E5C07B;">  ctx</span><span style="color:#ABB2BF;">.</span><span style="color:#E06C75;">request</span><span style="color:#ABB2BF;">; </span><span style="color:#7F848E;font-style:italic;">// 这是 koa Request</span></span>
<span class="line"><span style="color:#E5C07B;">  ctx</span><span style="color:#ABB2BF;">.</span><span style="color:#E06C75;">response</span><span style="color:#ABB2BF;">; </span><span style="color:#7F848E;font-style:italic;">// 这是 koa Response</span></span>
<span class="line"><span style="color:#ABB2BF;">});</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>为方便起见许多上下文的访问器和方法直接委托给它们的 <code>ctx.request</code>或 <code>ctx.response</code> ，不然的话它们是相同的。 例如 <code>ctx.type</code> 和 <code>ctx.length</code> 委托给 <code>response</code> 对象，<code>ctx.path</code> 和 <code>ctx.method</code> 委托给 <code>request</code>。</p><h2 id="api" tabindex="-1">API <a class="header-anchor" href="#api" aria-label="Permalink to &quot;API&quot;">​</a></h2><p><code>Context</code> 具体方法和访问器.</p><h3 id="ctx-req-node-的-request-对象" tabindex="-1">ctx.req - Node 的 <code>request</code> 对象 <a class="header-anchor" href="#ctx-req-node-的-request-对象" aria-label="Permalink to &quot;ctx.req - Node 的 \`request\` 对象&quot;">​</a></h3><p>Node的API文档：<a href="https://nodejs.org/api/http.html#class-httpincomingmessage" target="_blank" rel="noreferrer">HTTP | Node.js v19.2.0 Documentation (nodejs.org)</a></p><p>Node的requset对象类型&lt;http.IncomingMessage&gt;，继承stream.Readable类</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#E5C07B;">req</span><span style="color:#ABB2BF;">.</span><span style="color:#E06C75;">headers</span></span>
<span class="line"><span style="color:#E5C07B;">req</span><span style="color:#ABB2BF;">.</span><span style="color:#E06C75;">rawHeaders</span></span>
<span class="line"><span style="color:#E5C07B;">req</span><span style="color:#ABB2BF;">.</span><span style="color:#E06C75;">reusedSocket</span></span>
<span class="line"><span style="color:#E5C07B;">req</span><span style="color:#ABB2BF;">.</span><span style="color:#E06C75;">httpVersion</span></span>
<span class="line"><span style="color:#E5C07B;">req</span><span style="color:#ABB2BF;">.</span><span style="color:#E06C75;">method</span></span>
<span class="line"><span style="color:#E5C07B;">req</span><span style="color:#ABB2BF;">.</span><span style="color:#E06C75;">url</span></span>
<span class="line"><span style="color:#E5C07B;">req</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">end</span><span style="color:#ABB2BF;">()</span></span>
<span class="line"><span style="color:#E5C07B;">req</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">on</span><span style="color:#ABB2BF;">()</span></span>
<span class="line"><span style="color:#E5C07B;">req</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">once</span><span style="color:#ABB2BF;">()</span></span>
<span class="line"><span style="color:#E5C07B;">req</span><span style="color:#ABB2BF;">.</span><span style="color:#E06C75;">socket</span></span>
<span class="line"><span style="color:#E5C07B;">req</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">write</span><span style="color:#ABB2BF;">()</span></span>
<span class="line"><span style="color:#E5C07B;">req</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">destroy</span><span style="color:#ABB2BF;">()</span></span>
<span class="line"><span style="color:#E5C07B;">req</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">abort</span><span style="color:#ABB2BF;">()</span></span>
<span class="line"><span style="color:#ABB2BF;">...</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><h3 id="ctx-res-node-的-response-对象" tabindex="-1">ctx.res - Node 的 <code>response</code> 对象 <a class="header-anchor" href="#ctx-res-node-的-response-对象" aria-label="Permalink to &quot;ctx.res - Node 的 \`response\` 对象&quot;">​</a></h3><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#E5C07B;">res</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">setHeader</span><span style="color:#ABB2BF;">()</span></span>
<span class="line"><span style="color:#E5C07B;">res</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">writeHead</span><span style="color:#ABB2BF;">()</span></span>
<span class="line"><span style="color:#E5C07B;">res</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">end</span><span style="color:#ABB2BF;">()</span></span>
<span class="line"><span style="color:#E5C07B;">res</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">wtire</span><span style="color:#ABB2BF;">()</span></span>
<span class="line"><span style="color:#E5C07B;">res</span><span style="color:#ABB2BF;">.</span><span style="color:#E06C75;">statusCode</span></span>
<span class="line"><span style="color:#E5C07B;">res</span><span style="color:#ABB2BF;">.</span><span style="color:#E06C75;">statusMessage</span></span>
<span class="line"><span style="color:#E5C07B;">res</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">on</span><span style="color:#ABB2BF;">()</span></span>
<span class="line"><span style="color:#E5C07B;">res</span><span style="color:#ABB2BF;">.</span><span style="color:#E06C75;">socket</span></span>
<span class="line"><span style="color:#E5C07B;">res</span><span style="color:#ABB2BF;">.</span><span style="color:#E06C75;">complete</span></span>
<span class="line"><span style="color:#ABB2BF;">...</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>绕过 Koa 的 response 处理是 <strong>不被支持的</strong>. 应避免使用以下 node 属性：</p><ul><li><code>res.statusCode</code></li><li><code>res.writeHead()</code></li><li><code>res.write()</code></li><li><code>res.end()</code></li></ul><h2 id="ctx-request-koa-的-request-对象" tabindex="-1">ctx.request - koa 的 <code>Request</code> 对象 <a class="header-anchor" href="#ctx-request-koa-的-request-对象" aria-label="Permalink to &quot;ctx.request - koa 的 \`Request\` 对象&quot;">​</a></h2><p>koa 的 <code>Request</code> 对象，详情查看： <strong>Koa-请求(Request)</strong> 文档</p><h2 id="ctx-response-koa-的-response-对象" tabindex="-1">ctx.response - koa 的 <code>Response</code> 对象 <a class="header-anchor" href="#ctx-response-koa-的-response-对象" aria-label="Permalink to &quot;ctx.response - koa 的 \`Response\` 对象&quot;">​</a></h2><p>koa 的 <code>Response</code> 对象，详情查看： <strong>Koa-响应(Response)</strong> 文档</p><h3 id="ctx-state-用户数据存储空间" tabindex="-1">ctx.state - 用户数据存储空间 <a class="header-anchor" href="#ctx-state-用户数据存储空间" aria-label="Permalink to &quot;ctx.state - 用户数据存储空间&quot;">​</a></h3><p>推荐的命名空间（用户数据存储空间），用于通过中间件传递信息和你的前端视图。</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#E5C07B;">ctx</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">state</span><span style="color:#ABB2BF;">.</span><span style="color:#E06C75;">user</span><span style="color:#56B6C2;"> =</span><span style="color:#C678DD;"> await</span><span style="color:#E5C07B;"> User</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">find</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;">id</span><span style="color:#ABB2BF;">);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>下一个中间件内使用</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#E5C07B;">console</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">log</span><span style="color:#ABB2BF;">(</span><span style="color:#E5C07B;">ctx</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">state</span><span style="color:#ABB2BF;">.</span><span style="color:#E06C75;">user</span><span style="color:#ABB2BF;">)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><h3 id="ctx-app-application-对象" tabindex="-1">ctx.app - Application 对象 <a class="header-anchor" href="#ctx-app-application-对象" aria-label="Permalink to &quot;ctx.app - Application 对象&quot;">​</a></h3><p>应用程序实例引用，Application 对象（const app = new Koa()实例化对象）</p><h3 id="ctx-app-emit-定义一个类型由第一个参数定义的事件" tabindex="-1">ctx.app.emit - 定义一个类型由第一个参数定义的事件 <a class="header-anchor" href="#ctx-app-emit-定义一个类型由第一个参数定义的事件" aria-label="Permalink to &quot;ctx.app.emit - 定义一个类型由第一个参数定义的事件&quot;">​</a></h3><p>Koa 应用扩展了内部 <a href="https://nodejs.org/dist/latest-v11.x/docs/api/events.html" target="_blank" rel="noreferrer">EventEmitter</a>。<code>ctx.app.emit</code> 发出一个类型由第一个参数定义的事件。对于每个事件，您可以连接 &quot;listeners&quot;，这是在发出事件时调用的函数。有关更多信息，请参阅<a href="https://koajs.com/#error-handling" target="_blank" rel="noreferrer">错误处理文档</a>。</p><h3 id="ctx-cookies-get-name-options-获取cookies" tabindex="-1">ctx.cookies.get(name, [options]) - 获取cookies <a class="header-anchor" href="#ctx-cookies-get-name-options-获取cookies" aria-label="Permalink to &quot;ctx.cookies.get(name, [options]) - 获取cookies&quot;">​</a></h3><p>通过 <code>options</code> 获取 cookie <code>name</code>:</p><ul><li><code>signed</code> 所请求的cookie应该被签名</li></ul><p>koa 使用 <a href="https://github.com/pillarjs/cookies" target="_blank" rel="noreferrer">cookies</a> 模块，其中只需传递参数。</p><h3 id="ctx-cookies-set-name-value-options-设置cookies" tabindex="-1">ctx.cookies.set(name, value, [options]) - 设置cookies <a class="header-anchor" href="#ctx-cookies-set-name-value-options-设置cookies" aria-label="Permalink to &quot;ctx.cookies.set(name, value, [options]) - 设置cookies&quot;">​</a></h3><p>通过 <code>options</code> 设置 cookie <code>name</code> 的 <code>value</code> :</p><ul><li><code>maxAge</code>: 一个数字, 表示从 <code>Date.now()</code> 得到的毫秒数. <ul><li><code>expires</code>: 一个 <code>Date</code> 对象, 表示 cookie 的到期日期 (默认情况下在会话结束时过期).</li><li><code>path</code>：一个字符串, 表示 cookie 的路径 (默认是<code>/</code>).</li><li><code>domain</code>：一个字符串, 指示 cookie 的域 (无默认值).</li><li><code>secure</code>：一个布尔值, 表示 cookie 是否仅通过 HTTPS 发送 (HTTP 下默认为 <code>false</code>, HTTPS 下默认为 <code>true</code>). <a href="https://github.com/pillarjs/cookies#secure-cookies" target="_blank" rel="noreferrer">阅读有关此参数的更多信息</a>.</li><li><code>httpOnly</code>：一个布尔值, 表示 cookie 是否仅通过 HTTP(S) 发送，, 且不提供给客户端 JavaScript (默认为 <code>true</code>).</li><li><code>sameSite</code>：一个布尔值或字符串, 表示该 cookie 是否为 &quot;相同站点&quot; cookie (默认为 <code>false</code>). 可以设置为 <code>&#39;strict&#39;</code>, <code>&#39;lax&#39;</code>, <code>&#39;none&#39;</code>, 或 <code>true</code> (映射为 <code>&#39;strict&#39;</code>).</li><li><code>signed</code>：一个布尔值, 表示是否要对 cookie 进行签名 (默认为 <code>false</code>). 如果为 <code>true</code>, 则还会发送另一个后缀为 <code>.sig</code> 的同名 cookie, 使用一个 27-byte url-safe base64 SHA1 值来表示针对第一个 <a href="https://www.npmjs.com/package/keygrip" target="_blank" rel="noreferrer">Keygrip</a> 键的 <code>cookie-name=cookie-value</code> 的哈希值. 此签名密钥用于检测下次接收 cookie 时的篡改.</li><li><code>overwrite</code>：一个布尔值, 表示是否覆盖以前设置的同名的 cookie (默认是 <code>false</code>). 如果是 true, 在同一个请求中设置相同名称的所有 Cookie（无论路径或域）是否在设置此Cookie 时从 Set-Cookie 消息头中过滤掉.</li></ul></li></ul><p>koa 使用传递简单参数的 <a href="https://github.com/pillarjs/cookies" target="_blank" rel="noreferrer">cookies</a> 模块。</p><h3 id="ctx-throw-status-msg-properties-抛出错误" tabindex="-1">ctx.throw([status], [msg], [properties]) - 抛出错误 <a class="header-anchor" href="#ctx-throw-status-msg-properties-抛出错误" aria-label="Permalink to &quot;ctx.throw([status], [msg], [properties]) - 抛出错误&quot;">​</a></h3><p>用来抛出一个包含 <code>.status</code> 属性错误的帮助方法，其默认值为 <code>500</code>。这样 Koa 就可以做出适当地响应。</p><p>允许以下组合：</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#E5C07B;">ctx</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">throw</span><span style="color:#ABB2BF;">(</span><span style="color:#D19A66;">400</span><span style="color:#ABB2BF;">);</span></span>
<span class="line"><span style="color:#E5C07B;">ctx</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">throw</span><span style="color:#ABB2BF;">(</span><span style="color:#D19A66;">400</span><span style="color:#ABB2BF;">, </span><span style="color:#98C379;">&#39;name required&#39;</span><span style="color:#ABB2BF;">);</span></span>
<span class="line"><span style="color:#E5C07B;">ctx</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">throw</span><span style="color:#ABB2BF;">(</span><span style="color:#D19A66;">400</span><span style="color:#ABB2BF;">, </span><span style="color:#98C379;">&#39;name required&#39;</span><span style="color:#ABB2BF;">, { </span><span style="color:#E06C75;">user</span><span style="color:#ABB2BF;">: </span><span style="color:#E06C75;">user</span><span style="color:#ABB2BF;"> });</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>例如 <code>ctx.throw(400, &#39;name required&#39;)</code> 等效于:</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#C678DD;">const</span><span style="color:#E5C07B;"> err</span><span style="color:#56B6C2;"> =</span><span style="color:#C678DD;"> new</span><span style="color:#61AFEF;"> Error</span><span style="color:#ABB2BF;">(</span><span style="color:#98C379;">&#39;name required&#39;</span><span style="color:#ABB2BF;">);</span></span>
<span class="line"><span style="color:#E5C07B;">err</span><span style="color:#ABB2BF;">.</span><span style="color:#E06C75;">status</span><span style="color:#56B6C2;"> =</span><span style="color:#D19A66;"> 400</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#E5C07B;">err</span><span style="color:#ABB2BF;">.</span><span style="color:#E06C75;">expose</span><span style="color:#56B6C2;"> =</span><span style="color:#D19A66;"> true</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#C678DD;">throw</span><span style="color:#E06C75;"> err</span><span style="color:#ABB2BF;">;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>请注意，这些是用户级错误，并用 <code>err.expose</code> 标记，这意味着消息适用于客户端响应，这通常不是错误消息的内容，因为您不想泄漏故障详细信息。</p><p>你可以根据需要将 <code>properties</code> 对象传递到错误中，对于装载上传给请求者的机器友好的错误是有用的。这用于修饰其人机友好型错误并向上游的请求者报告非常有用。</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#E5C07B;">ctx</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">throw</span><span style="color:#ABB2BF;">(</span><span style="color:#D19A66;">401</span><span style="color:#ABB2BF;">, </span><span style="color:#98C379;">&#39;access_denied&#39;</span><span style="color:#ABB2BF;">, { </span><span style="color:#E06C75;">user</span><span style="color:#ABB2BF;">: </span><span style="color:#E06C75;">user</span><span style="color:#ABB2BF;"> });</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>koa 使用 <a href="https://github.com/jshttp/http-errors" target="_blank" rel="noreferrer">http-errors</a> 来创建错误。<code>status</code> 只应作为第一个参数传递。</p><h3 id="ctx-assert-value-status-msg-properties-错误的帮助方法" tabindex="-1">ctx.assert(value, [status], [msg], [properties]) - 错误的帮助方法 <a class="header-anchor" href="#ctx-assert-value-status-msg-properties-错误的帮助方法" aria-label="Permalink to &quot;ctx.assert(value, [status], [msg], [properties]) - 错误的帮助方法&quot;">​</a></h3><p>当 <code>!value</code> 时抛出一个类似 <code>.throw</code> 错误的帮助方法。这与 node 的 <a href="http://nodejs.org/api/assert.html" target="_blank" rel="noreferrer">assert()</a> 方法类似.</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#E5C07B;">ctx</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">assert</span><span style="color:#ABB2BF;">(</span><span style="color:#E5C07B;">ctx</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">state</span><span style="color:#ABB2BF;">.</span><span style="color:#E06C75;">user</span><span style="color:#ABB2BF;">, </span><span style="color:#D19A66;">401</span><span style="color:#ABB2BF;">, </span><span style="color:#98C379;">&#39;User not found. Please login!&#39;</span><span style="color:#ABB2BF;">);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>koa 使用 <a href="https://github.com/jshttp/http-assert" target="_blank" rel="noreferrer">http-assert</a> 作为断言。</p><h3 id="ctx-respond-写入原始的-res-对象-不支持使用" tabindex="-1">ctx.respond - 写入原始的 <code>res</code> 对象（不支持使用） <a class="header-anchor" href="#ctx-respond-写入原始的-res-对象-不支持使用" aria-label="Permalink to &quot;ctx.respond - 写入原始的 \`res\` 对象（不支持使用）&quot;">​</a></h3><p>为了绕过 Koa 的内置 response 处理，你可以显式设置 <code>ctx.respond = false;</code>。 如果您想要写入原始的 <code>res</code> 对象而不是让 Koa 处理你的 response，请使用此参数。</p><p>请注意，Koa <em>不</em> 支持使用此功能。这可能会破坏 Koa 中间件和 Koa 本身的预期功能。使用这个属性被认为是一个 hack，只是便于那些希望在 Koa 中使用传统的 <code>fn(req, res)</code> 功能和中间件的人。</p><h2 id="请求-request-别名-以下映射到ctx-request里面" tabindex="-1">请求 Request 别名 - 以下映射到ctx.request里面 <a class="header-anchor" href="#请求-request-别名-以下映射到ctx-request里面" aria-label="Permalink to &quot;请求 Request 别名 - 以下映射到ctx.request里面&quot;">​</a></h2><p>以下访问器和 <code>koa-请求(Request)</code> 文档的别名等效：</p><table tabindex="0"><thead><tr><th style="text-align:left;">Request API</th><th style="text-align:left;">作用</th></tr></thead><tbody><tr><td style="text-align:left;">ctx.header</td><td style="text-align:left;">获取请求头对象信息。这与 node <a href="https://nodejs.org/api/http.html#http_class_http_incomingmessage" target="_blank" rel="noreferrer"><code>http.IncomingMessage</code></a> 上的 <a href="https://nodejs.org/api/http.html#http_message_headers" target="_blank" rel="noreferrer"><code>headers</code></a> 字段相同</td></tr><tr><td style="text-align:left;">ctx.header=</td><td style="text-align:left;">设置请求头对象</td></tr><tr><td style="text-align:left;">ctx.headers</td><td style="text-align:left;">请求头对象。别名为 <code>request.header</code></td></tr><tr><td style="text-align:left;">ctx.headers=</td><td style="text-align:left;">设置请求头对象。别名为 <code>request.header=</code></td></tr><tr><td style="text-align:left;">ctx.method</td><td style="text-align:left;">请求方法（GET POST）</td></tr><tr><td style="text-align:left;">ctx.method=</td><td style="text-align:left;">设置请求方法，对于实现诸如 <code>methodOverride()</code> 的中间件是有用的</td></tr><tr><td style="text-align:left;">ctx.url</td><td style="text-align:left;">获取请求 URL</td></tr><tr><td style="text-align:left;">ctx.url=</td><td style="text-align:left;">设置请求 URL, 对 url 重写有用</td></tr><tr><td style="text-align:left;">ctx.originalUrl</td><td style="text-align:left;">获取请求原始URL</td></tr><tr><td style="text-align:left;">ctx.origin</td><td style="text-align:left;">获取URL的来源，包括 <code>protocol</code> 和 <code>host</code><br><code>ctx.origin</code></td></tr><tr><td style="text-align:left;">ctx.href</td><td style="text-align:left;">获取完整的请求URL，包括 <code>protocol</code>，<code>host</code> 和 <code>url</code></td></tr><tr><td style="text-align:left;">ctx.path</td><td style="text-align:left;">获取请求路径名</td></tr><tr><td style="text-align:left;">ctx.path=</td><td style="text-align:left;">设置请求路径名，并在存在时保留查询字符串</td></tr><tr><td style="text-align:left;">ctx.query</td><td style="text-align:left;">获取解析的查询字符串, 当没有查询字符串时，返回一个空对象。请注意，此 getter <em>不</em> 支持嵌套解析<br>获取查询字符串，获取GET请求 ? 后的参数，如：localhost:9000/users?name=&#39;aaa&#39;</td></tr><tr><td style="text-align:left;">ctx.query=</td><td style="text-align:left;">将查询字符串设置为给定对象。 请注意，此 setter <em>不</em> 支持嵌套对象</td></tr><tr><td style="text-align:left;">ctx.querystring</td><td style="text-align:left;">根据 <code>?</code> 获取原始查询字符串</td></tr><tr><td style="text-align:left;">ctx.querystring=</td><td style="text-align:left;">设置原始查询字符串</td></tr><tr><td style="text-align:left;">ctx.params.id</td><td style="text-align:left;">获取GET请求路由(/user/:id)参数， 如：localhost:9000/user/1</td></tr><tr><td style="text-align:left;">ctx.host</td><td style="text-align:left;">存在时获取主机（hostname:port）。当 <code>app.proxy</code> 是 <strong>true</strong> 时支持 <code>X-Forwarded-Host</code>，否则使用 <code>Host</code></td></tr><tr><td style="text-align:left;">ctx.hostname</td><td style="text-align:left;">存在时获取主机名。当 <code>app.proxy</code> 是 <strong>true</strong> 时支持 <code>X-Forwarded-Host</code>，否则使用 <code>Host</code>。<br><br>如果主机是 IPv6, Koa 解析到 <a href="https://nodejs.org/dist/latest-v8.x/docs/api/url.html#url_the_whatwg_url_api" target="_blank" rel="noreferrer">WHATWG URL API</a>, <em>注意</em> 这可能会影响性能。</td></tr><tr><td style="text-align:left;">ctx.fresh</td><td style="text-align:left;">检查请求缓存是否“新鲜”，也就是内容没有改变。此方法用于 <code>If-None-Match</code> / <code>ETag</code>, 和 <code>If-Modified-Since</code> 和 <code>Last-Modified</code> 之间的缓存协商。 在设置一个或多个这些响应头后应该引用它。<br>使用方法查看文档：<code>koa-请求(Request)</code></td></tr><tr><td style="text-align:left;">ctx.stale</td><td style="text-align:left;">与 <code>ctx.fresh</code> 相反</td></tr><tr><td style="text-align:left;">ctx.socket</td><td style="text-align:left;">返回请求套接字</td></tr><tr><td style="text-align:left;">ctx.protocol</td><td style="text-align:left;">返回请求协议，“https” 或 “http”。当 <code>app.proxy</code>是 <strong>true</strong> 时支持 <code>X-Forwarded-Proto</code></td></tr><tr><td style="text-align:left;">ctx.secure</td><td style="text-align:left;">通过 <code>ctx.protocol == &quot;https&quot;</code> 来检查请求是否通过 TLS 发出</td></tr><tr><td style="text-align:left;">ctx.ip</td><td style="text-align:left;">请求远程地址。 当 <code>app.proxy</code> 是 <strong>true</strong> 时支持 <code>X-Forwarded-Proto</code></td></tr><tr><td style="text-align:left;">ctx.ips</td><td style="text-align:left;">当 <code>X-Forwarded-For</code> 存在并且 <code>app.proxy</code> 被启用时，这些 ips 的数组被返回，从上游 - &gt;下游排序。 禁用时返回一个空数组<br>具体查看文档：<code>koa-请求(Request)</code></td></tr><tr><td style="text-align:left;">ctx.subdomains</td><td style="text-align:left;">以数组形式返回子域<br>具体查看文档：<code>koa-请求(Request)</code></td></tr><tr><td style="text-align:left;">ctx.is()</td><td style="text-align:left;">检查传入请求是否包含 <code>Content-Type</code> 消息头字段， 并且包含任意的 mime <code>type</code>。 如果没有请求主体，返回 <code>null</code>。 如果没有内容类型，或者匹配失败，则返回 <code>false</code>。 反之则返回匹配的 content-type<br>使用方法查看文档：<code>koa-请求(Request)</code></td></tr><tr><td style="text-align:left;">ctx.accepts(types)</td><td style="text-align:left;">检查给定的 <code>type(s)</code> 是否可以接受，如果 <code>true</code>，返回最佳匹配，否则为 <code>false</code>。 <code>type</code> 值可能是一个或多个 mime 类型的字符串，如 <code>application/json</code>，扩展名称如 <code>json</code>，或数组 <code>[&quot;json&quot;, &quot;html&quot;, &quot;text/plain&quot;]</code><br>使用方法查看文档：<code>koa-请求(Request)</code></td></tr><tr><td style="text-align:left;">ctx.acceptsEncodings(encodings)</td><td style="text-align:left;">检查 <code>encodings</code> 是否可以接受，返回最佳匹配为 <code>true</code>，否则为 <code>false</code>。 请注意，您应该将<code>identity</code> 作为编码之一<br>使用方法查看文档：<code>koa-请求(Request)</code></td></tr><tr><td style="text-align:left;">ctx.acceptsCharsets(charsets)</td><td style="text-align:left;">检查 <code>charsets</code> 是否可以接受，在 <code>true</code> 时返回最佳匹配，否则为 <code>false</code><br>使用方法查看文档：<code>koa-请求(Request)</code></td></tr><tr><td style="text-align:left;">ctx.acceptsLanguages(langs)</td><td style="text-align:left;">检查 <code>langs</code> 是否可以接受，如果为 <code>true</code>，返回最佳匹配，否则为 <code>false</code><br>使用方法查看文档：<code>koa-请求(Request)</code></td></tr><tr><td style="text-align:left;">ctx.get()</td><td style="text-align:left;">返回请求头(header), <code>field</code> 不区分大小写</td></tr></tbody></table><h2 id="响应-response-别名-以下映射到ctx-response里面" tabindex="-1">响应 Response 别名 - 以下映射到ctx.response里面 <a class="header-anchor" href="#响应-response-别名-以下映射到ctx-response里面" aria-label="Permalink to &quot;响应 Response 别名 - 以下映射到ctx.response里面&quot;">​</a></h2><p>以下访问器和 <code>koa-响应(Response)</code> 文档的别名等效：</p><table tabindex="0"><thead><tr><th>Response API</th><th>作用</th></tr></thead><tbody><tr><td>ctx.body</td><td>获取响应主体，POST 提交的参数 (需要中间件：koa-bodyparser）</td></tr><tr><td>ctx.body=</td><td>将响应体设置为-详情看使用方法文档<br>使用方法文档：<code>koa-响应(Response)</code></td></tr><tr><td>ctx.status</td><td>获取响应状态。默认情况下，<code>response.status</code> 设置为 <code>404</code> 而不是像 node 的 <code>res.statusCode</code> 那样默认为 <code>200</code></td></tr><tr><td>ctx.status=</td><td>通过数字代码设置响应状态，具体数字含义请看文档：<code>koa-响应(Response)</code></td></tr><tr><td>ctx.message</td><td>获取响应的状态消息. 默认情况下, <code>response.message</code> 与 <code>response.status</code> 关联</td></tr><tr><td>ctx.message=</td><td>将响应的状态消息设置为给定值</td></tr><tr><td>ctx.length=</td><td>将响应的 Content-Length 设置为给定值</td></tr><tr><td>ctx.length</td><td>以数字返回响应的 Content-Length，或者从<code>ctx.body</code>推导出来，或者<code>undefined</code></td></tr><tr><td>ctx.type=</td><td>设置响应 <code>Content-Type</code> 通过 mime 字符串或文件扩展名<br>使用方法文档：<code>koa-响应(Response)</code></td></tr><tr><td>ctx.type</td><td>获取响应 <code>Content-Type</code>, 不含 &quot;charset&quot; 等参数</td></tr><tr><td>ctx.headerSent</td><td>检查是否已经发送了一个响应头。 用于查看客户端是否可能会收到错误通知</td></tr><tr><td><strong>ctx.redirect()</strong></td><td>执行 [302] 重定向到 <code>url</code><br>使用方法文档：<code>koa-响应(Response)</code></td></tr><tr><td>ctx.attachment()</td><td>将 <code>Content-Disposition</code> 设置为 “附件” 以指示客户端提示下载。(可选)指定下载的 <code>filename</code> 和部分 <a href="https://github.com/jshttp/content-disposition#options" target="_blank" rel="noreferrer">参数</a></td></tr><tr><td>ctx.set()</td><td>用一个对象设置多个响应头<code>fields</code>:<br><code>ctx.set({&#39;Etag&#39;: &#39;1234&#39;, &#39;Last-Modified&#39;: date});</code></td></tr><tr><td>ctx.append()</td><td>用值 <code>val</code> 附加额外的消息头 <code>field</code>。<br><code>ctx.append(&#39;Link&#39;, &#39;&lt;http://127.0.0.1/&gt;&#39;);</code></td></tr><tr><td>ctx.remove()</td><td>删除消息头 <code>field</code></td></tr><tr><td>ctx.lastModified=</td><td>将 <code>Last-Modified</code> 消息头设置为适当的 UTC 字符串。您可以将其设置为 <code>Date</code> 或日期字符串。<br><code>&lt;br/&gt;ctx.response.lastModified = new Date();&lt;br/&gt;</code></td></tr><tr><td>ctx.etag=</td><td>设置包含 <code>&quot;</code> 包裹的 ETag 响应， 请注意，没有相应的 <code>response.etag</code> getter<br><code>ctx.response.etag = crypto.createHash(&#39;md5&#39;).update(ctx.body).digest(&#39;hex&#39;);</code></td></tr></tbody></table>`,60)]))}const u=s(n,[["render",l]]);export{B as __pageData,u as default};
