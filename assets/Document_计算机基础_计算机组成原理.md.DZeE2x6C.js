import{_ as e,c as s,o,ah as c}from"./chunks/framework.DqD713j2.js";const n="/FrontEndLearnNotes/assets/1706b694c2b484bdtplv-t2oaga2asx-jj-mark3024000q75.QlxAaYFu.png",p="/FrontEndLearnNotes/assets/1706b6d32a002249tplv-t2oaga2asx-jj-mark3024000q75.Cz0b5hjO.png",d="/FrontEndLearnNotes/assets/1706b702defc6fe1tplv-t2oaga2asx-jj-mark3024000q75.B7Al7Xkv.png",l="/FrontEndLearnNotes/assets/1706bff6d4271172tplv-t2oaga2asx-jj-mark3024000q75.D-5q9gsj.png",t="/FrontEndLearnNotes/assets/1706c01bf8cca0fbtplv-t2oaga2asx-jj-mark3024000q75.C5DtIM-g.png",r="/FrontEndLearnNotes/assets/1706c09a00c1bf76tplv-t2oaga2asx-jj-mark3024000q75.tRmKKLIz.png",i="/FrontEndLearnNotes/assets/1706c0c704b4d5e4tplv-t2oaga2asx-jj-mark3024000q75.B8eZ3R10.png",m="/FrontEndLearnNotes/assets/1706c1c88439428ctplv-t2oaga2asx-jj-mark3024000q75.D9USYpQy.png",b="/FrontEndLearnNotes/assets/1706c2497c78ea7ftplv-t2oaga2asx-jj-mark3024000q75.H7KSzJ09.png",u="/FrontEndLearnNotes/assets/1706c398612217b8tplv-t2oaga2asx-jj-mark3024000q75.qIH5zJt1.png",g="/FrontEndLearnNotes/assets/1706c4a705a0c799tplv-t2oaga2asx-jj-mark3024000q75.Cw4ewSEt.png",h="/FrontEndLearnNotes/assets/1706c9d470edc315tplv-t2oaga2asx-jj-mark3024000q75.E-XdJgdm.png",_="/FrontEndLearnNotes/assets/1706cbcf713a5daatplv-t2oaga2asx-jj-mark3024000q75.C-5QQzCh.png",B="/FrontEndLearnNotes/assets/1706cc3a1c2ac0b4tplv-t2oaga2asx-jj-mark3024000q75.Bf6CCF_2.png",q="/FrontEndLearnNotes/assets/1706d5e33596c8fetplv-t2oaga2asx-jj-mark3024000q75.B5DNtiWz.png",C="/FrontEndLearnNotes/assets/1706ff11252cf012tplv-t2oaga2asx-jj-mark3024000q75.B51f64Vp.png",j="/FrontEndLearnNotes/assets/1707000f2236ced5tplv-t2oaga2asx-jj-mark3024000q75.CLPy3WAN.png",k="/FrontEndLearnNotes/assets/170704847227a313tplv-t2oaga2asx-jj-mark3024000q75.Dd3LlUVU.png",x="/FrontEndLearnNotes/assets/170705cec4efdbbftplv-t2oaga2asx-jj-mark3024000q75.BQ6GDGkW.png",y="/FrontEndLearnNotes/assets/170705db54658733tplv-t2oaga2asx-jj-mark3024000q75.DYHANuNx.png",f="/FrontEndLearnNotes/assets/17070a5d364385eetplv-t2oaga2asx-jj-mark3024000q75.D6dCe3dy.png",A="/FrontEndLearnNotes/assets/17070ac01d4adfbetplv-t2oaga2asx-jj-mark3024000q75.C5Wm2iQn.png",v="/FrontEndLearnNotes/assets/170713830fa5eb8btplv-t2oaga2asx-jj-mark3024000q75.CtVxtFIk.png",F="/FrontEndLearnNotes/assets/17071e09c7aa0ec0tplv-t2oaga2asx-jj-mark3024000q75.COZPsuTP.png",P="/FrontEndLearnNotes/assets/17071f8af2c754fatplv-t2oaga2asx-jj-mark3024000q75.hn7hApDq.png",D="/FrontEndLearnNotes/assets/17071fac43ab80f6tplv-t2oaga2asx-jj-mark3024000q75.Cs9ODzSN.png",E="/FrontEndLearnNotes/assets/1707206ef2336a07tplv-t2oaga2asx-jj-mark3024000q75.D3Qqe2z0.png",N="/FrontEndLearnNotes/assets/17072561bbbaabd0tplv-t2oaga2asx-jj-mark3024000q75.DReYdYCa.png",I="/FrontEndLearnNotes/assets/1707263d5cdbcf4btplv-t2oaga2asx-jj-mark3024000q75.B8Bcgsb2.png",z=JSON.parse('{"title":"计算机组成原理","description":"","frontmatter":{},"headers":[],"relativePath":"Document/计算机基础/计算机组成原理.md","filePath":"Document/计算机基础/计算机组成原理.md","lastUpdated":1750954157000}'),L={name:"Document/计算机基础/计算机组成原理.md"};function O(R,a,U,M,S,T){return o(),s("div",null,a[0]||(a[0]=[c('<h1 id="计算机组成原理" tabindex="-1">计算机组成原理 <a class="header-anchor" href="#计算机组成原理" aria-label="Permalink to &quot;计算机组成原理&quot;">​</a></h1><p>前端开发人员中，有相当大比例的同学不是科班出来的，所以对于基本的科班<code>必修课</code>，例如：<code>计算机组成原理</code>、<code>操作系统</code>、<code>计算机网络</code>、<code>数据结构和算法</code>等知识接触不多。</p><p>当你越深入学习，越会发现这些知识的重要性。</p><p>比如大家都知道 js 里面<code>0.1 + 0.2</code> 是<code>不等于0.3</code>的，为什么呢？这就牵扯到计算机组成原理中<code>浮点数</code>的表示方法，以及<code>浮点数</code>的加减运算（正文会有白话版解答）。</p><p>又例如从键盘输入<code>a+b</code>这个指令，如何通过<code>cpu</code>的调度输出到<code>屏幕上</code>呢？这就涉及到<code>冯诺依曼体系</code>，如果你是编程人员，都不清楚数据从键盘到屏幕的<code>基本流向</code>，那是时候看看这篇&#39;十全大补文&#39;了</p><p>本文是一篇<code>计算机组成原理</code>最基本的入门文章，我觉得前端没有必要那么深入这个专题，掌握基本的<code>计算机组成原理</code>的常识即可。</p><h3 id="_1、计算机的工作原理" tabindex="-1">1、计算机的工作原理 <a class="header-anchor" href="#_1、计算机的工作原理" aria-label="Permalink to &quot;1、计算机的工作原理&quot;">​</a></h3><p>首先，计算机最基本的 5 大组成部分如下图，分别为：<code>输入设备</code>(比如键盘), <code>存储器</code>(比如内存), <code>运算器</code>(cpu), <code>控制器</code>(cpu), <code>输出设备</code>(显示器)。</p><p><img src="'+n+'" alt="img"></p><p>工作原理如下</p><h4 id="_1-1-控制器-控制输入设备-指令流向内存" tabindex="-1">1.1 控制器 ---&gt; 控制输入设备 ----&gt; 指令流向内存 <a class="header-anchor" href="#_1-1-控制器-控制输入设备-指令流向内存" aria-label="Permalink to &quot;1.1 控制器 ---&gt; 控制输入设备 ----&gt; 指令流向内存&quot;">​</a></h4><p>当我们输入数据的时候，cpu 里的<code>控制器</code>会让<code>输入设备</code>把这些指令存储到<code>存储器</code>(内存)上。</p><p><img src="'+p+'" alt="img"></p><h4 id="_1-2-控制器分析指令-控制存储器-把数据送到运算器" tabindex="-1">1.2 控制器分析指令 ---&gt; 控制存储器 ---&gt; 把数据送到运算器 <a class="header-anchor" href="#_1-2-控制器分析指令-控制存储器-把数据送到运算器" aria-label="Permalink to &quot;1.2 控制器分析指令 ---&gt; 控制存储器 ---&gt; 把数据送到运算器&quot;">​</a></h4><p>控制器分析指令之后， 此时让<code>存储器</code>把数据发送到<code>运算器</code>里(<code>控制器</code>和<code>运算器</code>都在<code>cpu</code>里面)</p><p>这里需要注意，<code>存储器</code>既能<code>存储数据</code>，还能<code>存储指令</code></p><p><img src="'+d+'" alt="img"></p><h4 id="_1-3-控制器控制运算器做数据的运算-并且将运算结果返回存储器" tabindex="-1">1.3 控制器控制运算器做数据的运算 并且将运算结果返回存储器 <a class="header-anchor" href="#_1-3-控制器控制运算器做数据的运算-并且将运算结果返回存储器" aria-label="Permalink to &quot;1.3 控制器控制运算器做数据的运算 并且将运算结果返回存储器&quot;">​</a></h4><p><img src="'+l+'" alt="img"></p><h4 id="_1-4-控制器控制存储器将结果返回给输出设备" tabindex="-1">1.4 控制器控制存储器将结果返回给输出设备 <a class="header-anchor" href="#_1-4-控制器控制存储器将结果返回给输出设备" aria-label="Permalink to &quot;1.4 控制器控制存储器将结果返回给输出设备&quot;">​</a></h4><p><img src="'+t+'" alt="img"></p><p>从接下来，我们更近一步，看看计算机内部，CPU 是怎么跟存储器交互的。</p><h3 id="_2、cpu-及其工作过程" tabindex="-1">2、CPU 及其工作过程 <a class="header-anchor" href="#_2、cpu-及其工作过程" aria-label="Permalink to &quot;2、CPU 及其工作过程&quot;">​</a></h3><p>CPU 中比较重要的两个部件是<code>运算器</code>和<code>控制器</code>，我们先来看看运算器的主要作用</p><h4 id="_2-1-运算器主要部件" tabindex="-1">2.1 运算器主要部件 <a class="header-anchor" href="#_2-1-运算器主要部件" aria-label="Permalink to &quot;2.1 运算器主要部件&quot;">​</a></h4><p><img src="'+r+'" alt="img"></p><p>如上图，运算器里最重要的部件是<code>ALU</code>，中文叫<code>算术逻辑单元</code>，用来进行<code>算术</code>和<code>逻辑运算</code>的。其它的<code>MQ</code>,<code>ACC</code>这些我们不用管了，是一些<code>寄存器</code>。</p><h4 id="_2-2-控制器主要部件" tabindex="-1">2.2 控制器主要部件 <a class="header-anchor" href="#_2-2-控制器主要部件" aria-label="Permalink to &quot;2.2 控制器主要部件&quot;">​</a></h4><p><img src="'+i+'" alt="img"></p><p>控制器中最重要的部件是<code>CU</code>（控制单元），只要是<code>分析指令</code>，给出<code>控制信号</code>。</p><p><code>IR</code>（指令寄存器），存放当前需要执行的指令</p><p><code>PC</code>存放的指令的地址。</p><h4 id="_2-3-举例-取数指令执行过程" tabindex="-1">2.3 举例 - 取数指令执行过程 <a class="header-anchor" href="#_2-3-举例-取数指令执行过程" aria-label="Permalink to &quot;2.3 举例 - 取数指令执行过程&quot;">​</a></h4><p>首先，是取指令的过程如下</p><p><img src="'+m+'" alt="img"></p><ul><li>第一步，<code>PC</code>，也就是存放指令地址的地方，我们要知道下一条指令是什么，就必须去存储器拿，<code>CPU</code>才知道接下来做什么。<code>PC</code>去了存储器的<code>MAR</code>拿要执行的指令地址，<code>MAR</code>（存储器里专门存指令地址的地方）</li><li>第二步和第三步，<code>MAR</code>去存储体内拿到指令之后，将指令地址放入<code>MDR</code>(存储器里专门存数据的地方)</li><li>第四步<code>MDR</code>里的数据返回到<code>IR</code>里面，<code>IR</code>是存放指令的地方，我们把刚才从存储体里拿的指令放在这里</li></ul><p>然后，分析指令，执行指令的过程如下</p><p><img src="'+b+'" alt="img"></p><ul><li>第五步， <code>IR</code>将指令放入<code>CU</code>中，来分析指令，比如说分析出是一个取数指令，接着就要执行指令了（这里取数指令，其实就是一个地址码，按着这个地址去存储体取数据）</li><li>第六步，第七步 <code>IR</code>就会接着去找存储体里的<code>MAR</code>（存储地址的地方），<code>MAR</code>就根据取数指令里的地址吗去存储体里去数据</li><li>第八步，取出的数据返回给<code>MDR</code>（存放数据的地方）</li><li>第九步，<code>MDR</code>里的数据放到运算器的寄存器里，这里的取指令的过程结束了。</li></ul><p>来个插曲，我们知道数据在<code>内存</code>里是<code>二进制</code>存着，也就是<code>0和1</code>, <code>0和1</code>怎么用表示呢？</p><p>我们拿其中一种存储 0 和 1 的方式来说明</p><ul><li><p>电容是否有电荷，有电荷代表 1，无电荷代表 0</p></li><li><p>如下图</p><p><img src="'+u+'" alt="img"></p></li></ul><p><img src="'+g+'" alt="img"></p><h3 id="_3、计算机编程语言" tabindex="-1">3、计算机编程语言 <a class="header-anchor" href="#_3、计算机编程语言" aria-label="Permalink to &quot;3、计算机编程语言&quot;">​</a></h3><p>我们看看机器语言，怎么表示存放一个数的指令，例如下图</p><p><img src="'+h+'" alt="img"></p><p>我们来看二进制代码 <code>0000，0000，000000010000</code></p><ul><li>其中第一个<code>0000</code>，表示的是汇编语言里的<code>LOAD</code>，也就是加载，加载什么呢</li><li>加载地址<code>000000010000</code>上的数据到第二个<code>0000</code>（寄存器的位置）。</li></ul><p>接下来，我们看看如果是<code>汇编语言</code>怎么表示</p><p><img src="'+_+'" alt="img"></p><p><code>LOAD A, 16</code>意思是将存储体内的 16 号单元数据，放到寄存器地址 A 中 <code>ADD C, A, B</code>意思是将寄存器里的 A,B 数据相加，得到 C <code>STORE C, 17</code>意思是将寄存器里的数据存到存储体 17 号单元内</p><p>最后，我们看看怎么用<code>高级语言</code>表示</p><p><img src="'+B+'" alt="img"></p><p>高级语言是不是很简单，就一个<code>a+b</code>，你都不用去考虑<code>寄存器</code>，<code>存储体</code>这些事。</p><h4 id="这部分的总结" tabindex="-1">这部分的总结 <a class="header-anchor" href="#这部分的总结" aria-label="Permalink to &quot;这部分的总结&quot;">​</a></h4><p>高级语言一般有两种方式转换为机器语言</p><ul><li>一种是直接借助<code>编译器</code>，将高级语言转换为<code>二进制</code>代码，比如<code>c</code>，这样<code>c</code>运行起来就特别快，因为编译后是机器语言，直接就能在系统上跑，但问题是，编译的速度可能会比较慢。</li><li>一种是解释性的，比如 <code>js</code>，是将代码翻译一行成<code>机器语言</code>（中间可能会先翻译为<code>汇编</code>代码或者<code>字节码</code>），解释一行，执行一行</li></ul><p>需要注意的是，按照第一种将大量的高级代码翻译为机器语言，这其中就有很大的空间给<code>编译器</code>做代码优化，解释性语言就很难做这种优化，但是在<code>v8</code>引擎中，<code>js</code>还是要被优化的，在<code>编译阶段</code>（代码分<code>编译</code>和<code>执行</code>两个阶段）会对代码做一些优化，编译后立即执行的方式通常被称为 <code>JIT (Just In Time) Comipler</code>。</p><h3 id="_4、进制转换" tabindex="-1">4、进制转换 <a class="header-anchor" href="#_4、进制转换" aria-label="Permalink to &quot;4、进制转换&quot;">​</a></h3><p>接下来 4.3 这个小节会解释为什么 0.1 + 0.2 等于 0.3</p><h4 id="_4-1-二进制如何转化为十进制" tabindex="-1">4.1 二进制如何转化为十进制 <a class="header-anchor" href="#_4-1-二进制如何转化为十进制" aria-label="Permalink to &quot;4.1 二进制如何转化为十进制&quot;">​</a></h4><p>例如<code>2</code>进制<code>101.1</code>如何转化为<code>10</code>进制。（有些同学觉得可以用<code>parseInt(&#39;101.1&#39;, 2)</code>，这个是不行的，因为<code>parseInt</code>返回整数）</p><p>转化方法如下：</p><p><img src="'+q+'" alt="img"></p><p>上图的规则是什么呢？</p><p><code>二进制</code>的每个数去<code>乘以2</code>的相应次方,注意小数点后是乘以它的<code>负相应次方</code>。 再举一个例子你就明白了，</p><p>二进制<code>1101</code>转为十进制</p><p><img src="'+C+'" alt="img"></p><h4 id="_4-2-十进制整数转为二进制" tabindex="-1">4.2 十进制整数转为二进制 <a class="header-anchor" href="#_4-2-十进制整数转为二进制" aria-label="Permalink to &quot;4.2 十进制整数转为二进制&quot;">​</a></h4><p><code>JS</code>里面可以用<code>toString(2)</code>这个方法来转换。如果要用通用的方法，例如：将十进制数<code>（29）</code>转换成二进制数， 算法如下：</p><ul><li>把给定的十进制数 29 除以 2，商为 14，所得的余数 1 是二进制数的最低位的数码</li><li>再将 14 除以 2，商为 7，余数为 0</li><li>再将 7 除以 2，商为 3，余数为 1，再将 3 除以 2，商为 1，余数为 1</li><li>再将 1 除以 2，商为 0，余数为 1 是二进制数的最高位的数码</li></ul><p><img src="'+j+`" alt="img"></p><p>其结果为：11101</p><h4 id="_4-3-十进制小数转为二进制" tabindex="-1">4.3 十进制小数转为二进制 <a class="header-anchor" href="#_4-3-十进制小数转为二进制" aria-label="Permalink to &quot;4.3 十进制小数转为二进制&quot;">​</a></h4><p>方式是采用“乘 2 取整，顺序排列”法。具体做法是：</p><ul><li>用 2 乘十进制小数，可以得到积，将积的整数部分取出-</li><li>再用 2 乘余下的小数部分，又得到一个积，再将积的整数部分取出-</li><li>如此进行，直到积中的小数部分为零，或者达到所要求的精度为止</li></ul><p>我们具体举一个例子</p><p>如: 十进制 0.25 转为二进制</p><ul><li><code>0.25 * 2 = 0.5</code> 取出整数部分：<code>0</code></li><li><code>0.5 * 2 = 1.0</code> 取出整数部分 1</li></ul><p>即十进制<code>0.25</code>的二进制为 <code>0.01</code> ( 第一次所得到为最高位,最后一次得到为最低位)</p><p>此时我们可以试试十进制<code>0.1</code>和<code>0.2</code>如何转为二进制</p><div class="language- line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span>0.1(十进制) = 0.0001100110011001(二进制)</span></span>
<span class="line"><span>十进制数0.1转二进制计算过程：</span></span>
<span class="line"><span>0.1*2＝0.2……0——整数部分为“0”。整数部分“0”清零后为“0”，用“0.2”接着计算。</span></span>
<span class="line"><span>0.2*2＝0.4……0——整数部分为“0”。整数部分“0”清零后为“0”，用“0.4”接着计算。</span></span>
<span class="line"><span>0.4*2＝0.8……0——整数部分为“0”。整数部分“0”清零后为“0”，用“0.8”接着计算。</span></span>
<span class="line"><span>0.8*2＝1.6……1——整数部分为“1”。整数部分“1”清零后为“0”，用“0.6”接着计算。</span></span>
<span class="line"><span>0.6*2＝1.2……1——整数部分为“1”。整数部分“1”清零后为“0”，用“0.2”接着计算。</span></span>
<span class="line"><span>0.2*2＝0.4……0——整数部分为“0”。整数部分“0”清零后为“0”，用“0.4”接着计算。</span></span>
<span class="line"><span>0.4*2＝0.8……0——整数部分为“0”。整数部分“0”清零后为“0”，用“0.8”接着计算。</span></span>
<span class="line"><span>0.8*2＝1.6……1——整数部分为“1”。整数部分“1”清零后为“0”，用“0.6”接着计算。</span></span>
<span class="line"><span>0.6*2＝1.2……1——整数部分为“1”。整数部分“1”清零后为“0”，用“0.2”接着计算。</span></span>
<span class="line"><span>0.2*2＝0.4……0——整数部分为“0”。整数部分“0”清零后为“0”，用“0.4”接着计算。</span></span>
<span class="line"><span>0.4*2＝0.8……0——整数部分为“0”。整数部分“0”清零后为“0”，用“0.2”接着计算。</span></span>
<span class="line"><span>0.8*2＝1.6……1——整数部分为“1”。整数部分“1”清零后为“0”，用“0.2”接着计算。</span></span>
<span class="line"><span>……</span></span>
<span class="line"><span>……</span></span>
<span class="line"><span>所以，得到的整数依次是：“0”，“0”，“0”，“1”，“1”，“0”，“0”，“1”，“1”，“0”，“0”，“1”……。</span></span>
<span class="line"><span>由此，大家肯定能看出来，整数部分出现了无限循环。</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>接下来看<code>0.2</code></p><div class="language- line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span>0.2化二进制是</span></span>
<span class="line"><span>0.2*2=0.4,整数位为0</span></span>
<span class="line"><span>0.4*2=0.8,整数位为0</span></span>
<span class="line"><span>0.8*2=1.6,整数位为1,去掉整数位得0.6</span></span>
<span class="line"><span>0.6*2=1.2,整数位为1,去掉整数位得0.2</span></span>
<span class="line"><span>0.2*2=0.4,整数位为0</span></span>
<span class="line"><span>0.4*2=0.8.整数位为0</span></span>
<span class="line"><span>就这样推下去！小数*2整,一直下去就行</span></span>
<span class="line"><span>这个数整不断</span></span>
<span class="line"><span>0.0011001</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>所以<code>0.1</code>和<code>0.2</code>都无法完美转化为二进制，所以它们相加当然不是<code>0.3</code>了</p><h3 id="_5、定点数和浮点数" tabindex="-1">5、定点数和浮点数 <a class="header-anchor" href="#_5、定点数和浮点数" aria-label="Permalink to &quot;5、定点数和浮点数&quot;">​</a></h3><p>首先，什么是定点数呢？</p><h4 id="_5-1-定点数" tabindex="-1">5.1 定点数 <a class="header-anchor" href="#_5-1-定点数" aria-label="Permalink to &quot;5.1 定点数&quot;">​</a></h4><p><img src="`+k+'" alt="img"></p><p>如上图，举例纯整数的二进制<code>1011</code>和<code>-1011</code>，如果是<code>整数</code>，符号位用<code>0</code>表示，如果是<code>负数</code>符号为用<code>1</code>表示</p><p><img src="'+x+'" alt="img"></p><p>同理，纯小数表示举例如下：</p><p><img src="'+y+'" alt="img"></p><p>那如果不是<code>纯小数</code>或者<code>纯整数</code>，该怎么表示呢？</p><p>比如<code>10.1</code>, 可以乘以一个比例因子，将<code>10.1 ---&gt; 101</code> 比例因子是<code>10</code>, 或者<code>10.1 ---&gt; 0.101</code>比例因子是<code>100</code></p><p>定点数很简单，接下来我们介绍浮点数，再 JS 里面，数字都是用<code>双精度的浮点数</code>，所以学习浮点数对我们理解 JS 的数字有帮助。</p><h4 id="_5-2-浮点数" tabindex="-1">5.2 浮点数 <a class="header-anchor" href="#_5-2-浮点数" aria-label="Permalink to &quot;5.2 浮点数&quot;">​</a></h4><p>浮点数怎么表示呢？</p><p><img src="'+f+'" alt="img"></p><p>上面是<code>十进制</code>的科学计数法，从中我们需要了解几个概念，一个是<code>尾数</code>，<code>基数</code>和<code>阶码</code></p><ul><li><code>尾数</code>必须是纯小数，所以上图中<code>1.2345</code>不满足尾数的格式，需要改成<code>0.12345</code></li><li><code>基数</code>，在二进制里面是<code>2</code></li><li><code>阶码</code>就是多少次方</li></ul><p>所以<code>浮点数</code>的<code>通用</code>表示格式如下：</p><p><img src="'+A+'" alt="img"></p><ul><li>S 代表尾数</li><li>r 代表基数</li><li>j 代表阶码</li></ul><p>这里需要注意的是，浮点数的加减运算，并不是像我们上面介绍的那样简单，会经过以下几个步骤完成</p><p><img src="'+v+'" alt="img"></p><p>这些名词大家感兴趣的话，可以去网上查询，我们只要了解到<code>浮点数加减运算</code>很麻烦就行了，但如果你要做一个浮点数运算的库，你肯定是要完全掌握的。</p><h3 id="_6、局部性原理和-catche-缓存" tabindex="-1">6、局部性原理和 catche(缓存) <a class="header-anchor" href="#_6、局部性原理和-catche-缓存" aria-label="Permalink to &quot;6、局部性原理和 catche(缓存)&quot;">​</a></h3><p>先看下图</p><p><img src="'+F+`" alt="img"></p><p>（说明一下，<code>MDR</code>和<code>MAR</code>虽然逻辑上属于主存，但是在<code>电路实现</code>的时候，<code>MDR</code>和<code>MAR</code>离<code>CPU</code>比较近）</p><p>上图是在执行一串代码,可以理解为 js 的 for 循环</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#C678DD;">const</span><span style="color:#E5C07B;"> n</span><span style="color:#56B6C2;"> =</span><span style="color:#D19A66;"> 1000</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#C678DD;">const</span><span style="color:#E5C07B;"> a</span><span style="color:#56B6C2;"> =</span><span style="color:#ABB2BF;"> [</span><span style="color:#D19A66;">1</span><span style="color:#ABB2BF;">, </span><span style="color:#D19A66;">2</span><span style="color:#ABB2BF;">, </span><span style="color:#D19A66;">3</span><span style="color:#ABB2BF;">, </span><span style="color:#D19A66;">4</span><span style="color:#ABB2BF;">, </span><span style="color:#D19A66;">5</span><span style="color:#ABB2BF;">, </span><span style="color:#D19A66;">6</span><span style="color:#ABB2BF;">, </span><span style="color:#D19A66;">7</span><span style="color:#ABB2BF;">];</span></span>
<span class="line"><span style="color:#C678DD;">for</span><span style="color:#ABB2BF;"> (</span><span style="color:#C678DD;">let</span><span style="color:#E06C75;"> i</span><span style="color:#56B6C2;"> =</span><span style="color:#D19A66;"> 0</span><span style="color:#ABB2BF;">; </span><span style="color:#E06C75;">i</span><span style="color:#56B6C2;"> &lt;</span><span style="color:#E06C75;"> n</span><span style="color:#ABB2BF;">; </span><span style="color:#E06C75;">i</span><span style="color:#56B6C2;">++</span><span style="color:#ABB2BF;">) {</span></span>
<span class="line"><span style="color:#E06C75;">	a</span><span style="color:#ABB2BF;">[</span><span style="color:#E06C75;">i</span><span style="color:#ABB2BF;">] </span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;"> a</span><span style="color:#ABB2BF;">[</span><span style="color:#E06C75;">i</span><span style="color:#ABB2BF;">] </span><span style="color:#56B6C2;">+</span><span style="color:#D19A66;"> 2</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>我们可以发现</p><ul><li>数组的数据有时候在内存是连续存储的</li><li>如果我们要取数据，比如从内存取出 a[0]的数据需要 1000ns(ns 是纳秒的意思),那么取出 a[0]到 a[7]就需要 1000 * 8 = 8000 ns</li><li>如果我们 cpu 发现这是取数组数据，那么我就把就近的数据块 a[0]到 a[7]全部存到缓存上多好，这样只需要取一次数据，消耗 1000ns</li></ul><p><code>cahce</code>就是<code>局部性原理</code>的一个应用</p><p><img src="`+P+'" alt="img"></p><ul><li><code>空间局部性</code>：在最近的未来要用到的信息（<code>指令</code>和<code>数据</code>），很可能与现在正在使用的信息在<code>存储空间</code>上是邻近的</li><li><code>时间局部性</code>：在最近的未来要用到的信息，很可能是现在<code>正在使用的信息</code></li></ul><p><img src="'+D+'" alt="img"></p><p>可以看到<code>cache</code>一次性取了<code>a[0]</code>到<code>a[9]</code>存储体上的数据，只需要<code>1000ns</code>，因为<code>Cache</code>是<code>高速存储器</code>，跟<code>cpu</code>交互速度就比<code>cpu</code>跟<code>主存</code>交互速度快很多。</p><p>接下里，进入最后一节(略过对总线知识的学习)，I/O 设备的演变</p><h3 id="_7、i-o-设备的演变" tabindex="-1">7、I/O 设备的演变 <a class="header-anchor" href="#_7、i-o-设备的演变" aria-label="Permalink to &quot;7、I/O 设备的演变&quot;">​</a></h3><p>I/O 是什么呢？</p><div class="language- line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span>输入/输出（Input /Output ,简称I/O），指的是一切操作、程序或设备与计算机之间发生的数据传输过程。</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>比如文件读写操作，就是典型的<code>I/O</code>操作。接下来我们看一下 I/O 设备的演进过程</p><p><img src="'+E+'" alt="img"></p><p>在早期的计算机里，<code>cpu</code>如何知道<code>I/O设备</code>已经完成任务呢?比如说怎么知道<code>I/O设备</code>已经读取完一个文件的数据呢?<code>CPU</code>会不断查询<code>I/O设备</code>是否已经准备好。这时，<code>cpu</code>就处于等待状态。也就是<code>cpu</code>工作的时候，<code>I/O</code>系统是不工作的，<code>I/O</code>系统工作，<code>cpu</code>是不工作。</p><p>接着看第二阶段</p><p><img src="'+N+'" alt="img"></p><ul><li>为了解决第一阶段<code>CPU</code>要等待<code>I/O设备</code>，<code>串行</code>的工作方式，所有<code>I/O设备</code>通过<code>I/O总线</code>来跟<code>CPU</code>打交道，一旦某个<code>I/O设备</code>完成任务，就会以<code>中断请求</code>的方式，通过<code>I/O总线</code>，告诉<code>CPU</code>，我已经准备好了。</li><li>但是对于<code>高速外设</code>，它们完成任务的速度很快，所以会频繁中断<code>CPU</code>, 为了解决这个问题，高速外设跟主存之间用一条直接数据通路，<code>DMA总线</code>连接，<code>CPU</code>只需要安排开始高速外设做什么，剩下的就不用管了，这样就可以防止频繁中断<code>CPU</code>。</li></ul><p>最后来看一下第三阶段</p><p><img src="'+I+'" alt="img"></p><p>第三阶段，CPU 通过通道控制部件来管理 I/O 设备，CPU 不需要帮它安排任务，只需要简单的发出启动和停止类似的命令，通道部件就会自动的安排相应的 I/O 设备工作</p><h1 id="其他待定" tabindex="-1">其他待定 <a class="header-anchor" href="#其他待定" aria-label="Permalink to &quot;其他待定&quot;">​</a></h1>',134)]))}const Q=e(L,[["render",O]]);export{z as __pageData,Q as default};
