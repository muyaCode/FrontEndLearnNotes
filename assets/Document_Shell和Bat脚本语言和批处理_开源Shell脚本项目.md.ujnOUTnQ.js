import{_ as n,c as a,o as l,ah as p}from"./chunks/framework.DqD713j2.js";const o="/FrontEndLearnNotes/assets/image-20240510203624378.cSIApr6R.png",e="/FrontEndLearnNotes/assets/image-20240511172803217.D6s2Ed5F.png",u=JSON.parse('{"title":"开源Shell脚本项目","description":"","frontmatter":{},"headers":[],"relativePath":"Document/Shell和Bat脚本语言和批处理/开源Shell脚本项目.md","filePath":"Document/Shell和Bat脚本语言和批处理/开源Shell脚本项目.md","lastUpdated":1750954157000}'),r={name:"Document/Shell和Bat脚本语言和批处理/开源Shell脚本项目.md"};function c(t,s,y,i,B,b){return l(),a("div",null,s[0]||(s[0]=[p(`<h1 id="开源shell脚本项目" tabindex="-1">开源Shell脚本项目 <a class="header-anchor" href="#开源shell脚本项目" aria-label="Permalink to &quot;开源Shell脚本项目&quot;">​</a></h1><p><a href="https://github.com/JosefZIla/bash2048" target="_blank" rel="noreferrer">JosefZIla/bash2048：2048 游戏的 Bash 实现 (github.com)</a></p><p><a href="https://github.com/ropery/FFcast" target="_blank" rel="noreferrer">ropery/FFcast：在矩形屏幕区域上运行命令 (github.com)</a></p><h2 id="揭秘批量远程执行命令的神奇脚本" tabindex="-1">揭秘批量远程执行命令的神奇脚本 <a class="header-anchor" href="#揭秘批量远程执行命令的神奇脚本" aria-label="Permalink to &quot;揭秘批量远程执行命令的神奇脚本&quot;">​</a></h2><p>在日常的系统管理工作中，经常需要远程连接到多台服务器去执行相同的命令。如果你还在一台台地手动连接、输入命令，那你就OUT了！今天，我将向大家揭秘一个能够批量远程执行命令的神奇脚本，让你轻松掌控所有主机！</p><p>首先，让我们来看看这个脚本的庐山真面目：</p><div class="language-bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#7F848E;font-style:italic;">#!/bin/bash  </span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;"># 接收所有传入的参数作为需要远程执行的命令  </span></span>
<span class="line"><span style="color:#E06C75;">COMMAND</span><span style="color:#56B6C2;">=</span><span style="color:#E5C07B;">$*</span><span style="color:#ABB2BF;">  </span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;"># 主机信息文件，记录着每台主机的IP、用户名、端口和密码  </span></span>
<span class="line"><span style="color:#E06C75;">HOST_INFO</span><span style="color:#56B6C2;">=</span><span style="color:#98C379;">host.info</span><span style="color:#ABB2BF;">  </span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;"># 遍历host.info文件中的每一行，提取IP地址  </span></span>
<span class="line"><span style="color:#C678DD;">for</span><span style="color:#E06C75;"> IP</span><span style="color:#C678DD;"> in</span><span style="color:#ABB2BF;"> $(</span><span style="color:#61AFEF;">awk</span><span style="color:#98C379;"> &#39;/^[^#]/{print $1}&#39;</span><span style="color:#E06C75;"> $HOST_INFO</span><span style="color:#ABB2BF;">); </span><span style="color:#C678DD;">do</span><span style="color:#ABB2BF;">  </span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">    # 根据IP地址从host.info文件中提取对应的用户名  </span></span>
<span class="line"><span style="color:#E06C75;">    USER</span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;">$(</span><span style="color:#61AFEF;">awk</span><span style="color:#D19A66;"> -v</span><span style="color:#98C379;"> ip=</span><span style="color:#E06C75;">$IP</span><span style="color:#98C379;"> &#39;ip==$1{print $2}&#39;</span><span style="color:#E06C75;"> $HOST_INFO</span><span style="color:#ABB2BF;">)  </span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">    # 根据IP地址从host.info文件中提取对应的端口号  </span></span>
<span class="line"><span style="color:#E06C75;">    PORT</span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;">$(</span><span style="color:#61AFEF;">awk</span><span style="color:#D19A66;"> -v</span><span style="color:#98C379;"> ip=</span><span style="color:#E06C75;">$IP</span><span style="color:#98C379;"> &#39;ip==$1{print $3}&#39;</span><span style="color:#E06C75;"> $HOST_INFO</span><span style="color:#ABB2BF;">)  </span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">    # 根据IP地址从host.info文件中提取对应的密码  </span></span>
<span class="line"><span style="color:#E06C75;">    PASS</span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;">$(</span><span style="color:#61AFEF;">awk</span><span style="color:#D19A66;"> -v</span><span style="color:#98C379;"> ip=</span><span style="color:#E06C75;">$IP</span><span style="color:#98C379;"> &#39;ip==$1{print $4}&#39;</span><span style="color:#E06C75;"> $HOST_INFO</span><span style="color:#ABB2BF;">)  </span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">    # 使用expect工具自动进行SSH连接，并发送命令  </span></span>
<span class="line"><span style="color:#61AFEF;">    expect</span><span style="color:#D19A66;"> -c</span><span style="color:#98C379;"> &quot;  </span></span>
<span class="line"><span style="color:#98C379;">       spawn ssh -p </span><span style="color:#E06C75;">$PORT</span><span style="color:#E06C75;"> $USER</span><span style="color:#98C379;">@</span><span style="color:#E06C75;">$IP</span><span style="color:#98C379;">  </span></span>
<span class="line"><span style="color:#98C379;">       expect {  </span></span>
<span class="line"><span style="color:#56B6C2;">          \\&quot;</span><span style="color:#98C379;">(yes/no)</span><span style="color:#56B6C2;">\\&quot;</span><span style="color:#98C379;"> {send </span><span style="color:#56B6C2;">\\&quot;</span><span style="color:#98C379;">yes\\r</span><span style="color:#56B6C2;">\\&quot;</span><span style="color:#98C379;">; exp_continue}  </span></span>
<span class="line"><span style="color:#56B6C2;">          \\&quot;</span><span style="color:#98C379;">password:</span><span style="color:#56B6C2;">\\&quot;</span><span style="color:#98C379;"> {send </span><span style="color:#56B6C2;">\\&quot;</span><span style="color:#E06C75;">$PASS</span><span style="color:#98C379;">\\r</span><span style="color:#56B6C2;">\\&quot;</span><span style="color:#98C379;">; exp_continue}  </span></span>
<span class="line"><span style="color:#56B6C2;">          \\&quot;</span><span style="color:#E06C75;">$USER</span><span style="color:#98C379;">@*</span><span style="color:#56B6C2;">\\&quot;</span><span style="color:#98C379;"> {send </span><span style="color:#56B6C2;">\\&quot;</span><span style="color:#E06C75;">$COMMAND</span><span style="color:#98C379;">\\r exit\\r</span><span style="color:#56B6C2;">\\&quot;</span><span style="color:#98C379;">; exp_continue}  </span></span>
<span class="line"><span style="color:#98C379;">       }  </span></span>
<span class="line"><span style="color:#98C379;">    &quot;</span><span style="color:#ABB2BF;">  </span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">    # 输出分隔线，方便查看每台主机的执行结果  </span></span>
<span class="line"><span style="color:#56B6C2;">    echo</span><span style="color:#98C379;"> &quot;-------------------&quot;</span><span style="color:#ABB2BF;">  </span></span>
<span class="line"><span style="color:#C678DD;">done</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br></div></div><p>这个脚本的工作原理如下：</p><ol><li><strong>接收命令</strong>：脚本首先接收所有传入的参数，并将它们组合成一个待执行的命令字符串。</li><li><strong>读取主机信息</strong>：脚本会读取一个名为<code>host.info</code>的文件，该文件记录了所有需要连接的主机的信息，包括IP地址、用户名、端口和密码。</li><li><strong>远程连接</strong>：对于<code>host.info</code>文件中的每一台主机，脚本都会使用<code>expect</code>工具来自动进行SSH连接。这个工具能够模拟用户与终端的交互，自动输入密码等信息。</li><li><strong>执行命令</strong>：一旦成功连接到远程主机，脚本就会发送之前组合好的命令字符串，并在命令执行完毕后自动退出SSH连接。</li><li><strong>输出结果</strong>：每台主机的执行结果都会被打印出来，并用分隔线隔开，方便查看。</li></ol><p>使用这个脚本的好处显而易见：你可以一次性在所有主机上执行相同的命令，而无需逐台登录、逐台输入。这不仅大大提高了工作效率，还减少了人为错误的可能性。</p><p>为了让这个脚本能够正常工作，你需要准备一个<code>host.info</code>文件，格式如下：</p><div class="language-bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#7F848E;font-style:italic;"># 注释行，以#开头，不会被脚本处理  </span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;"># IP地址 用户名 端口 密码  </span></span>
<span class="line"><span style="color:#61AFEF;">192.168.1.100</span><span style="color:#98C379;"> user1</span><span style="color:#D19A66;"> 22</span><span style="color:#98C379;"> passwd1</span><span style="color:#ABB2BF;">  </span></span>
<span class="line"><span style="color:#61AFEF;">192.168.1.101</span><span style="color:#98C379;"> user2</span><span style="color:#D19A66;"> 22</span><span style="color:#98C379;"> passwd2</span><span style="color:#ABB2BF;">  </span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;"># 可以继续添加更多主机信息...</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>请确保你的密码是安全的，并妥善保管好这个文件，以防泄露敏感信息。</p><p>现在，你可以将这个脚本保存为一个可执行文件，比如命名为<code>remote_exec.sh</code>，并给它添加执行权限：<code>chmod +x remote_exec.sh</code>。然后，你就可以通过以下方式使用它了：</p><div class="language- line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span>./remote_exec.sh &quot;ls -l /home&quot;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>这条命令会在所有主机上列出<code>/home</code>目录下的文件和文件夹。你可以将<code>&quot;ls -l /home&quot;</code>替换为任何你需要远程执行的命令。</p><p><img src="`+o+`" alt="image-20240510203624378"></p><h2 id="轻松监控多台服务器磁盘利用率" tabindex="-1">轻松监控多台服务器磁盘利用率 <a class="header-anchor" href="#轻松监控多台服务器磁盘利用率" aria-label="Permalink to &quot;轻松监控多台服务器磁盘利用率&quot;">​</a></h2><h3 id="脚本介绍" tabindex="-1">脚本介绍 <a class="header-anchor" href="#脚本介绍" aria-label="Permalink to &quot;脚本介绍&quot;">​</a></h3><p>这个Bash脚本通过SSH连接到多台服务器，收集各服务器的磁盘利用情况，并在发现某个磁盘分区使用率超过80%时，发送警告邮件到你的指定邮箱。下面，让我们详细了解一下这个脚本的工作原理。</p><div class="language-bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">#!/bin/bash  </span></span>
<span class="line"><span style="color:#E06C75;">HOST_INFO</span><span style="color:#56B6C2;">=</span><span style="color:#98C379;">host.info</span><span style="color:#ABB2BF;">  </span></span>
<span class="line"><span style="color:#C678DD;">for</span><span style="color:#E06C75;"> IP</span><span style="color:#C678DD;"> in</span><span style="color:#ABB2BF;"> $(</span><span style="color:#61AFEF;">awk</span><span style="color:#98C379;"> &#39;/^[^#]/{print $1}&#39;</span><span style="color:#E06C75;"> $HOST_INFO</span><span style="color:#ABB2BF;">); </span><span style="color:#C678DD;">do</span><span style="color:#ABB2BF;">  </span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">    # 取出用户名和端口  </span></span>
<span class="line"><span style="color:#E06C75;">    USER</span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;">$(</span><span style="color:#61AFEF;">awk</span><span style="color:#D19A66;"> -v</span><span style="color:#98C379;"> ip=</span><span style="color:#E06C75;">$IP</span><span style="color:#98C379;"> &#39;ip==$1{print $2}&#39;</span><span style="color:#E06C75;"> $HOST_INFO</span><span style="color:#ABB2BF;">)  </span></span>
<span class="line"><span style="color:#E06C75;">    PORT</span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;">$(</span><span style="color:#61AFEF;">awk</span><span style="color:#D19A66;"> -v</span><span style="color:#98C379;"> ip=</span><span style="color:#E06C75;">$IP</span><span style="color:#98C379;"> &#39;ip==$1{print $3}&#39;</span><span style="color:#E06C75;"> $HOST_INFO</span><span style="color:#ABB2BF;">)  </span></span>
<span class="line"><span style="color:#ABB2BF;">      </span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">    # 创建临时文件，保存信息  </span></span>
<span class="line"><span style="color:#E06C75;">    TMP_FILE</span><span style="color:#56B6C2;">=</span><span style="color:#98C379;">/tmp/disk.tmp</span><span style="color:#ABB2BF;">  </span></span>
<span class="line"><span style="color:#ABB2BF;">      </span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">    # 通过公钥登录获取主机磁盘信息  </span></span>
<span class="line"><span style="color:#61AFEF;">    ssh</span><span style="color:#D19A66;"> -p</span><span style="color:#E06C75;"> $PORT</span><span style="color:#E06C75;"> $USER</span><span style="color:#98C379;">@</span><span style="color:#E06C75;">$IP</span><span style="color:#98C379;"> &#39;df -h&#39;</span><span style="color:#ABB2BF;"> &gt; </span><span style="color:#E06C75;">$TMP_FILE</span><span style="color:#ABB2BF;">  </span></span>
<span class="line"><span style="color:#ABB2BF;">      </span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">    # 分析磁盘占用空间  </span></span>
<span class="line"><span style="color:#E06C75;">    USE_RATE_LIST</span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;">$(</span><span style="color:#61AFEF;">awk</span><span style="color:#98C379;"> &#39;BEGIN{OFS=&quot;=&quot;}/^\\/dev/{print $NF,int($5)}&#39;</span><span style="color:#E06C75;"> $TMP_FILE</span><span style="color:#ABB2BF;">)  </span></span>
<span class="line"><span style="color:#ABB2BF;">      </span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">    # 循环磁盘列表，进行判断  </span></span>
<span class="line"><span style="color:#C678DD;">    for</span><span style="color:#E06C75;"> USE_RATE</span><span style="color:#C678DD;"> in</span><span style="color:#E06C75;"> $USE_RATE_LIST</span><span style="color:#ABB2BF;">; </span><span style="color:#C678DD;">do</span><span style="color:#ABB2BF;">  </span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">        # 取出等号(=)右边的值，即挂载点名称  </span></span>
<span class="line"><span style="color:#E06C75;">        PART_NAME</span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;">\${</span><span style="color:#E06C75;">USE_RATE</span><span style="color:#ABB2BF;">%=*}  </span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">        # 取出等号(=)左边的值，即磁盘利用率  </span></span>
<span class="line"><span style="color:#E06C75;">        USE_RATE</span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;">\${</span><span style="color:#E06C75;">USE_RATE</span><span style="color:#ABB2BF;">#*=}  </span></span>
<span class="line"><span style="color:#ABB2BF;">          </span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">        # 进行判断  </span></span>
<span class="line"><span style="color:#C678DD;">        if</span><span style="color:#ABB2BF;"> [ </span><span style="color:#E06C75;">$USE_RATE</span><span style="color:#56B6C2;"> -ge</span><span style="color:#D19A66;"> 80</span><span style="color:#ABB2BF;"> ]; </span><span style="color:#C678DD;">then</span><span style="color:#ABB2BF;">  </span></span>
<span class="line"><span style="color:#56B6C2;">            echo</span><span style="color:#98C379;"> &quot;Warning: </span><span style="color:#E06C75;">$PART_NAME</span><span style="color:#98C379;"> Partition usage </span><span style="color:#E06C75;">$USE_RATE</span><span style="color:#98C379;">%!&quot;</span><span style="color:#ABB2BF;">  </span></span>
<span class="line"><span style="color:#56B6C2;">            echo</span><span style="color:#98C379;"> &quot;服务器</span><span style="color:#E06C75;">$IP的磁盘空间占用过高</span><span style="color:#98C379;">，请及时处理&quot;</span><span style="color:#ABB2BF;"> | </span><span style="color:#61AFEF;">mail</span><span style="color:#D19A66;"> -s</span><span style="color:#98C379;"> &quot;空间不足警告&quot;</span><span style="color:#98C379;"> 你的qq@qq.com</span><span style="color:#ABB2BF;">  </span></span>
<span class="line"><span style="color:#C678DD;">        else</span><span style="color:#ABB2BF;">  </span></span>
<span class="line"><span style="color:#56B6C2;">            echo</span><span style="color:#98C379;"> &quot;服务器</span><span style="color:#E06C75;">$IP的$PART_NAME目录空间良好</span><span style="color:#98C379;">&quot;</span><span style="color:#ABB2BF;">  </span></span>
<span class="line"><span style="color:#C678DD;">        fi</span><span style="color:#ABB2BF;">  </span></span>
<span class="line"><span style="color:#C678DD;">    done</span><span style="color:#ABB2BF;">  </span></span>
<span class="line"><span style="color:#C678DD;">done</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br></div></div><p>这个脚本首先从一个名为<code>host.info</code>的文件中读取服务器信息，该文件应包含每行一个服务器的IP地址、用户名和端口号，以空格分隔。例如：</p><div class="language-bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#7F848E;font-style:italic;"># host.info 文件示例  </span></span>
<span class="line"><span style="color:#61AFEF;">192.168.1.100</span><span style="color:#98C379;"> username1</span><span style="color:#D19A66;"> 22</span><span style="color:#ABB2BF;">  </span></span>
<span class="line"><span style="color:#61AFEF;">192.168.1.101</span><span style="color:#98C379;"> username2</span><span style="color:#D19A66;"> 2222</span><span style="color:#ABB2BF;">  </span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;"># ... 更多服务器信息</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>脚本通过SSH连接到每台服务器，并运行<code>df -h</code>命令来获取磁盘使用情况。然后，它使用<code>awk</code>命令分析输出结果，提取出每个磁盘分区的挂载点和利用率。如果某个分区的利用率达到或超过80%，脚本将发送一封警告邮件到你的指定邮箱。</p><h3 id="脚本优势与特点" tabindex="-1">脚本优势与特点 <a class="header-anchor" href="#脚本优势与特点" aria-label="Permalink to &quot;脚本优势与特点&quot;">​</a></h3><ol><li><strong>集中监控</strong>：通过一个脚本即可监控多台服务器的磁盘利用率，无需在每台服务器上单独设置监控。</li><li><strong>灵活性</strong>：你可以根据需要轻松添加或删除要监控的服务器，只需在<code>host.info</code>文件中进行相应的更改即可。</li><li><strong>实时性</strong>：脚本实时获取服务器的磁盘使用情况，确保你能够及时了解并解决潜在的磁盘空间问题。</li><li><strong>可扩展性</strong>：你可以根据自己的需求对脚本进行修改和扩展，例如添加更多的监控项或自定义警告阈值等。</li></ol><h3 id="使用建议与注意事项" tabindex="-1">使用建议与注意事项 <a class="header-anchor" href="#使用建议与注意事项" aria-label="Permalink to &quot;使用建议与注意事项&quot;">​</a></h3><ol><li><strong>安全性</strong>：确保在使用SSH连接时采用了安全的身份验证方式，如公钥认证，以避免密码泄露风险。</li><li><strong>性能考虑</strong>：如果你监控的服务器数量众多，建议合理安排脚本的运行频率，以避免对服务器造成过大的负载。</li><li><strong>错误处理</strong>：在实际使用中，可能会遇到网络问题、SSH连接失败等异常情况。建议在脚本中添加适当的错误处理逻辑，以提高稳定性。</li><li><strong>日志记录</strong>：为了便于追踪和排查问题，建议将脚本的输出重定向到一个日志文件，以便随时查看和分析。</li></ol><p>通过这个实用的Bash脚本，你可以轻松实现多台服务器磁盘利用率的集中监控。无论是对于系统管理员还是运维工程师来说，这都是一个非常有价值的工具。现在就开始尝试吧，让你的服务器管理工作更加高效和便捷！</p><h2 id="打造动态进度条的shell脚本秘诀" tabindex="-1">打造动态进度条的Shell脚本秘诀 <a class="header-anchor" href="#打造动态进度条的shell脚本秘诀" aria-label="Permalink to &quot;打造动态进度条的Shell脚本秘诀&quot;">​</a></h2><p>你是否曾在命令行终端中看到过那些酷炫的动态进度条，它们是如何实现的呢？今天，就让我们一起揭开这个神秘的面纱，通过一个简单而有趣的Shell脚本实例，来教大家如何制作属于自己的动态进度条！</p><p><img src="`+e+`" alt="image-20240511172803217"></p><p>在Linux终端中，我们经常需要执行一些耗时较长的任务，如文件传输、大数据处理或软件编译等。在这些任务执行过程中，如果能够有一个直观的进度条来展示任务进度，无疑会大大提升用户体验。下面这段代码，就是利用Shell脚本和ANSI转义序列，来制作一个简单的动态进度条。</p><div class="language-shell line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#7F848E;font-style:italic;"># 声明一个数组变量ary  </span></span>
<span class="line"><span style="color:#C678DD;">declare</span><span style="color:#D19A66;"> -a</span><span style="color:#E06C75;"> ary</span><span style="color:#ABB2BF;">  </span></span>
<span class="line"><span style="color:#ABB2BF;">  </span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;"># 初始化数组，为数组的每个元素（下标40到49）赋值为空格  </span></span>
<span class="line"><span style="color:#C678DD;">for</span><span style="color:#E06C75;"> i</span><span style="color:#C678DD;"> in</span><span style="color:#98C379;"> \`</span><span style="color:#61AFEF;">seq</span><span style="color:#D19A66;"> 40</span><span style="color:#D19A66;"> 49</span><span style="color:#98C379;">\`</span><span style="color:#ABB2BF;">  </span></span>
<span class="line"><span style="color:#C678DD;">do</span><span style="color:#ABB2BF;">  </span></span>
<span class="line"><span style="color:#E06C75;">    ary</span><span style="color:#ABB2BF;">[</span><span style="color:#E06C75;">$i</span><span style="color:#ABB2BF;">]</span><span style="color:#56B6C2;">=</span><span style="color:#98C379;">&quot; &quot;</span><span style="color:#7F848E;font-style:italic;">  # 数组下标从40到49的元素均赋值为一个空格  </span></span>
<span class="line"><span style="color:#ABB2BF;">  </span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">    # 使用ANSI转义序列在终端的特定行上显示数组内容，模拟进度条效果  </span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">    # \\e[ 是转义字符的开始，$i 是行号，5m 表示设置文本闪烁，\${ary[@]} 打印整个数组的内容  </span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">    # \\e[;0m 是转义字符的结束，用于重置之前的文本属性设置  </span></span>
<span class="line"><span style="color:#56B6C2;">    echo</span><span style="color:#D19A66;"> -en</span><span style="color:#98C379;"> &quot;\\e[</span><span style="color:#E06C75;">$i</span><span style="color:#98C379;">;5m \${</span><span style="color:#E06C75;">ary</span><span style="color:#98C379;">[</span><span style="color:#ABB2BF;">@</span><span style="color:#98C379;">]}\\e[;0m&quot;</span><span style="color:#ABB2BF;">  </span></span>
<span class="line"><span style="color:#C678DD;">done</span><span style="color:#ABB2BF;">  </span></span>
<span class="line"><span style="color:#ABB2BF;">  </span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;"># 下面的代码是一个更复杂的例子，通过双层循环来模拟一个动态更新的进度条效果  </span></span>
<span class="line"><span style="color:#C678DD;">declare</span><span style="color:#D19A66;"> -a</span><span style="color:#E06C75;"> ary</span><span style="color:#ABB2BF;">  </span></span>
<span class="line"><span style="color:#C678DD;">for</span><span style="color:#E06C75;"> s</span><span style="color:#C678DD;"> in</span><span style="color:#98C379;"> \`</span><span style="color:#61AFEF;">seq</span><span style="color:#D19A66;"> 1</span><span style="color:#D19A66;"> 10000</span><span style="color:#98C379;">\`</span><span style="color:#7F848E;font-style:italic;">  # 外层循环，用于控制进度条的更新次数  </span></span>
<span class="line"><span style="color:#C678DD;">do</span><span style="color:#ABB2BF;">  </span></span>
<span class="line"><span style="color:#C678DD;">    for</span><span style="color:#E06C75;"> i</span><span style="color:#C678DD;"> in</span><span style="color:#98C379;"> \`</span><span style="color:#61AFEF;">seq</span><span style="color:#D19A66;"> 40</span><span style="color:#D19A66;"> 49</span><span style="color:#98C379;">\`</span><span style="color:#7F848E;font-style:italic;">  # 内层循环，用于初始化或更新进度条  </span></span>
<span class="line"><span style="color:#C678DD;">    do</span><span style="color:#ABB2BF;">  </span></span>
<span class="line"><span style="color:#E06C75;">        ary</span><span style="color:#ABB2BF;">[</span><span style="color:#E06C75;">$i</span><span style="color:#ABB2BF;">]</span><span style="color:#56B6C2;">=</span><span style="color:#98C379;">&quot; &quot;</span><span style="color:#7F848E;font-style:italic;">  # 每次循环都重新为数组元素赋值空格，相当于清空进度条  </span></span>
<span class="line"><span style="color:#ABB2BF;">  </span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">        # 与上面的echo命令类似，但这次是在双层循环中，因此会不断更新进度条的状态  </span></span>
<span class="line"><span style="color:#56B6C2;">        echo</span><span style="color:#D19A66;"> -en</span><span style="color:#98C379;"> &quot;\\e[</span><span style="color:#E06C75;">$i</span><span style="color:#98C379;">;5m \${</span><span style="color:#E06C75;">ary</span><span style="color:#98C379;">[</span><span style="color:#ABB2BF;">@</span><span style="color:#98C379;">]}\\e[;0m&quot;</span><span style="color:#ABB2BF;">  </span></span>
<span class="line"><span style="color:#C678DD;">    done</span><span style="color:#ABB2BF;">  </span></span>
<span class="line"><span style="color:#C678DD;">done</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br></div></div><p><strong>代码解析</strong>：</p><ol><li><strong>declare -a ary</strong>：这行代码声明了一个名为<code>ary</code>的数组变量。在Shell脚本中，数组可以存储多个值，每个值由一个唯一的下标标识。</li><li><strong>for i in <code>seq 40 49</code></strong>：这个循环用于初始化数组<code>ary</code>，将其下标从40到49的元素设置为空格。这些下标对应于终端中的行号，稍后将用于在特定行上显示进度条。</li><li>echo -en &quot;\\e[i;5m{ary[@]}\\e[;0m&quot;：这行代码使用ANSI转义序列在终端的指定行上显示数组的内容。<code>\\e[</code> 开始一个转义序列，<code>$i</code> 是行号，<code>5m</code> 设置文本闪烁（这样可以让进度条动态显示），<code>\${ary[@]}</code> 打印整个数组的内容，<code>\\e[;0m</code> 重置文本属性。</li><li>在第二个双层循环中，外层循环控制进度条的更新次数，内层循环则负责在每次更新时清空并重新显示进度条。虽然这个示例中的进度条并没有实际的进度信息（只是简单地重复显示空格），但你可以根据需要修改代码，比如根据任务的实际进度来更新进度条的状态。</li></ol><p><strong>如何应用这段代码？</strong></p><p>这个简单的Shell脚本示例展示了如何在Linux终端中创建动态进度条。你可以将这段代码嵌入到你的Shell脚本中，用于显示长时间运行任务的进度。当然，为了让它更加实用，你可能需要根据你的具体任务来定制进度条的更新逻辑。</p><p><strong>注意事项</strong>：</p><ul><li>这个脚本在大多数Linux终端中应该都能正常工作，但不同的终端可能对ANSI转义序列的支持有所不同。</li><li>进度条的显示效果和性能也取决于你的终端性能和设置。</li></ul><p>现在你已经知道了如何在Shell脚本中创建动态进度条，快去试试吧！无论是为了提升你的脚本的用户体验，还是仅仅为了好玩，这都是一个值得尝试的技巧。</p><p><strong>终端魔法：更多高级技巧等你来探索</strong></p><p>当然，这只是终端技巧中的冰山一角。Linux终端是一个强大而灵活的工具，掌握它可以让你的工作更加高效、有趣。除了动态进度条，还有很多其他的高级技巧和工具等待你去探索，比如使用<code>tput</code>命令来控制光标位置、颜色和其他终端属性，或者使用<code>expect</code>工具来自动化交互式任务。不断学习和实践，你会发现终端世界中的无尽魅力！</p><h2 id="bash脚本入门-随机数数组排序全解析-生成与排序" tabindex="-1">Bash脚本入门：随机数数组排序全解析-生成与排序 <a class="header-anchor" href="#bash脚本入门-随机数数组排序全解析-生成与排序" aria-label="Permalink to &quot;Bash脚本入门：随机数数组排序全解析-生成与排序&quot;">​</a></h2><p>在Linux系统中，Bash脚本是一种强大的自动化工具，它可以帮助我们执行一系列复杂的任务。今天，我们将通过一个简单的示例，展示如何在Bash脚本中生成一个随机数数组，并对其进行排序。这个过程不仅有趣，而且是学习Bash编程基础知识的好方法。</p><h3 id="一、生成随机数数组" tabindex="-1">一、生成随机数数组 <a class="header-anchor" href="#一、生成随机数数组" aria-label="Permalink to &quot;一、生成随机数数组&quot;">​</a></h3><p>首先，让我们来看看如何生成一个包含随机数的数组。在Bash脚本中，我们可以使用<code>$RANDOM</code>变量来生成随机数。下面是一个简单的脚本，它创建了一个包含10个随机数的数组：</p><div class="language-bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#7F848E;font-style:italic;">#!/bin/bash  </span></span>
<span class="line"><span style="color:#C678DD;">declare</span><span style="color:#D19A66;"> -a</span><span style="color:#E06C75;"> array</span><span style="color:#7F848E;font-style:italic;"> # 声明一个数组变量  </span></span>
<span class="line"><span style="color:#C678DD;">for</span><span style="color:#E06C75;"> i</span><span style="color:#C678DD;"> in</span><span style="color:#98C379;"> \`</span><span style="color:#61AFEF;">seq</span><span style="color:#D19A66;"> 1</span><span style="color:#D19A66;"> 10</span><span style="color:#98C379;">\`</span><span style="color:#7F848E;font-style:italic;"> # 使用seq命令生成一个从1到10的序列  </span></span>
<span class="line"><span style="color:#C678DD;">do</span><span style="color:#ABB2BF;">  </span></span>
<span class="line"><span style="color:#E06C75;">    array</span><span style="color:#ABB2BF;">[</span><span style="color:#E06C75;">$i</span><span style="color:#ABB2BF;">]</span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;">$RANDOM</span><span style="color:#7F848E;font-style:italic;"> # 将每个随机数赋值给数组的对应元素  </span></span>
<span class="line"><span style="color:#C678DD;">done</span><span style="color:#ABB2BF;">  </span></span>
<span class="line"><span style="color:#56B6C2;">echo</span><span style="color:#D19A66;"> -e</span><span style="color:#98C379;"> &quot;Array_1:  \${</span><span style="color:#E06C75;">array</span><span style="color:#98C379;">[</span><span style="color:#ABB2BF;">@</span><span style="color:#98C379;">]}&quot;</span><span style="color:#7F848E;font-style:italic;"> # 打印整个数组的内容</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>这段代码首先声明了一个名为<code>array</code>的数组。然后，它使用一个for循环和<code>seq</code>命令来生成一个从1到10的数字序列。在每次循环中，它都将一个随机数赋值给数组的相应元素。最后，它使用<code>\${array[@]}</code>来打印整个数组的内容。</p><h3 id="二、对随机数数组进行排序" tabindex="-1">二、对随机数数组进行排序 <a class="header-anchor" href="#二、对随机数数组进行排序" aria-label="Permalink to &quot;二、对随机数数组进行排序&quot;">​</a></h3><p>生成了随机数数组之后，我们可能希望对这些数字进行排序。虽然Bash本身没有提供内置的排序函数，但我们可以通过编写自己的排序算法来实现这一目标。下面是一个使用冒泡排序算法对数组进行排序的脚本：</p><div class="language-bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#C678DD;">for</span><span style="color:#ABB2BF;"> (( </span><span style="color:#E06C75;">x</span><span style="color:#56B6C2;">=</span><span style="color:#D19A66;">1</span><span style="color:#ABB2BF;">; </span><span style="color:#E06C75;">x</span><span style="color:#56B6C2;">&lt;=</span><span style="color:#D19A66;">9</span><span style="color:#ABB2BF;">; </span><span style="color:#E06C75;">x</span><span style="color:#56B6C2;">++</span><span style="color:#ABB2BF;"> )) </span><span style="color:#7F848E;font-style:italic;"># 外层循环，控制排序的轮数  </span></span>
<span class="line"><span style="color:#C678DD;">do</span><span style="color:#ABB2BF;">  </span></span>
<span class="line"><span style="color:#C678DD;">    for</span><span style="color:#ABB2BF;">(( </span><span style="color:#E06C75;">y</span><span style="color:#56B6C2;">=</span><span style="color:#D19A66;">1</span><span style="color:#ABB2BF;">; </span><span style="color:#E06C75;">y</span><span style="color:#56B6C2;">&lt;=</span><span style="color:#D19A66;">9</span><span style="color:#ABB2BF;">; </span><span style="color:#E06C75;">y</span><span style="color:#56B6C2;">++</span><span style="color:#ABB2BF;"> )) </span><span style="color:#7F848E;font-style:italic;"># 内层循环，负责两两比较和交换  </span></span>
<span class="line"><span style="color:#C678DD;">    do</span><span style="color:#ABB2BF;">  </span></span>
<span class="line"><span style="color:#C678DD;">        if</span><span style="color:#ABB2BF;"> [ \${</span><span style="color:#E06C75;">array</span><span style="color:#ABB2BF;">[</span><span style="color:#E06C75;">$y</span><span style="color:#ABB2BF;">]} </span><span style="color:#56B6C2;">-gt</span><span style="color:#ABB2BF;"> \${</span><span style="color:#E06C75;">array</span><span style="color:#ABB2BF;">[$((</span><span style="color:#E06C75;">$y</span><span style="color:#ABB2BF;">+1))]} ] </span><span style="color:#7F848E;font-style:italic;"># 如果前一个数大于后一个数  </span></span>
<span class="line"><span style="color:#C678DD;">        then</span><span style="color:#ABB2BF;">  </span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">            # 交换两个元素的值  </span></span>
<span class="line"><span style="color:#E06C75;">            temp</span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;">\${</span><span style="color:#E06C75;">array</span><span style="color:#ABB2BF;">[</span><span style="color:#E06C75;">$y</span><span style="color:#ABB2BF;">]} </span><span style="color:#7F848E;font-style:italic;"># 将array[y]的值保存到临时变量中  </span></span>
<span class="line"><span style="color:#E06C75;">            array</span><span style="color:#ABB2BF;">[</span><span style="color:#E06C75;">$y</span><span style="color:#ABB2BF;">]</span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;">\${</span><span style="color:#E06C75;">array</span><span style="color:#ABB2BF;">[$((</span><span style="color:#E06C75;">$y</span><span style="color:#ABB2BF;">+1))]} </span><span style="color:#7F848E;font-style:italic;"># 将array[y+1]的值赋给array[y]  </span></span>
<span class="line"><span style="color:#61AFEF;">            array[$(($y+1</span><span style="color:#ABB2BF;">))]=</span><span style="color:#E06C75;">$temp</span><span style="color:#7F848E;font-style:italic;"> # 将临时变量的值赋给array[y+1]  </span></span>
<span class="line"><span style="color:#C678DD;">        fi</span><span style="color:#ABB2BF;">  </span></span>
<span class="line"><span style="color:#C678DD;">    done</span><span style="color:#ABB2BF;">  </span></span>
<span class="line"><span style="color:#C678DD;">done</span><span style="color:#ABB2BF;">  </span></span>
<span class="line"><span style="color:#56B6C2;">echo</span><span style="color:#D19A66;"> -e</span><span style="color:#98C379;"> &quot;Array_2:  \${</span><span style="color:#E06C75;">array</span><span style="color:#98C379;">[</span><span style="color:#ABB2BF;">@</span><span style="color:#98C379;">]}&quot;</span><span style="color:#7F848E;font-style:italic;"> # 打印排序后的数组内容</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>这段代码使用了嵌套的for循环来实现冒泡排序。外层循环控制排序的轮数，内层循环则负责两两比较数组中的元素，并根据需要进行交换。注意，在比较时我们使用了<code>-gt</code>（大于）操作符来判断前一个数是否大于后一个数。如果是，则交换这两个数的位置。最后，我们再次打印整个数组的内容，以验证排序结果。</p><h3 id="三、完整脚本及运行示例" tabindex="-1">三、完整脚本及运行示例 <a class="header-anchor" href="#三、完整脚本及运行示例" aria-label="Permalink to &quot;三、完整脚本及运行示例&quot;">​</a></h3><p>将上述两部分代码合并，我们得到了一个完整的Bash脚本，该脚本可以生成一个随机数数组并对其进行排序：</p><div class="language-bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#7F848E;font-style:italic;">#!/bin/bash  </span></span>
<span class="line"><span style="color:#C678DD;">declare</span><span style="color:#D19A66;"> -a</span><span style="color:#E06C75;"> array</span><span style="color:#7F848E;font-style:italic;"> # 声明数组变量  </span></span>
<span class="line"><span style="color:#C678DD;">for</span><span style="color:#E06C75;"> i</span><span style="color:#C678DD;"> in</span><span style="color:#98C379;"> \`</span><span style="color:#61AFEF;">seq</span><span style="color:#D19A66;"> 1</span><span style="color:#D19A66;"> 10</span><span style="color:#98C379;">\`</span><span style="color:#7F848E;font-style:italic;"> # 生成随机数数组  </span></span>
<span class="line"><span style="color:#C678DD;">do</span><span style="color:#ABB2BF;">  </span></span>
<span class="line"><span style="color:#E06C75;">    array</span><span style="color:#ABB2BF;">[</span><span style="color:#E06C75;">$i</span><span style="color:#ABB2BF;">]</span><span style="color:#56B6C2;">=</span><span style="color:#E06C75;">$RANDOM</span><span style="color:#7F848E;font-style:italic;"> # 为数组元素赋值随机数  </span></span>
<span class="line"><span style="color:#C678DD;">done</span><span style="color:#ABB2BF;">  </span></span>
<span class="line"><span style="color:#56B6C2;">echo</span><span style="color:#D19A66;"> -e</span><span style="color:#98C379;"> &quot;Array_1:  \${</span><span style="color:#E06C75;">array</span><span style="color:#98C379;">[</span><span style="color:#ABB2BF;">@</span><span style="color:#98C379;">]}&quot;</span><span style="color:#7F848E;font-style:italic;"> # 打印原始数组内容  </span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;"># 使用冒泡排序算法对数组进行排序  </span></span>
<span class="line"><span style="color:#C678DD;">for</span><span style="color:#ABB2BF;"> (( </span><span style="color:#E06C75;">x</span><span style="color:#56B6C2;">=</span><span style="color:#D19A66;">1</span><span style="color:#ABB2BF;">; </span><span style="color:#E06C75;">x</span><span style="color:#56B6C2;">&lt;=</span><span style="color:#D19A66;">9</span><span style="color:#ABB2BF;">; </span><span style="color:#E06C75;">x</span><span style="color:#56B6C2;">++</span><span style="color:#ABB2BF;"> ))   </span></span>
<span class="line"><span style="color:#C678DD;">do</span><span style="color:#ABB2BF;">  </span></span>
<span class="line"><span style="color:#C678DD;">    for</span><span style="color:#ABB2BF;">(( </span><span style="color:#E06C75;">y</span><span style="color:#56B6C2;">=</span><span style="color:#D19A66;">1</span><span style="color:#ABB2BF;">; </span><span style="color:#E06C75;">y</span><span style="color:#56B6C2;">&lt;=</span><span style="color:#D19A66;">9</span><span style="color:#ABB2BF;">; </span><span style="color:#E06C75;">y</span><span style="color:#56B6C2;">++</span><span style="color:#ABB2BF;"> ))   </span></span>
<span class="line"><span style="color:#C678DD;">    do</span><span style="color:#ABB2BF;">  </span></span>
<span class="line"><span style="color:#C678DD;">        if</span><span style="color:#ABB2BF;"> [ \${</span><span style="color:#E06C75;">array</span><span style="color:#ABB2BF;">[</span><span style="color:#E06C75;">$y</span><span style="color:#ABB2BF;">]} </span><span style="color:#56B6C2;">-gt</span><span style="color:#ABB2BF;"> \${</span><span style="color:#E06C75;">array</span><span style="color:#ABB2BF;">[$((</span><span style="color:#E06C75;">$y</span><span style="color:#ABB2BF;">+1))]} ]   </span></span>
<span class="line"><span style="color:#C678DD;">        then</span><span style="color:#ABB2BF;">  </span></span>
<span class="line"><span style="color:#E06C75;">            temp</span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;">\${</span><span style="color:#E06C75;">array</span><span style="color:#ABB2BF;">[</span><span style="color:#E06C75;">$y</span><span style="color:#ABB2BF;">]} </span><span style="color:#7F848E;font-style:italic;"># 交换元素值  </span></span>
<span class="line"><span style="color:#E06C75;">            array</span><span style="color:#ABB2BF;">[</span><span style="color:#E06C75;">$y</span><span style="color:#ABB2BF;">]</span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;">\${</span><span style="color:#E06C75;">array</span><span style="color:#ABB2BF;">[$((</span><span style="color:#E06C75;">$y</span><span style="color:#ABB2BF;">+1))]}  </span></span>
<span class="line"><span style="color:#61AFEF;">            array[$(($y+1</span><span style="color:#ABB2BF;">))]=</span><span style="color:#E06C75;">$temp</span><span style="color:#ABB2BF;">  </span></span>
<span class="line"><span style="color:#C678DD;">        fi</span><span style="color:#ABB2BF;">  </span></span>
<span class="line"><span style="color:#C678DD;">    done</span><span style="color:#ABB2BF;">  </span></span>
<span class="line"><span style="color:#C678DD;">done</span><span style="color:#ABB2BF;">  </span></span>
<span class="line"><span style="color:#56B6C2;">echo</span><span style="color:#D19A66;"> -e</span><span style="color:#98C379;"> &quot;Array_2:  \${</span><span style="color:#E06C75;">array</span><span style="color:#98C379;">[</span><span style="color:#ABB2BF;">@</span><span style="color:#98C379;">]}&quot;</span><span style="color:#7F848E;font-style:italic;"> # 打印排序后的数组内容</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><p>保存上述代码为一个<code>.sh</code>文件（例如<code>sort_random_array.sh</code>），然后在终端中运行以下命令来执行脚本：</p><div class="language-bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#61AFEF;">chmod</span><span style="color:#98C379;"> +x</span><span style="color:#98C379;"> sort_random_array.sh</span><span style="color:#7F848E;font-style:italic;"> # 添加可执行权限  </span></span>
<span class="line"><span style="color:#61AFEF;">./sort_random_array.sh</span><span style="color:#7F848E;font-style:italic;"> # 运行脚本</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>你将看到脚本首先打印出一个包含10个随机数的数组，然后打印出排序后的数组。每次运行脚本时，生成的随机数都会不同，但排序后的数组总是按升序排列的。这是因为我们使用了冒泡排序算法对数组进行了排序。</p><h3 id="四、结语" tabindex="-1">四、结语 <a class="header-anchor" href="#四、结语" aria-label="Permalink to &quot;四、结语&quot;">​</a></h3><p>通过这个简单的示例，我们学习了如何在Bash脚本中生成随机数数组，并使用冒泡排序算法对其进行排序。这个过程不仅展示了Bash脚本的强大功能，还帮助我们巩固了编程基础知识。现在，你可以尝试修改这个脚本，以适应不同的需求或添加更多的功能。</p><p>例如，你可以尝试使用其他排序算法（如插入排序、选择排序等）来对数组进行排序，或者生成不同大小和范围的随机数数组。无论你选择做什么样的修改和扩展，这个简单的示例都将为你提供一个坚实的基础，帮助你更好地理解Bash脚本编程的原理和技巧。</p>`,62)]))}const d=n(r,[["render",c]]);export{u as __pageData,d as default};
