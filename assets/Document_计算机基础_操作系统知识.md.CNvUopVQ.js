import{_ as a,c as e,o as n,ah as p}from"./chunks/framework.DqD713j2.js";const o="/FrontEndLearnNotes/assets/625bd319664a4c47ac3e09c42af27648tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.CqhU6EHr.webp",l="/FrontEndLearnNotes/assets/b7e94d10138444fca675d3e78771cd3dtplv-k3u1fbpfcp-zoom-in-crop-mark1512000.CMqmNZMQ.webp",c="/FrontEndLearnNotes/assets/c63454bc3f6d47ada18e16ac8b1448bbtplv-k3u1fbpfcp-zoom-in-crop-mark1512000.Be-d-yxk.webp",r="/FrontEndLearnNotes/assets/5ffec6ba8bb84fd3b671562ddaa4dd3atplv-k3u1fbpfcp-zoom-in-crop-mark1512000.BKRQ-hLO.webp",t="/FrontEndLearnNotes/assets/5e2b1d866079496989d6aa802976c718tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.CYUgHTsJ.webp",i="/FrontEndLearnNotes/assets/7aad0ff1519c45e88923eac0ca186ff1tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.CsXTN5In.webp",d="/FrontEndLearnNotes/assets/bbb1d6ab19194af0990f24f1d4f3b54ctplv-k3u1fbpfcp-zoom-in-crop-mark1512000.Lo70L2EM.webp",b="/FrontEndLearnNotes/assets/62afac3d324d4d4db8a4e6e594861cfdtplv-k3u1fbpfcp-zoom-in-crop-mark1512000.DFZuwnyv.webp",m="/FrontEndLearnNotes/assets/ff2fa4931c914df39b70b5165d50e5d4tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.P0CAJsBY.webp",u="/FrontEndLearnNotes/assets/6dcf78ddde4945f0b93f7d55952f64datplv-k3u1fbpfcp-zoom-in-crop-mark1512000.DLHhjvHQ.webp",B="/FrontEndLearnNotes/assets/63e2b27cc0914088a2d0357ab332ade7tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.C3fP6Eyz.webp",f="/FrontEndLearnNotes/assets/85d60c74edfc4e9485fba703f52dd97etplv-k3u1fbpfcp-zoom-in-crop-mark1512000.NN1QaFJq.webp",y="/FrontEndLearnNotes/assets/fad302f1961248dc8489739fd8e28c46tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.60NCfW0D.webp",h="/FrontEndLearnNotes/assets/80201fdf7ce242f18174dcb18ff4b833tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.BOu7Zx84.webp",F="/FrontEndLearnNotes/assets/7b732a28a9ad435f8f20b365edd08916tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.ghK-pRif.webp",k="/FrontEndLearnNotes/assets/1cea105addf6473da486e64fe6b9be56tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.2wxPesGZ.webp",A="/FrontEndLearnNotes/assets/e3ce930479dc4ba0a6fb021198de671dtplv-k3u1fbpfcp-zoom-in-crop-mark1512000.Ch8TaJ0O.webp",g="/FrontEndLearnNotes/assets/ca6a27dd09f14178870960ad305ae3edtplv-k3u1fbpfcp-zoom-in-crop-mark1512000.C1zcvjG4.webp",C="/FrontEndLearnNotes/assets/763951d99b6a4ba3992415554d9fec2etplv-k3u1fbpfcp-zoom-in-crop-mark1512000.CY0KwVdp.webp",v="/FrontEndLearnNotes/assets/ca7157b11dd74f8e90dd42f9b5dd9cf4tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.BfnzJVka.webp",q="/FrontEndLearnNotes/assets/36e3b665bee04bcfbb0a20c359f76c3ctplv-k3u1fbpfcp-zoom-in-crop-mark1512000.C8tEbEEm.webp",E="/FrontEndLearnNotes/assets/66fee389dbd44c39b57d3883ec13f441tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.BlgI2kd9.webp",P="/FrontEndLearnNotes/assets/5c7ab1f18d704b9fbcebef25447cbc80tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.DcWrOb56.webp",w="/FrontEndLearnNotes/assets/30a1f85b6c474ed794feaa05d758341atplv-k3u1fbpfcp-zoom-in-crop-mark1512000.C70f_Rcx.webp",D="/FrontEndLearnNotes/assets/b2eeee2b2646477ea6806ca40e8cb1f6tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.DKllH87x.webp",x="/FrontEndLearnNotes/assets/c43bc18cf5524f659a9ecfd8f8ccd5catplv-k3u1fbpfcp-zoom-in-crop-mark1512000.CkW5dTFy.webp",N="/FrontEndLearnNotes/assets/9f49d7a510234059a036db17621e6611tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.Bj7qE5o7.webp",U="/FrontEndLearnNotes/assets/e1e2c682268d41ca8c83534fa084a99ctplv-k3u1fbpfcp-zoom-in-crop-mark1512000.BmUhI5TJ.webp",_="/FrontEndLearnNotes/assets/3a38ed59e7b0490d8cf33f1918aad2b3tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.BSz0Nxgt.webp",j="/FrontEndLearnNotes/assets/ffd33160b37145b1b88cac9291623cactplv-k3u1fbpfcp-zoom-in-crop-mark1512000.14z0DV4C.webp",L="/FrontEndLearnNotes/assets/a68dfb01459c42c6903079072272157dtplv-k3u1fbpfcp-zoom-in-crop-mark1512000.De05hVNV.webp",z="/FrontEndLearnNotes/assets/b26aa3c975264ceea6d3ed652d1c6614tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.CiZgCN1x.webp",I="/FrontEndLearnNotes/assets/dd268e0a431a4b15ae4296bfca89694atplv-k3u1fbpfcp-zoom-in-crop-mark1512000.DrlqL2tF.webp",O="/FrontEndLearnNotes/assets/e6421765e1ce4a9cb65e43d141024eb7tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.D_Yuxvjp.webp",M="/FrontEndLearnNotes/assets/3f1af8437fa94756b1b43fd6bf33b192tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.DM9gDZ9S.webp",Q="/FrontEndLearnNotes/assets/432b2dcbf38c4a8980f4870e1d6b4c9ctplv-k3u1fbpfcp-zoom-in-crop-mark1512000.DS7FQXYR.webp",S="/FrontEndLearnNotes/assets/70dc16b172314e5db51fc5d04d8a064etplv-k3u1fbpfcp-zoom-in-crop-mark1512000.C4kee7ho.webp",X="/FrontEndLearnNotes/assets/a5a6f71703a849c3a2a3b3d10f521481tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.DJMEe_yI.webp",R="/FrontEndLearnNotes/assets/0d09c18951374a87b2add0bd911adb45tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.CBffne5n.webp",J="/FrontEndLearnNotes/assets/63a6c065b6404ad7a095d76fa7427be5tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.bL26k8qP.webp",K="/FrontEndLearnNotes/assets/0a70b298461f4e84970428384a9d3e45tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.Ch9Krpjc.webp",H="/FrontEndLearnNotes/assets/ae80fe1578784a6abf0649f7e404d215tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.Bu2blo_3.webp",G="data:image/webp;base64,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",V="/FrontEndLearnNotes/assets/bc8174ebcc114535bba6c176aa994c2etplv-k3u1fbpfcp-zoom-in-crop-mark1512000.1bEp3oHv.webp",W="/FrontEndLearnNotes/assets/52b8b0a5f7a3429086355bc4d270f413tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.Cq72JLG_.webp",Y="/FrontEndLearnNotes/assets/6cd7a2957b11495c9cdb1f36fe8a6da0tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.DihWQ_O4.webp",T="/FrontEndLearnNotes/assets/efaf172946114c8eb87b30a2ea169879tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.JFV446wa.webp",Z="/FrontEndLearnNotes/assets/8bb290ae36894a6f9c1403c4957b7bc3tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.xrmRIf4V.webp",$="/FrontEndLearnNotes/assets/678a819dc59c46cba3266249aa5ba27etplv-k3u1fbpfcp-zoom-in-crop-mark1512000.Bw5gIfoS.webp",ss="/FrontEndLearnNotes/assets/d8b30ba5541246ad90018aedce215a26tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.Cu1u096Z.webp",as="/FrontEndLearnNotes/assets/5129b71fdcb34e3ab49b2de7469215batplv-k3u1fbpfcp-zoom-in-crop-mark1512000.BxAbjt1N.webp",es="/FrontEndLearnNotes/assets/68935b04dd884171a13dd36c3584b73atplv-k3u1fbpfcp-zoom-in-crop-mark1512000.CE98i6aw.webp",ns="/FrontEndLearnNotes/assets/536eb5ac39434f8b8af6854229cca78atplv-k3u1fbpfcp-zoom-in-crop-mark1512000.DQzP24T3.webp",ps="/FrontEndLearnNotes/assets/dcdfaebb040f4233be5f864b00905eaetplv-k3u1fbpfcp-zoom-in-crop-mark1512000.Dipv4hCp.webp",os="/FrontEndLearnNotes/assets/89c845739cd242ea867cdc3a519fa784tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.CWfqBt2o.webp",ls="/FrontEndLearnNotes/assets/3c4431903aa8475688e9b181938a4e85tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.Xt4t5spt.webp",cs="/FrontEndLearnNotes/assets/1321294866e34aa99674e26e8780d7e2tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.BHIaYzEO.webp",rs="/FrontEndLearnNotes/assets/c16f1c01736244a1bec1ab7f3b1f3978tplv-k3u1fbpfcp-jj-mark3024000q75.DJB-J-SB.webp",ts="/FrontEndLearnNotes/assets/0ea3acf69cb34125ae0f61613c50e553tplv-k3u1fbpfcp-jj-mark3024000q75.DDlh_obb.webp",is="/FrontEndLearnNotes/assets/7faea038ab494833a588ca532b6e4d42tplv-k3u1fbpfcp-jj-mark3024000q75.DSHrox3b.webp",ds="/FrontEndLearnNotes/assets/932ae5aa184e4686aa2d9d434abe5038tplv-k3u1fbpfcp-jj-mark3024000q75.Bzah4c3S.webp",bs="/FrontEndLearnNotes/assets/36a4740eba4c45dda1062339f4600e8ctplv-k3u1fbpfcp-jj-mark3024000q75.BRZj8CvS.webp",ms="/FrontEndLearnNotes/assets/a9bfdda7a66d4c238619fdf1479f5c2ctplv-k3u1fbpfcp-jj-mark3024000q75.Kr5SrhN3.webp",us="/FrontEndLearnNotes/assets/68933b4c3f8148c6b5a5c42900c399f2tplv-k3u1fbpfcp-jj-mark3024000q75.BcRLRLna.webp",Bs="/FrontEndLearnNotes/assets/7262a17c43ae4195b29b76c8096199b9tplv-k3u1fbpfcp-jj-mark3024000q75.DdR-tqNG.webp",fs="/FrontEndLearnNotes/assets/932ae5aa184e4686aa2d9d434abe5038tplv-k3u1fbpfcp-jj-mark3024000q75.Bzah4c3S.webp",ys="/FrontEndLearnNotes/assets/b73859406bb1444197357db1babc6c85tplv-k3u1fbpfcp-jj-mark3024000q75.Bk3WMHGB.webp",hs="/FrontEndLearnNotes/assets/0410315b30b84fd187987d2d11b4381btplv-k3u1fbpfcp-jj-mark3024000q75.CfXSrfuP.webp",Fs="/FrontEndLearnNotes/assets/feb67199687d4205b8783226bd7f07c4tplv-k3u1fbpfcp-jj-mark3024000q75.BxQkuTDq.webp",ks="/FrontEndLearnNotes/assets/8ca58c06df694487840e4cf24e184da1tplv-k3u1fbpfcp-jj-mark3024000q75.DKPEu_Vu.webp",As="/FrontEndLearnNotes/assets/21865277c5ac4a649122a267668b1099tplv-k3u1fbpfcp-jj-mark3024000q75.C-Qlfvo6.webp",gs="/FrontEndLearnNotes/assets/b5dd6fe2ff3a400f98d91cf898dd95cctplv-k3u1fbpfcp-jj-mark3024000q75.fDrqahav.webp",Cs="/FrontEndLearnNotes/assets/a9b619cf7ece4dbebfb33b57b397c37dtplv-k3u1fbpfcp-jj-mark3024000q75.KgO7Gq3s.webp",vs="/FrontEndLearnNotes/assets/701d6b60965d4da891356b225c24a3betplv-k3u1fbpfcp-jj-mark3024000q75.D2F7YknK.webp",qs="/FrontEndLearnNotes/assets/9406a97f7b0f4af8acbef0b5812d9105tplv-k3u1fbpfcp-jj-mark3024000q75.CJdZoMDw.webp",Es="/FrontEndLearnNotes/assets/e281b5991ede4013bd8a20f064df9b4etplv-k3u1fbpfcp-jj-mark3024000q75.TFgtphfn.webp",Ps="/FrontEndLearnNotes/assets/de70761254dd430ba179943d218fba53tplv-k3u1fbpfcp-jj-mark3024000q75.CKO5aSNs.webp",ws="/FrontEndLearnNotes/assets/f3cac0c14bd14e1790b70d7198936411tplv-k3u1fbpfcp-jj-mark3024000q75.Sac0Hgb7.webp",Ds="/FrontEndLearnNotes/assets/4940c1b91190436cbf9d13a1af1dd6d6tplv-k3u1fbpfcp-jj-mark3024000q75.CwtHTWeD.webp",xs="/FrontEndLearnNotes/assets/f4dff6e74f20405dadaaf7c3317ddc11tplv-k3u1fbpfcp-jj-mark3024000q75.zJe1imAk.webp",Ns="data:image/webp;base64,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",Us="data:image/webp;base64,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",_s="data:image/webp;base64,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",js="/FrontEndLearnNotes/assets/2e9ffe38bfc84f0086fd8b94021ffff5tplv-k3u1fbpfcp-jj-mark3024000q75.Dcq0qOx8.webp",Ls="/FrontEndLearnNotes/assets/06907844bd354403ababfbaeec3ea8ddtplv-k3u1fbpfcp-jj-mark3024000q75.CtBnfErG.webp",zs="/FrontEndLearnNotes/assets/b62157e47ef248cbbcf4b6108abf4fe4tplv-k3u1fbpfcp-jj-mark3024000q75.DqqH2oq0.webp",Is="/FrontEndLearnNotes/assets/a083e7243b4c494d94592f6c1a694f69tplv-k3u1fbpfcp-jj-mark3024000q75.DIHz0roL.webp",Os="/FrontEndLearnNotes/assets/385480ca5cc9400d9594845705be1d80tplv-k3u1fbpfcp-jj-mark3024000q75.q74q4dVb.webp",Ms="/FrontEndLearnNotes/assets/15de0a2275874fe7a73eb85758ffdf85tplv-k3u1fbpfcp-jj-mark3024000q75.3XRjTTsu.webp",Qs="/FrontEndLearnNotes/assets/89aebd1731474c6bb031974dea439540tplv-k3u1fbpfcp-jj-mark3024000q75.BqK65tRe.webp",Ws=JSON.parse('{"title":"操作系统知识","description":"","frontmatter":{},"headers":[],"relativePath":"Document/计算机基础/操作系统知识.md","filePath":"Document/计算机基础/操作系统知识.md","lastUpdated":1750954157000}'),Ss={name:"Document/计算机基础/操作系统知识.md"};function Xs(Rs,s,Js,Ks,Hs,Gs){return n(),e("div",null,s[0]||(s[0]=[p('<h1 id="操作系统知识" tabindex="-1">操作系统知识 <a class="header-anchor" href="#操作系统知识" aria-label="Permalink to &quot;操作系统知识&quot;">​</a></h1><h2 id="要操作系统干嘛" tabindex="-1">要操作系统干嘛？ <a class="header-anchor" href="#要操作系统干嘛" aria-label="Permalink to &quot;要操作系统干嘛？&quot;">​</a></h2><p>这里先不讲<code>操作系统</code>的概念了，因为文字太生硬了，我们只需要看一个简单的例子：</p><ul><li>在我们的 JS 代码里，只需要输入 <code>console.log(1+1)</code>; 就可以在浏览器面板中看到<code>2</code>，这其中发生了什么事情呢?(简单扫一眼)</li><li>首先键盘输入代码<code>1+1</code>到显示器输出<code>2</code>, 需要<code>CPU</code>控制键盘（输入设备） ，将获取的<code>1+1</code>指令放入内存</li><li>然后 CPU 的控制器从内存中取出指令，并分析出指令是让计算机做一个<code>1+1</code>的加法运算</li><li>此时 CPU 的控制将控制 CPU 的运算器做<code>1+1</code>的加法运算，并得出结果<code>2</code></li><li>最后 CPU 控制器控制运算器将结果返给内存，内存也在 CPU 控制器的控制下，将结果<code>2</code>返回给屏幕（输出设备）</li></ul><p>好了，这里问题是，如果没有操作系统，一个简单的 1+1 运算，你的 js 代码还需要考虑这些硬件的协调工作，比如你的代码要协调 CPU 资源什么时候读取你的代码，什么时候把进程切换到别的进程。。。这些脏活累活都是操作系统帮你屏蔽了，要不这代码可咋写啊。</p><p><img src="'+o+'" alt="img"></p><h2 id="前端学这个干嘛" tabindex="-1">前端学这个干嘛？ <a class="header-anchor" href="#前端学这个干嘛" aria-label="Permalink to &quot;前端学这个干嘛？&quot;">​</a></h2><p>很早以前看朴零大神的《深入浅出 NodeJS》的时候，讲到进程间通信，有一句大概说，windows 平台进程间通信用的是管道，linux 平台用的是 domain socket，我一看就傻眼了，啥是进程间通信？啥是管道？啥是 domain socket？😭 看不懂啊.... 这些都是跟操作系统进程的知识相关）。</p><h2 id="_2、操作系统运行机制和体系结构" tabindex="-1">2、操作系统运行机制和体系结构 <a class="header-anchor" href="#_2、操作系统运行机制和体系结构" aria-label="Permalink to &quot;2、操作系统运行机制和体系结构&quot;">​</a></h2><p>预备知识： 什么是指令（更详细内容请看我的计算机组成原理文章）</p><p>比如说，如下图（简单扫一下即可）：</p><p><img src="'+l+`" alt="img"></p><p>a+b 是一段程序代码，a+b 在 CPU 看来并不能一步完成，可以翻译成如下：</p><div class="language-css line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#ABB2BF;">// </span><span style="color:#C678DD;">意思是将内存的16号单元数据，放到A寄存器，</span></span>
<span class="line"><span style="color:#C678DD;">LOAD </span><span style="color:#E06C75;">A</span><span style="color:#ABB2BF;">,</span><span style="color:#C678DD;"> 16</span></span>
<span class="line"><span style="color:#ABB2BF;">// </span><span style="color:#C678DD;">意思是将内存的16号单元数据，放到B寄存器</span></span>
<span class="line"><span style="color:#C678DD;">LOAD </span><span style="color:#E06C75;">B</span><span style="color:#ABB2BF;">,</span><span style="color:#C678DD;"> 17</span></span>
<span class="line"><span style="color:#ABB2BF;">// </span><span style="color:#C678DD;">存器里的A</span><span style="color:#ABB2BF;">,</span><span style="color:#C678DD;">B数据相加，得到C</span></span>
<span class="line"><span style="color:#C678DD;">ADD C</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;"> A</span><span style="color:#ABB2BF;">,</span><span style="color:#E06C75;"> B</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>这里就可以看得出来，指令是<code>CPU</code>能<code>识别</code>和<code>执行</code>的最基本命令。</p><h4 id="_2-1-两种指令、两种处理器状态、两种程序" tabindex="-1">2.1 两种指令、两种处理器状态、两种程序 <a class="header-anchor" href="#_2-1-两种指令、两种处理器状态、两种程序" aria-label="Permalink to &quot;2.1 两种指令、两种处理器状态、两种程序&quot;">​</a></h4><p>假如说一个用户可以随意把服务器上的所有文件删光，这是很危险的。所以有些指令普通用户是不能使用的，只能是<code>权限较高</code>的用户能使用。此时指令就分为了两种，如下图：</p><p><img src="`+c+'" alt="img"></p><p>这就引出一个问题：CPU<code>如何判断</code>当前是否可以执行<code>特权指令</code>？ 如下图: <img src="'+r+'" alt="img"> CPU 通常有两种工作模式即：<code>内核态</code>和<code>用户态</code>，而在 PSW（这个不用管，就知道有一个寄存器的标志位 0 表示用户态，1 表示核心态）中有一个二进制位控制这两种模式。</p><p>对于应用程序而言，有的程序能执行特权指令，有的程序只能执行非特权指令。所以操作系统里的程序又分为两种：</p><p><img src="'+t+'" alt="img"></p><h4 id="_2-2-操作系统内核简单介绍" tabindex="-1">2.2 操作系统内核简单介绍 <a class="header-anchor" href="#_2-2-操作系统内核简单介绍" aria-label="Permalink to &quot;2.2 操作系统内核简单介绍&quot;">​</a></h4><p>从下图，我们先看看操作系统内核包含哪些</p><p><img src="'+i+'" alt="img"></p><p>操作系统内核中跟硬件紧密相关的部分有：</p><ul><li>时钟管理。操作系统的时钟管理是依靠<code>硬件定时器</code>的（具体硬件怎么实现我也不太清楚，好像是靠硬件周期性的产生一个脉冲信号实现的）。时钟管理相当重要，比如我们<code>获取时间信息</code>，<code>进程切换</code>等等都是要依靠时钟管理。</li><li>中断处理（下一小节会详细介绍）。</li><li>原语（后面会有案例提到）。现在可以简单理解为用来实现某个特定功能，在执行过程中<code>不可被中断</code>的指令集合。原语有一个非常重要的特性，就是原子性（其运行<code>一气呵成，不可中断</code>）。</li></ul><h4 id="_2-3-中断" tabindex="-1">2.3 中断 <a class="header-anchor" href="#_2-3-中断" aria-label="Permalink to &quot;2.3 中断&quot;">​</a></h4><ul><li>在程序运行过程中，系统出现了一个必须由 CPU 立即处理的情况，此时，CPU<code>暂时中止程序的执行</code>转而<code>处理这个新的情况</code>的过程就叫做<code>中断</code>。 下面举一个例子：</li></ul><p><img src="'+d+'" alt="img"> 第一个应用程序在用户态执行了一段时间后 <img src="'+b+'" alt="img"> 接着操作系统切换到核心态，处理中断信号 <img src="'+m+'" alt="img"></p><ul><li>操作系统发现<code>中断的信号</code>是第一个程序的时间片（每个程序不能一直执行，CPU 会给每个程序一定的执行时间，这段时间就是时间片）用完了，应该换第二个应用程序执行了</li><li>切换到<code>第2个进程</code>后，操作系统会将<code>CPU</code>的<code>使用权</code>交换给第二个应用程序，接着第二个应用程序就在<code>用户态</code>下开始执行。</li><li><code>进程</code>2 需要调用<code>打印机资源</code>，这时会执行一个<code>系统调用</code>（后面会讲系统调用，这里简单理解为需要操作系统进入核心态处理的函数），让操作系统进入核心态，去调用打印机资源</li><li>打印机开始工作，<code>此时进程2</code>因为要等待打印机启动，操作系统就不等待了（等到打印机准备好了，再回来执行程序 2），直接切换到<code>第三个应用程序</code>执行</li><li>等到打印机准备好了，此时打印机通过 I/O 控制器会给操作系统发出一<code>个中断信号</code>，操作系统又进入到核心态，发现这个中断是因为<code>程序2</code>等待打印机资源，现在打印机准备好了，就切换到<code>程序2</code>，切换到<code>用户态</code>，把 CPU 给程序 2 继续执行。</li></ul><p>好了，现在可以给出一个结论，就是用户态、核心态之间的切换是怎么实现的?</p><ul><li>&quot;用户态 ---&gt; 核心态&quot;是通过中断实现的。<code>并且中断时唯一途径</code>。</li><li>&quot;核心态 ---&gt; 用户态&quot;的切换时通过执行一个特权指令，将程序状态的标志位设为用户态。</li></ul><h4 id="_2-4-中断的分类" tabindex="-1">2.4 中断的分类 <a class="header-anchor" href="#_2-4-中断的分类" aria-label="Permalink to &quot;2.4 中断的分类&quot;">​</a></h4><p>举一个例子，什么是内中断和外中断：</p><p>接着说之前的范桶同学，小时候不爱学习，每次学习着学习着突然异想天开，回过神来已经过好好长一段时间，这是<code>内部中断</code>。想着想着老师走过来，给了范捅一嘴巴，这是<code>外部中断</code>。</p><p>官方解释如下： <img src="'+u+'" alt="img"></p><ul><li>内中断常见的情况如<code>程序非法操作</code>(比如你要拿的的数据的内存地址不是内存地址，是系统无法识别的地址)，<code>地址越界</code>(比如系统给你的程序分配了一些内存，但是你访问的时候超出了你应该访问的内存范围)、<code>浮点溢出</code>(比如系统只能表示 1.1 到 5.1 的范围，你输入一个 100, 超出了计算机能处理的范围)，或者<code>异常</code>，<code>陷入trap</code>（是指应用程序请求系统调用造成的，什么是系统调用，后面小节会举例讲）。</li><li>外中断常见的情况如<code>I/O中断</code>（由 I/O 控制器产生，用于发送信号通知操作完成等信号，比如进程需要请求打印机资源，打印机有一个启动准备的过程，准备好了就会给 CPU 一个 I/O 中断，告诉它已经准备好了）、<code>时钟中断</code>（由处理器内部的计时器产生，允许操作系统以一定规程执行函数，操作系统每过大约 15ms 会进行一次线程调度，就是利用时钟中断来实现的）。</li></ul><h4 id="_2-5-系统调用" tabindex="-1">2.5 系统调用 <a class="header-anchor" href="#_2-5-系统调用" aria-label="Permalink to &quot;2.5 系统调用&quot;">​</a></h4><blockquote><p>为什么需要系统调用？</p></blockquote><ul><li>比如你的程序需要<code>读取文件信息</code>，可读取文件属于<code>读取硬盘里的数</code>据，这个操作应该时 CPU 在<code>内核态</code>去完成的，我们的应用程序怎么让 CPU 去帮助我们切换到内核态完成这个工作呢，这里就需要<code>系统调用了</code>。</li><li>这里就引出系统调用的概念和作用。</li><li>应用程序<code>通过系统调用请求操作系统的服务</code>。系统中的各种共享资源都由操作系统统一管理，因此在用户程序中，凡是与<code>资源有关的操作</code>（如存储分配、I/O 操作、文件管理等），都<code>必须</code>通过系统调用的方式向操作系统提出服务请求，由操作系统代为完成。</li></ul><p>以下内容简单看一下即可，系统调用的分类：</p><p><img src="'+B+`" alt="img"></p><p>需要注意的是，<code>库函数</code>和<code>系统调用</code>容易混淆。</p><ul><li>库是可重用的模块 <code>处于用户态</code></li><li>进程通过系统调用从用户态进入<code>内核态</code>， 库函数中有很大部分是对系统调用的封装</li></ul><p>举个例子：比如<code>windows</code>和<code>linux</code>中，创建进程的系统调用方法是不一样的。 但在 node 中的只需要调用相同函数方法就可以创建一个进程。例如</p><div class="language-javascript line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#7F848E;font-style:italic;">// 引入创建子进程的模块</span></span>
<span class="line"><span style="color:#C678DD;">const</span><span style="color:#E5C07B;"> childProcess</span><span style="color:#56B6C2;"> =</span><span style="color:#61AFEF;"> require</span><span style="color:#ABB2BF;">(</span><span style="color:#98C379;">&quot;child_process&quot;</span><span style="color:#ABB2BF;">);</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">// 获取cpu的数量</span></span>
<span class="line"><span style="color:#C678DD;">const</span><span style="color:#E5C07B;"> cpuNum</span><span style="color:#56B6C2;"> =</span><span style="color:#61AFEF;"> require</span><span style="color:#ABB2BF;">(</span><span style="color:#98C379;">&quot;os&quot;</span><span style="color:#ABB2BF;">).</span><span style="color:#61AFEF;">cpus</span><span style="color:#ABB2BF;">().</span><span style="color:#E06C75;">length</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">// 创建与cpu数量一样的子进程</span></span>
<span class="line"><span style="color:#C678DD;">for</span><span style="color:#ABB2BF;"> (</span><span style="color:#C678DD;">let</span><span style="color:#E06C75;"> i</span><span style="color:#56B6C2;"> =</span><span style="color:#D19A66;"> 0</span><span style="color:#ABB2BF;">; </span><span style="color:#E06C75;">i</span><span style="color:#56B6C2;"> &lt;</span><span style="color:#E06C75;"> cpuNum</span><span style="color:#ABB2BF;">; </span><span style="color:#56B6C2;">++</span><span style="color:#E06C75;">i</span><span style="color:#ABB2BF;">) {</span></span>
<span class="line"><span style="color:#E5C07B;">	childProcess</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">fork</span><span style="color:#ABB2BF;">(</span><span style="color:#98C379;">&quot;./worker.js&quot;</span><span style="color:#ABB2BF;">);</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h4 id="_2-6-进程的定义、组成、组织方式、状态与转换" tabindex="-1">2.6 进程的定义、组成、组织方式、状态与转换 <a class="header-anchor" href="#_2-6-进程的定义、组成、组织方式、状态与转换" aria-label="Permalink to &quot;2.6 进程的定义、组成、组织方式、状态与转换&quot;">​</a></h4><h5 id="_2-6-1-为什么要引入进程的概念呢" tabindex="-1">2.6.1 为什么要引入进程的概念呢？ <a class="header-anchor" href="#_2-6-1-为什么要引入进程的概念呢" aria-label="Permalink to &quot;2.6.1 为什么要引入进程的概念呢？&quot;">​</a></h5><ul><li>早期的计算机只支持<code>单道程序</code>（是指所有进程一个一个排队执行，A 进程执行时，CPU、内存、I/O 设备全是 A 进程控制的，等 A 进程执行完了，才换 B 进程，然后对应的资源比如 CPU、内存这些才能换 B 用）。 <img src="`+f+'" alt="img"></li><li>现代计算机是<code>多道程序</code>执行，就是同时看起来有多个程序在一起执行，那每个程序执行都需要系统分配给它资源来执行，比如<code>CPU</code>、<code>内存</code>。</li><li>拿内存来说，操作系统要知道给 A 程序分配的内存有哪些，给 B 程序分配的内存有哪些，这些都要有小本本记录下来，这个小本本就是进程的一部分，进程的一大职责就是<code>记录目前程序运行的状态</code>。</li><li>系统为每个运行的程序配置一个数据结构，称为<code>进程控制块</code>（PCB），用来描述进程的各种信息（比如代码段放在哪）。</li></ul><h5 id="_2-6-2-进程的定义" tabindex="-1">2.6.2 进程的定义？ <a class="header-anchor" href="#_2-6-2-进程的定义" aria-label="Permalink to &quot;2.6.2 进程的定义？&quot;">​</a></h5><p>简要的说，进程就是具有<code>独立功能的程序</code>在数据集合上<code>运行的过程</code>。(强调动态性)</p><h5 id="_2-6-3-pcb-有哪些组成" tabindex="-1">2.6.3 PCB 有哪些组成 <a class="header-anchor" href="#_2-6-3-pcb-有哪些组成" aria-label="Permalink to &quot;2.6.3 PCB 有哪些组成&quot;">​</a></h5><p>如下图，分别说明一下 <img src="'+y+'" alt="img"></p><ul><li><code>进程标识符PID</code>相当于身份证。是在进程被创建时，操作系统会为该进程分配一个唯一的、不重复的 ID，<code>用于区分不同的进程</code>。</li><li>用户标识符<code>UID</code>用来表示这个进程<code>所属的用户</code>是谁。</li><li>进程当前状态和优先级下一小节会详细介绍</li><li>程序段指针是指当前进程的程序在<code>内存的什么地方</code>。</li><li>数据段指针是指当前进程的数据在<code>内存的什么地方</code>。</li><li>键盘和鼠标是指进程被<code>分配得到的I/O设备</code>。</li><li>各种寄存器值是指比如把程序计数器的值，比如有些计算的结果算到一半，进程切换时需要把这些值保存下来。</li></ul><h5 id="_2-6-4-进程的组织" tabindex="-1">2.6.4 进程的组织 <a class="header-anchor" href="#_2-6-4-进程的组织" aria-label="Permalink to &quot;2.6.4 进程的组织&quot;">​</a></h5><p>在一个系统中，通常由数十、数百乃至数千个<code>PCB</code>。为了对他们加以有效的管理，应该用适当的方式把这些 PCB 组织起来。这里介绍一种组织方式，类似数据结构里的链表。</p><p><img src="'+h+'" alt="img"></p><h5 id="_2-6-5-进程的状态" tabindex="-1">2.6.5 进程的状态 <a class="header-anchor" href="#_2-6-5-进程的状态" aria-label="Permalink to &quot;2.6.5 进程的状态&quot;">​</a></h5><p><code>进程是程序的一次执行。</code>在这个执行过程中，有时进程正在<code>被CPU处理</code>，有时又需要<code>等待CPU服务</code>，可见，进程的 状态是会有各种变化。为了方便对各个进程的管理，操作系统需要将进程合理地划分为几种状态。</p><p>进程的三种基本状态：</p><p><img src="'+F+'" alt="img"></p><p>进程的另外两种状态：</p><p><img src="'+k+'" alt="img"></p><h5 id="_2-6-6-进程状态的转换" tabindex="-1">2.6.6 进程状态的转换 <a class="header-anchor" href="#_2-6-6-进程状态的转换" aria-label="Permalink to &quot;2.6.6 进程状态的转换&quot;">​</a></h5><p>进程的状态并不是一成不变的，在一定情况下会动态转换。</p><p><img src="'+A+'" alt="img"></p><p>以上的这些进程状态的转换是如何实现的呢，这就要引出下一个角色了，叫`原语。</p><ul><li>原语是<code>不可被中断</code>的原子操作。我们举一个例子看看原语是怎么保证不可中断的。</li></ul><p><img src="'+g+'" alt="img"> 原语采用<code>关中断指令</code>和<code>开中断指令</code>实现。</p><ul><li>首先执行关中断指令</li><li>然后外部来了中断信号，不予以处理</li><li>等到开中断指令执行后，其他中断信号才有机会处理。</li></ul><h4 id="_2-6-进程的通信" tabindex="-1">2.6 进程的通信 <a class="header-anchor" href="#_2-6-进程的通信" aria-label="Permalink to &quot;2.6 进程的通信&quot;">​</a></h4><blockquote><p>为什么需要进程间通信呢？</p></blockquote><p>因为进程是<code>分配系统资源的单位</code>（包括内存地址空间），因此各进程拥有的内存地址空间相互独立。</p><p><img src="'+C+'" alt="img"></p><h5 id="_2-6-1-进程通信方法-共享存储" tabindex="-1">2.6.1 进程通信方法---共享存储 <a class="header-anchor" href="#_2-6-1-进程通信方法-共享存储" aria-label="Permalink to &quot;2.6.1 进程通信方法---共享存储&quot;">​</a></h5><p>因为两个进程的存储空间<code>不能相互访问</code>，所以操作系统就提供的一个内存空间让彼此都能访问，这就是共享存储的原理。 <img src="'+v+'" alt="img"></p><p>其中，介绍一下基于存储区的共享。</p><ul><li>在内存中画出一块<code>共享存储区</code>，数据的形式、存放位置都是由进程控制，而不是操作系统。</li></ul><h5 id="_2-6-2-进程通信方法-管道" tabindex="-1">2.6.2 进程通信方法---管道 <a class="header-anchor" href="#_2-6-2-进程通信方法-管道" aria-label="Permalink to &quot;2.6.2 进程通信方法---管道&quot;">​</a></h5><p><img src="'+q+'" alt="img"></p><ul><li>管道数据是以<code>字符流</code>（注意不是字节流）的形式写入管道，当管道写满时，写进程的<code>write()</code>系统调用将被阻塞，等待读进程将数据取走。当读进程将数据全部取走后，管道变空，此时读进程的<code>read()</code>系统调用将被阻塞。</li><li>如果没写满就不允许读。如果都没空就不允许写。</li><li>数据一旦被读出，就从管道中被丢弃，这就意味着<code>读进程</code>最多只能有一个。</li></ul><h5 id="_2-6-3-进程通信方法-消息传递" tabindex="-1">2.6.3 进程通信方法---消息传递 <a class="header-anchor" href="#_2-6-3-进程通信方法-消息传递" aria-label="Permalink to &quot;2.6.3 进程通信方法---消息传递&quot;">​</a></h5><p>进程间的数据交换以<code>格式化的消息</code>为单位。进程通过操作系统提供的<code>&quot;发送消息/接收消息&quot;</code>两个原语进行数据交换。</p><p>其中消息是什么意思呢？就好像你发 QQ 消息，消息头的来源是你，消息体是你发的内容。如下图：</p><p><img src="'+E+'" alt="img"></p><p>接下来我们介绍一种<code>间接通信</code>的方式（很像中介者模式或者发布订阅模式）, 如下图：中介者是信箱，进程通过它来收发消息。</p><p><img src="'+P+'" alt="img"></p><h4 id="_2-7-线程" tabindex="-1">2.7 线程 <a class="header-anchor" href="#_2-7-线程" aria-label="Permalink to &quot;2.7 线程&quot;">​</a></h4><blockquote><p>为什么要引入线程呢？</p></blockquote><ul><li>比如你在玩 QQ 的时候，QQ 是一个进程，如果 QQ 的进程里没有多线程并发，那么 QQ 进程就只能<code>同一时间做一件事情</code>（比如 QQ 打字聊天）</li><li>但是我们真实的场景是 QQ 聊天的同时，还可以发文件，还可以视频聊天，这说明如果 QQ<code>没有多线程并发能力</code>，QQ 能够的实用性就大大降低了。所以我们<code>需要线程</code>，也就是<code>需要进程拥有能够并发</code>多个事件的能力。</li></ul><p><img src="'+w+'" alt="img"></p><p>引入线程后带来的变化 <img src="'+D+'" alt="img"></p><h2 id="_3-进程的同步和互斥" tabindex="-1">3 进程的同步和互斥 <a class="header-anchor" href="#_3-进程的同步和互斥" aria-label="Permalink to &quot;3 进程的同步和互斥&quot;">​</a></h2><blockquote><p>同步。是指多个进程中发生的事件存在某种先后顺序。即某些进程的执行必须先于另一些进程。</p></blockquote><p>比如说<code>进程A</code>需要从缓冲区读取<code>进程B</code>产生的信息，当缓冲区为空时，<code>进程B</code>因为读取不到信息而被阻塞。而当<code>进程A</code>产生信息放入缓冲区时，<code>进程B</code>才会被唤醒。概念如图 1 所示。 <img src="'+x+'" alt="img"></p><blockquote><p>互斥。是指多个进程不允许同时使用同一资源。当某个进程使用某种资源的时候，其他进程必须等待。</p></blockquote><p>比如<code>进程B</code>需要访问打印机，但此时<code>进程A</code>占有了打印机，<code>进程B</code>会被阻塞，直到<code>进程A</code>释放了打印机资源,进程 B 才可以继续执行。概念如图 3 所示。 <img src="'+N+`" alt="img"></p><h4 id="_3-1-信号量-了解概念即可" tabindex="-1">3.1 信号量（了解概念即可） <a class="header-anchor" href="#_3-1-信号量-了解概念即可" aria-label="Permalink to &quot;3.1 信号量（了解概念即可）&quot;">​</a></h4><p><code>信号量</code>主要是来解决进程的<code>同步</code>和<code>互斥</code>的，我们前端需要了解，如果涉及到同步和互斥的关系（我们编程大多数关于流程的逻辑问题，本质不就是同步和互斥吗？）</p><p>在操作系统中，常用<code>P、V信号量</code>来实现进程间的<code>同步</code>和<code>互斥</code>，我们简单了解一下一种常用的信号量，<code>记录型信号量</code>来简单了解一下信号量本质是怎样的。（c 语言来表示，会有备注）</p><div class="language-C line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">C</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#7F848E;font-style:italic;">/*记录型信号量的定义*/</span></span>
<span class="line"><span style="color:#C678DD;">typedef</span><span style="color:#C678DD;"> struct</span><span style="color:#ABB2BF;"> {</span></span>
<span class="line"><span style="color:#C678DD;">    int</span><span style="color:#ABB2BF;"> value;</span><span style="color:#7F848E;font-style:italic;"> // 剩余资源</span></span>
<span class="line"><span style="color:#ABB2BF;">    Struct process </span><span style="color:#C678DD;">*</span><span style="color:#ABB2BF;">L</span><span style="color:#7F848E;font-style:italic;"> // 等待队列</span></span>
<span class="line"><span style="color:#ABB2BF;">} semaphore</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>意思是信号量的结构有两部分组成，<code>一部分是剩余资源value</code>，比如目前有两台打印机空闲，那么剩余资源就是 2，谁正在使用打印机，剩余资源就减 1。</p><p><code>Struct process *L </code>意思是，比如 2 台打印机都有人在用，这时候你的要用打印机，此时会把这个打印机资源的请求放入阻塞队列，L 就是阻塞队列的地址。</p><div class="language-c line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#7F848E;font-style:italic;">/*P 操作，也就是记录型信号量的请求资源操作*/</span></span>
<span class="line"><span style="color:#C678DD;">void</span><span style="color:#61AFEF;"> wait</span><span style="color:#ABB2BF;"> (</span><span style="color:#E06C75;">semaphore </span><span style="color:#E06C75;font-style:italic;">S</span><span style="color:#ABB2BF;">) {</span></span>
<span class="line"><span style="color:#E5C07B;">    S</span><span style="color:#ABB2BF;">.</span><span style="color:#E06C75;">value</span><span style="color:#C678DD;">--</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#C678DD;">    if</span><span style="color:#ABB2BF;"> (</span><span style="color:#E5C07B;">S</span><span style="color:#ABB2BF;">.</span><span style="color:#E06C75;">value</span><span style="color:#C678DD;"> &lt;</span><span style="color:#D19A66;"> 0</span><span style="color:#ABB2BF;">){</span></span>
<span class="line"><span style="color:#61AFEF;">        block</span><span style="color:#ABB2BF;"> (</span><span style="color:#E5C07B;">S</span><span style="color:#ABB2BF;">.</span><span style="color:#E06C75;">L</span><span style="color:#ABB2BF;">);</span></span>
<span class="line"><span style="color:#ABB2BF;">    }</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>需要注意的是，如果剩余资源数不够，使用 block 原语使进程从运行态进入阻塞态，并把挂到信号量 S 的等待队列中。</p><div class="language-c line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#7F848E;font-style:italic;">/*V 操作，也就是记录型信号量的释放资源操作*/</span></span>
<span class="line"><span style="color:#C678DD;">void</span><span style="color:#61AFEF;"> singal</span><span style="color:#ABB2BF;"> (</span><span style="color:#E06C75;">semaphore </span><span style="color:#E06C75;font-style:italic;">S</span><span style="color:#ABB2BF;">) {</span></span>
<span class="line"><span style="color:#E5C07B;">    S</span><span style="color:#ABB2BF;">.</span><span style="color:#E06C75;">value</span><span style="color:#C678DD;">++</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#C678DD;">    if</span><span style="color:#ABB2BF;"> (</span><span style="color:#E5C07B;">S</span><span style="color:#ABB2BF;">.</span><span style="color:#E06C75;">value</span><span style="color:#C678DD;"> &lt;=</span><span style="color:#D19A66;"> 0</span><span style="color:#ABB2BF;">){</span></span>
<span class="line"><span style="color:#61AFEF;">        wakeup</span><span style="color:#ABB2BF;"> (</span><span style="color:#E5C07B;">S</span><span style="color:#ABB2BF;">.</span><span style="color:#E06C75;">L</span><span style="color:#ABB2BF;">);</span></span>
<span class="line"><span style="color:#ABB2BF;">    }</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>释放资源后，若还有别的进程在等待这个资源，比如打印机资源，则使用 wakeup 原语唤醒等待队列中的一个进程，该进程从阻塞态变为继续态。</p><h4 id="_3-2-生产者消费者问题-了解概念即可" tabindex="-1">3.2 生产者消费者问题（了解概念即可） <a class="header-anchor" href="#_3-2-生产者消费者问题-了解概念即可" aria-label="Permalink to &quot;3.2 生产者消费者问题（了解概念即可）&quot;">​</a></h4><p>为什么要讲这个呢，主要是 node 的流的机制，本质就是生产者消费者问题，可以简单的看看这个问题如何解决。</p><p><img src="`+U+`" alt="img"> 如上图，<code>生产者</code>的主要作用是生成<code>一定量的数据放到缓冲区中</code>，然后<code>重复此过程</code>。与此同时，消费者也在<code>缓冲区消耗这些数据</code>。该问题的关键就是要保证生产者不会在缓冲区满时加入数据，消费者也不会在缓冲区中空时消耗数据。</p><p>这里我们需要两个同步信号量和一个互斥信号量</p><div class="language-c line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#7F848E;font-style:italic;">// 互斥信号量，实现对缓冲区的互斥访问</span></span>
<span class="line"><span style="color:#ABB2BF;">semaphore mutex </span><span style="color:#C678DD;">=</span><span style="color:#D19A66;"> 1</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">// 同步信号量，表示目前还可以生产几个产品</span></span>
<span class="line"><span style="color:#ABB2BF;">semaphore empty </span><span style="color:#C678DD;">=</span><span style="color:#ABB2BF;"> n;</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">// 同步信号量，表示目前可以消耗几个产品</span></span>
<span class="line"><span style="color:#ABB2BF;">semaphore full </span><span style="color:#C678DD;">=</span><span style="color:#D19A66;"> 0</span><span style="color:#ABB2BF;">;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>生产者代码如下</p><div class="language-c line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#61AFEF;">producer</span><span style="color:#ABB2BF;"> () {</span></span>
<span class="line"><span style="color:#C678DD;">    while</span><span style="color:#ABB2BF;">(</span><span style="color:#D19A66;">1</span><span style="color:#ABB2BF;">) {</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">        // 生产一个产品</span></span>
<span class="line"><span style="color:#61AFEF;">        P</span><span style="color:#ABB2BF;">(empty);</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">        // 对缓冲区加锁</span></span>
<span class="line"><span style="color:#61AFEF;">        P</span><span style="color:#ABB2BF;">(mutex);</span></span>
<span class="line"><span style="color:#ABB2BF;">        这里的代码是生产一个产品</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">        // 解锁</span></span>
<span class="line"><span style="color:#61AFEF;">        V</span><span style="color:#ABB2BF;">(mutex);</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">        // 产出一个产品</span></span>
<span class="line"><span style="color:#61AFEF;">        V</span><span style="color:#ABB2BF;">(full);</span></span>
<span class="line"><span style="color:#ABB2BF;">    }</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>消费者代码如下</p><div class="language-c line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#61AFEF;">producer</span><span style="color:#ABB2BF;"> () {</span></span>
<span class="line"><span style="color:#C678DD;">    while</span><span style="color:#ABB2BF;">(</span><span style="color:#D19A66;">1</span><span style="color:#ABB2BF;">) {</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">        // 消费一个产品</span></span>
<span class="line"><span style="color:#61AFEF;">        P</span><span style="color:#ABB2BF;">(full);</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">        // 对缓冲区加锁</span></span>
<span class="line"><span style="color:#61AFEF;">        P</span><span style="color:#ABB2BF;">(mutex);</span></span>
<span class="line"><span style="color:#ABB2BF;">        这里的代码是消费一个产品</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">        // 解锁</span></span>
<span class="line"><span style="color:#61AFEF;">        V</span><span style="color:#ABB2BF;">(mutex);</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">        // 消费一个产品</span></span>
<span class="line"><span style="color:#61AFEF;">        V</span><span style="color:#ABB2BF;">(empty);</span></span>
<span class="line"><span style="color:#ABB2BF;">    }</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h2 id="_4-内存的基础知识和概念" tabindex="-1">4 内存的基础知识和概念 <a class="header-anchor" href="#_4-内存的基础知识和概念" aria-label="Permalink to &quot;4 内存的基础知识和概念&quot;">​</a></h2><blockquote><p>为什么需要内存</p></blockquote><p>内存是计算机<code>其它硬件设备</code>与<code>CPU沟通</code>的桥梁、中转站。程序执行前需要先放到内存中才能被 CPU 处理。</p><h4 id="_4-1-cpu-如何区分执行程序的数据在内存的什么地方" tabindex="-1">4.1 cpu 如何区分执行程序的数据在内存的什么地方 <a class="header-anchor" href="#_4-1-cpu-如何区分执行程序的数据在内存的什么地方" aria-label="Permalink to &quot;4.1 cpu 如何区分执行程序的数据在内存的什么地方&quot;">​</a></h4><ul><li>是通过给<code>内存的存储单元编址</code>实现的。（存储单元一般是以字节为单位）</li><li>如下图，内存的存储单元，就像一个酒店的房间，都有编号，比如程序一的数据都在 1 楼，1 楼 1 号存储着程序里<code>let a = 1</code>这段代码。</li></ul><p><img src="`+_+'" alt="img"></p><h4 id="_4-2-内存管理-内存空间的分配与回收" tabindex="-1">4.2 内存管理-内存空间的分配与回收 <a class="header-anchor" href="#_4-2-内存管理-内存空间的分配与回收" aria-label="Permalink to &quot;4.2 内存管理-内存空间的分配与回收&quot;">​</a></h4><ul><li>内存分配分为<code>连续分配</code>和<code>非连续分配</code>，连续分配是指用户进程分配的必须是<code>一个连续的内存空间</code>。</li><li>这里我们只讲连续分配中的<code>动态分区分配</code>。</li><li>什么是动态分区分配呢，这种分配方式<code>不会预先划分内存分区</code>，而是在进程装入内存时，根据进程的大小<code>动态地</code>建立分区，并使分区的大小<code>正好适合</code>进程的需要。（比如，某计算机内存大小 64MB，系统区 8MB，用户区 56MB...，现在我们有几个进程要装入内存，如下图）</li></ul><p><img src="'+j+'" alt="img"></p><ul><li>随之而来的问题就是，如果此时进程 1 使用完了，相应在内存上的数据也被删除了，那么<code>空闲的区域</code>，后面该怎么分配（也就是说随着进程退出，会有很多空闲的内存区域出现）</li></ul><p>我们讲一种较为简单的处理方法叫<code>空闲分区表</code>法来解决这个问题。如下图，右侧的表格就是一个空闲分区表。</p><p><img src="'+L+'" alt="img"></p><p>当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配呢，例如下图，分别有<code>20MB</code>，<code>10MB</code>，<code>4MB</code>三个空闲分区块，现在<code>进程5</code>需要<code>4MB</code>空闲分区，改怎么分配呢？</p><p>我们需要按照一定的动态分区分配算法，比如有<code>首次适应算法</code>，指的是每次都从低地址开始查找，找到第一个能满足大小的空闲分区。还有比如<code>最佳适应算法</code>，指的是从空闲分区表中找到最小的适合分配的分区块来满足需求。</p><p><img src="'+z+'" alt="img"></p><p><code>连续分配缺点很明显</code>，大多数情况，需要分配的进程大小，不能跟空闲分区剩下的大小完全一样，这样就产生很多很难利用的<code>内存碎片</code>。</p><p>这里我们介绍一种更好的空闲分区的分配方法，<code>基本分页存储</code>。如下图</p><p><img src="'+I+'" alt="img"> 将内存空间分为<code>一个个大小相等</code>的分区（比如：每个分区<code>4KB</code>）.每个分区就是一个<code>“页框”</code>。页框号从<code>0</code>开始。</p><p>将用户进程的地址空间分为与页框大小相等的一个个区域，称为<code>“页”</code>。每个页也是从<code>0</code>开始。</p><h2 id="_5-文件管理" tabindex="-1">5 文件管理 <a class="header-anchor" href="#_5-文件管理" aria-label="Permalink to &quot;5 文件管理&quot;">​</a></h2><blockquote><p>文件是什么？</p></blockquote><p>文件就是一组有意义的<code>信息/数据</code>集合。</p><p>计算机中存放了各种各样的文件，一个文件有哪些属性呢？文件内部的数据应该怎样组织起来？文件之间又该怎么组织起来？</p><h4 id="_5-1-文件的属性" tabindex="-1">5.1 文件的属性 <a class="header-anchor" href="#_5-1-文件的属性" aria-label="Permalink to &quot;5.1 文件的属性&quot;">​</a></h4><p><img src="'+O+'" alt="img"></p><ul><li>文件名。即文件的名字，需要注意的是，同一目录下<code>不允许</code>有重名的文件。</li><li>标识符。操作系统用于区分各个文件的一种<code>内部的名称</code>。</li><li>类型。文件的类型。</li><li>位置。文件<code>存放的路径</code>，同时也是在硬盘里的位置（需要转换成物理硬盘上的地址）</li><li>创建时间、上次修改时间、文件所有者就是字面意思。</li><li>保护信息。比如对这个文件的<code>执行权限</code>，是否有删除文件权限，修改文件权限等等。</li></ul><h4 id="_5-2-文件内部数据如何组织在一起" tabindex="-1">5.2 文件内部数据如何组织在一起 <a class="header-anchor" href="#_5-2-文件内部数据如何组织在一起" aria-label="Permalink to &quot;5.2 文件内部数据如何组织在一起&quot;">​</a></h4><p>如下图，文件主要分为<code>有结构文件</code>和<code>无结构文件</code>。</p><p><img src="'+M+'" alt="img"></p><h4 id="_5-3-文件之间如何组织起来" tabindex="-1">5.3 文件之间如何组织起来 <a class="header-anchor" href="#_5-3-文件之间如何组织起来" aria-label="Permalink to &quot;5.3 文件之间如何组织起来&quot;">​</a></h4><p>通过<code>树状结构</code>组织的。例如<code>windows</code>的文件间的组织关系如下：</p><p><img src="'+Q+'" alt="img"></p><p>接下来我们详细的了解一下<code>文件的逻辑结构</code></p><h4 id="_5-4-文件的逻辑结构" tabindex="-1">5.4 文件的逻辑结构 <a class="header-anchor" href="#_5-4-文件的逻辑结构" aria-label="Permalink to &quot;5.4 文件的逻辑结构&quot;">​</a></h4><p>逻辑结构是指，在用户看来，文件内部的数据是如何组织起来的，而<code>“物理结构”</code>是在操作系统看来，文件是如何保存在外存，比如<code>硬盘</code>中的。</p><p><img src="'+S+'" alt="img"></p><p>比如，<code>“线性表”</code>就是一种逻辑结构，在用户看来，线性表就是一组有先后关系的元素序列，如：<code>a,b,c,d,e....</code></p><ul><li><code>“线性表”</code>这种逻辑结构可以用不同的物理结构实现，比如：<code>顺序表/链表</code>。<code>顺序表</code>的各个元素在逻辑上相邻，在物理上也相邻：而<code>链表</code>的各个元素在物理上可以是不相邻的。</li><li>因此，顺序表可以实现<code>“随机访问”</code>，而<code>“链表”</code>无法实现随机访问。</li></ul><p>接下来我了解一下有结构文件的三种逻辑结构</p><h5 id="_5-4-1-顺序文件" tabindex="-1">5.4.1 顺序文件 <a class="header-anchor" href="#_5-4-1-顺序文件" aria-label="Permalink to &quot;5.4.1 顺序文件&quot;">​</a></h5><blockquote><p>什么是顺序文件</p></blockquote><p>指的是文件中的记录一个接一个地在逻辑上是<code>顺序排列</code>，记录可以是<code>定长</code>或<code>变长</code>，各个记录在物理上可以<code>顺序存储</code>或<code>链式存储</code></p><p><img src="'+X+'" alt="img"></p><ul><li>顺序文件按结构来划分，可以分为<code>串结构</code>和<code>顺序结构</code>。</li><li>串结构是指记录之间的顺序与<code>关键字无关</code>，通常都是按照记录的时间决定记录的顺序。</li><li>顺序结构就必须保证记录之间的先后顺序按<code>关键字排列</code>。</li></ul><p>这里需要注意的知识点是，顺序文件的存储方式和是否<code>按关键字排列</code>，会影响数据<code>是否支持随机存取</code>和<code>是否可以快速按关键字找到对应记录</code>的功能。</p><p>可以看到，顺序文件按顺序存放对于查找是非常有帮助的，我们在记录文件的时候也可以注意利用这一点。</p><p><img src="'+R+'" alt="img"></p><h5 id="_5-4-2-索引文件" tabindex="-1">5.4.2 索引文件 <a class="header-anchor" href="#_5-4-2-索引文件" aria-label="Permalink to &quot;5.4.2 索引文件&quot;">​</a></h5><p>对于<code>可变长记录文件</code>，要找到<code>第i</code>个记录，必须先顺序查找<code>前i-1</code>个记录（也就是需要遍历一遍），但是很多场景中又必须使用可变长记录，如何解决这个问题呢？这就引出来马上讲的<code>索引文件</code></p><p><img src="'+J+'" alt="img"></p><ul><li>给这些变长的记录都用一张索引表来记录，一个索引表项包括了<code>索引号</code>，<code>长度</code>和<code>指针</code>。</li><li>其中，可以将关键字作为索引号的内容，如果关键字本身的排列是有序的，那么还可以按照关键字进行折半查找。这里是关键，因为我们平时用 mysql 数据库对某个字段假如索引，就是这个道理。</li><li>但是建立索引表的问题也很明显，首先若要<code>删除/增加</code>一个记录，同时也要对<code>索引表</code>操作，其次，如果<code>增加一条记录才1KB</code>，但是索引表<code>增加i一条记录可能有8KB</code>，以至于索引表的体积大大多于记录。存储空间的利用率就比较低。</li></ul><h5 id="_5-4-3-索引顺序文件" tabindex="-1">5.4.3 索引顺序文件 <a class="header-anchor" href="#_5-4-3-索引顺序文件" aria-label="Permalink to &quot;5.4.3 索引顺序文件&quot;">​</a></h5><p>索引顺序文件是<code>索引文件</code>和<code>顺序文件</code>思想的结合。索引顺序文件中，同样会为文件建立一张索引表，但不同的是，并不是每个记录对应一个<code>索引表项</code>，而是一组记录对应一个索引表项。</p><p><img src="'+K+'" alt="img"></p><p>如上图，学生记录按照学生姓名的开头字母进行分组。每个分组就是一个顺序文件，分组内的记录不需要按关键字排序</p><h4 id="_5-5-文件目录" tabindex="-1">5.5 文件目录 <a class="header-anchor" href="#_5-5-文件目录" aria-label="Permalink to &quot;5.5 文件目录&quot;">​</a></h4><p>首先，我们需要了解一下<code>文件控制</code>块是什么。我们假设目前在<code>windows的D盘</code>，如下图</p><p><img src="'+H+'" alt="img"></p><p>可以看到，目录本身就是一种<code>有结构的文件</code>，记录了目录里的<code>文件</code>和<code>目录</code>的信息，比如名称和类型。而这些一条条的记录就是一个个的<code>“文件控制块”（FCB）</code>。</p><p>文件目录的结构通常是<code>树状的</code>，例如 linux 里<code>/</code>是指根路径，<code>/home</code>是根路径下的二级目录</p><p><img src="'+G+'" alt="img"></p><ul><li>需要注意的是，树状目录<code>不容易实现文件共享</code>，所以在树形目录结构的基础上，增加了一些指向同一节点的有向边（可以简单理解为引用关系，就跟 js 里的对象一样）</li><li>也就是说需要为<code>每个共享节点</code>设置一个<code>共享计数器</code>，用于记录此时有多少个地方在共享该结点。只有<code>共享计数器减为0</code>，才删除该节点。</li></ul><h4 id="文件分配方式-物理分配" tabindex="-1">文件分配方式（物理分配） <a class="header-anchor" href="#文件分配方式-物理分配" aria-label="Permalink to &quot;文件分配方式（物理分配）&quot;">​</a></h4><p>我们这里介绍一种索引分配的方式：</p><p>索引分配允许文件离散地分配在各个磁盘块中，系统会为每个文件建立一张索引表，索引表记录了文件各个逻辑块对应的物理块。索引表存放的磁盘块称为索引快。文件数据存放的磁盘块称为数据块。</p><p><img src="'+V+'" alt="截屏2021-07-30 上午8.48.45.png"></p><p>如上图，假设某个新创建的文件&#39;aaa&#39;的数据依次存放磁盘块 2-&gt;5-&gt;13&gt;9。7 号磁盘块作为’aaa‘的索引块，索引块保存了索引表的内容</p><h4 id="文件的逻辑分配和物理分配" tabindex="-1">文件的逻辑分配和物理分配 <a class="header-anchor" href="#文件的逻辑分配和物理分配" aria-label="Permalink to &quot;文件的逻辑分配和物理分配&quot;">​</a></h4><p>上面我们讲到了文件的逻辑分配，是站在用户视角的分配，物理分配是站在操作系统的角度的分配，分配的是实际的物理磁盘里的空间。</p><p>举个例子，我们用户看到的文件，意识里都是顺序排列的，比如说，excel 表有 100 行数据，用户看来这 100 行数据就是连续的。</p><p>在操作系统的视角，它可以把这 100 行数据分为一个个的数据块，比如跟磁盘块（假设磁盘块是 1kb 大小）一样都是 1kb，拆分后的数据可以使用索引表的形式分配（也就是我们上面才讲了的，索引分配的方式，打散分配在实际的物理磁盘里）</p><h4 id="_5-6-文件存储空间管理" tabindex="-1">5.6 文件存储空间管理 <a class="header-anchor" href="#_5-6-文件存储空间管理" aria-label="Permalink to &quot;5.6 文件存储空间管理&quot;">​</a></h4><p>首先，我们了解一下磁盘分为<code>目录区</code>和<code>文件区</code>。</p><p><img src="'+W+'" alt="img"></p><p>接着，我们了解一下常见的两种<code>文件存储空间的管理算法</code>，如下图，假如硬盘上<code>空闲的数据块</code>是蓝色，<code>非空闲的数据</code>块是橙色。</p><p><img src="'+Y+'" alt="img"></p><p>对分配连续的存储空间，可以采用<code>空闲表法</code>（只讲这种较简单的方法）来<code>分配</code>和<code>回收</code>磁盘块。对于分配，可以采用首次适应，最佳适应等算法来决定要为文件分配哪个区间。（空闲表表示如下）</p><p><img src="'+T+'" alt="img"></p><ul><li><code>首次适应</code>是指当要插入数据的时候，空闲表会依次检查空闲表中的表项，然后找到<code>第一个满足条件</code>的空闲区间。</li><li><code>最佳适应算法</code>是指当要插入数据的时候，空闲表会依次检查空闲表中的表项，然后找到<code>满足条件而且空闲块最小的空闲区间</code>。</li></ul><p>再讲一种位示图法</p><p>如下图：</p><p><img src="'+Z+'" alt="image.png"></p><p>每一个二进制位对应一个磁盘块，比如上面 0 表示空闲块，1 表示已分配的块。而且我们可以通过一定的公式，可以从示图表的横纵坐标推断出物理块的实际地址，也可以从物理块的实际地址推断出在表里的横纵坐标。</p><h4 id="_5-7-文件共享" tabindex="-1">5.7 文件共享 <a class="header-anchor" href="#_5-7-文件共享" aria-label="Permalink to &quot;5.7 文件共享&quot;">​</a></h4><p>文件共享分为两种</p><p><img src="'+$+'" alt="img"></p><ul><li>注意，多个用户<code>共享同一个文件</code>，意味着系统只有<code>“一份”</code>文件数据。并且只要某个用户修改了该文件的数据，其他用户也可以看到<code>文件的变化</code>。</li><li>软连接可以理解为<code>windows</code>里的<code>快捷方式</code>。</li><li>硬链接可以理解为 js 里的<code>引用计数</code>，只有引用为<code>0</code>的时候，才会真正删除这个文件。</li></ul><h4 id="_5-8-文件保护" tabindex="-1">5.8 文件保护 <a class="header-anchor" href="#_5-8-文件保护" aria-label="Permalink to &quot;5.8 文件保护&quot;">​</a></h4><p>操作系统需要保护文件的安全，一般有如下 3 种方式：</p><ul><li>口令保护。是指为文件设置一个<code>“口令”</code>（比如 123），用户请求访问该文件时必须提供对应的口令。口令一般放在文件对应的<code>FCB或者索引结点</code>上。</li><li>加密保护。使用某个<code>&quot;密码&quot;</code>对文件进行加密，在访问文件时需要提供<code>正确的“密码”</code>才能对文件进行正确的解密。</li><li>访问控制。在每个文件的 FCB 或者索引节点种增加一个<code>访问控制列表</code>，该表中记录了各个用户可以对该文件执行哪些操作。</li></ul><p><img src="'+ss+'" alt="img"></p><h2 id="总结文件系统这块的内容" tabindex="-1">总结文件系统这块的内容 <a class="header-anchor" href="#总结文件系统这块的内容" aria-label="Permalink to &quot;总结文件系统这块的内容&quot;">​</a></h2><p>我们举一个实际案例，把上面的内容总结一下。</p><p>假如我们当前的操作系统采用如下的文件系统管理方式：</p><ul><li>文件的物理结构 --- 索引分配（混合索引）</li><li>文件目录的实现 --- inode 结点</li><li>空闲分区管理 --- 位示图法</li></ul><p>那么我们假设 0 号磁盘块就是装载位示图的磁盘块，用来管理哪些磁盘是空闲的哪些是正在使用的。 <img src="'+as+'" alt="img"></p><p>因为这里我们已经使用了 0 号块，位示图的第一项就是 1</p><p>接着我们把磁盘块第二块用来放 inode 节点，也就是文件目录索引节点，意思是文件目录下存放的只有文件名和索引节点的位置，要知道文件的详细信息，就要靠着</p><p><img src="'+es+`" alt="img"></p><p>假设 2 号磁盘块存放了我们根目录信息，而本身目录其实也是一种特殊的文件，也在 inode 节点表里有自己的信息，1 号磁盘块增加类似如下信息：</p><div class="language-bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#61AFEF;">类型：目录</span></span>
<span class="line"><span style="color:#61AFEF;">存放在：2号磁盘块</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>2 号磁盘块里面存放了一个<code>你好.txt</code>文件，那么 2 号磁盘块会增加一行信息，类似</p><div class="language-bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#61AFEF;">文件名：你好.txt</span></span>
<span class="line"><span style="color:#61AFEF;">inode结点：2</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>这就意味着，2 号 inode 节点存放了你好.txt 文件的具体磁盘块在哪，所以在 1 号磁盘块的 2 号 inode 节点增加</p><div class="language-bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#61AFEF;">类型：txt</span></span>
<span class="line"><span style="color:#61AFEF;">存放在：3、4号磁盘块</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>为什么要放到 3、4 号磁盘块呢，因为我们有位示图，知道哪些磁盘块是空闲的就分配给它，一扫描发现 3、4 正空闲而且满足存放这个文件的条件，就分配出去了。</p><p>我们在细分一下这里的 3、4 号磁盘块是什么意思，因为我们物理磁盘块分配的方法是混合索引，其实 3、4 号磁盘块表示的形式如下：</p><div class="language-bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#61AFEF;">直接索引：3号磁盘块</span></span>
<span class="line"><span style="color:#61AFEF;">直接索引：4号磁盘块</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>上面只涉及到直接索引，我们其实还可以有 1 级索引，2 级索引，这些索引指向的是一个索引表，我们这里就不详细叙述了（之前交过索引块和索引表）。</p><p>到这里我们们就基本明白了一个文件系统的基本运行原理。</p><h3 id="_6-i-o-设备" tabindex="-1">6 I/O 设备 <a class="header-anchor" href="#_6-i-o-设备" aria-label="Permalink to &quot;6 I/O 设备&quot;">​</a></h3><blockquote><p>什么是 I/O 设备</p></blockquote><p>I/O 就是<code>输入输出</code>(Input/Output)的意思，I/O 设备就是可以将数据输入到计算机，或者可以接收计算机输出数据的外部设备，属于计算机中的硬件部件。 <img src="`+ns+'" alt="img"></p><h4 id="_6-1-i-o-设备分类-按使用特性" tabindex="-1">6.1 I/O 设备分类--按使用特性 <a class="header-anchor" href="#_6-1-i-o-设备分类-按使用特性" aria-label="Permalink to &quot;6.1 I/O 设备分类--按使用特性&quot;">​</a></h4><ul><li>人机交互类设备，这类设备传输数据的速度慢</li></ul><p><img src="'+ps+'" alt="img"></p><ul><li>存储设备，这类设备传输数据的速度较快</li></ul><p><img src="'+os+'" alt="img"></p><ul><li>网络通信设备，这类设备的传输速度介于人机交互设备和存储设备之间</li></ul><h4 id="_6-2-i-o-控制器" tabindex="-1">6.2 I/O 控制器 <a class="header-anchor" href="#_6-2-i-o-控制器" aria-label="Permalink to &quot;6.2 I/O 控制器&quot;">​</a></h4><p>CPU 无法直接控制<code>I/O设备的机械部件</code>，因此 I/O 设备还要有一个电子部件作为<code>CPU</code>和<code>I/O设备</code>机械部件之间的<code>“中介”</code>，用于实现 CPU 对设备的控制。这个电子部件就是<code>I/O控制器</code>。</p><p><img src="'+ls+'" alt="img"></p><ul><li>接收和识别 CPU 发出的指令是指，比如 CPU 发来读取文件的命令，I/O 控制器中会有相应的<code>控制寄存器</code>来存放命令和参数</li><li>向 cpu 报告设备的状态是指，I/O 控制器会有相应的<code>状态寄存器</code>，用来记录 I/O 设备<code>是否空闲</code>或者<code>忙碌</code></li><li>数据交换是指 I/O 控制器会设置相应的<code>数据寄存器</code>。输出时，数据寄存器用于<code>暂存CPU发来的数据</code>，之后再由控制器传送给设备。</li><li>地址识别是指，为了区分设备控制器中的各个寄存器中的各个寄存器，也需要给各个寄存器设置一个特性的<code>“地址”</code>。I/O 控制器通过 CPU 提供的“地址”来判断 CPU 要读写的是哪个寄存器</li></ul><h4 id="_6-3-i-o-控制方式" tabindex="-1">6.3 I/O 控制方式 <a class="header-anchor" href="#_6-3-i-o-控制方式" aria-label="Permalink to &quot;6.3 I/O 控制方式&quot;">​</a></h4><ul><li>这里我们指讲一下目前比较先进的方式，通道控制方式。</li><li>通道可以理解为一种<code>“弱鸡版CPU”</code>。通道可以识别并执行一系列通道指令。 <img src="'+cs+'" alt="img"></li></ul><p>通道最大的优点是极大的<code>减少了CPU的干预频率</code>，<code>I/O设备</code>完成任务，通道会向 CPU 发出<code>中断</code>，不需要轮询来问 I/O 设备是否完成 CPU 下达的任务。</p><p>本文完结。</p><p>预告：后面会有数据结构入门知识（常用的数据结构以及在内存的存储形式，并对比其增删改查的时间复杂度）</p><p>注： 本文绝大多数资料来源于以下的学习视频资料</p><ul><li><a href="https://www.bilibili.com/video/av6538245" target="_blank" rel="noreferrer">操作系统_清华大学（陈渝）</a></li><li><a href="https://www.bilibili.com/video/av70156862" target="_blank" rel="noreferrer">2019 王道考研 操作系统</a></li><li><a href="https://www.bilibili.com/video/av51437944" target="_blank" rel="noreferrer">操作系统（哈工大李治军老师）32 讲</a></li><li><a href="https://www.bilibili.com/video/BV147411G7zD/" target="_blank" rel="noreferrer">【Linux 操作系统】Lecture 3 Process Concept_哔哩哔哩_bilibili</a></li></ul><h1 id="第二篇" tabindex="-1">第二篇 <a class="header-anchor" href="#第二篇" aria-label="Permalink to &quot;第二篇&quot;">​</a></h1><p>在 k8s 和 devops 上有大的突破，其中需要对操作系统知识需要有一些更深入的学习。</p><p>实际上，你如果能像本文一样，对操作系统讲的一些基础知识能串在一起，有自己的理解，而不是死记硬背，最终，形成一个基本的知识体系。</p><p>这不仅仅对写前端代码运行有帮助，更对你后续学习 nodejs（例如服务端对内存管理很敏感，你不了解内存基本分配和回收机制是不太合适的，这又恰恰是前端很缺少的知识，而且市面上很少有结合操作系统的运行机制来解释的文章）。</p><p>当然这还对学习 devops 知识大有裨益，例如我们现在都是容器化部署，大多数都是用 docker 作为容器运行时，早年 docker 使用的文件系统叫 overlay，会产生 inode 用尽的问题（简单来说就是文件系统格式化后，inode 占用的磁盘空间是确定的，一旦占用完了，就用尽了，也就无法打开别的文件了），这里就涉及到可能对于很多前端同学，尤其是非科班的，inode 表这个概念会不太了解，也很难知道这个问题是什么。</p><h2 id="从开机开始" tabindex="-1">从开机开始 <a class="header-anchor" href="#从开机开始" aria-label="Permalink to &quot;从开机开始&quot;">​</a></h2><p>首先，我们开机的时候，启动的是操作系统。可是你有没有想过，操作系统也是软件，运行软件都是要把程序装载到内存，才能被 cpu 调度的。</p><p>所以我们要启动操作系统，是需要把启动程序从硬盘读取到内存才可以被 cpu 执行的。</p><p>这里就有问题了:</p><h3 id="为什么要把程序代码读到内存才能执行-直接读取硬盘数据执行不行吗" tabindex="-1">为什么要把程序代码读到内存才能执行？直接读取硬盘数据执行不行吗？ <a class="header-anchor" href="#为什么要把程序代码读到内存才能执行-直接读取硬盘数据执行不行吗" aria-label="Permalink to &quot;为什么要把程序代码读到内存才能执行？直接读取硬盘数据执行不行吗？&quot;">​</a></h3><p>原因是首先因为磁盘读取速度太慢了，cpu 执行速度太快，所以应用程序需要加载到读取速度更快的物理介质中。</p><p>然后，你可能会问为什么不把所有程序都装在内存里呢？就不用从磁盘把程序读到内存了啊。这里又涉及到一个知识点，就是数据存储器分为 RAM 和 ROM。 RAM 代表随机存取内存，特点是掉电数据就没了。ROM 代表只读内存，掉电还能保存数据，比如硬盘。</p><p>最终，简而言之，通过一系列操作读取到启动操作系统的程序，然后 cpu 执行这由这个程序帮助我们最终完成开机操作。</p><p>额外小知识：更深入的开机流程，有兴趣的同学可以自行搜索，例如什么是 MBR 启动分区，什么是 BIOS 等等，这里顺便提一个很有趣的知识点，我们在用电脑的时候，尤其是台式电脑，一般启动的时候会短促有 “嘀”的一声，这是 BIOS 硬件自检通过的标志（简单理解硬件自检就是，启动电脑，硬盘、内存、cpu 等这些硬件是否能正常工作，比如你硬盘都没了，你咋加载操作系统软件呢，更别谈开机了）。</p><p>开机后，我们找到自己的前端项目，准备开始今天的任务，一般都是打开代码编辑器，比如 vscode，此时 vscode 将我们的存放代码加载进来，此时又有问题了</p><h3 id="我们的代码-也就是文件是如何从硬盘加载到内存" tabindex="-1">我们的代码，也就是文件是如何从硬盘加载到内存？ <a class="header-anchor" href="#我们的代码-也就是文件是如何从硬盘加载到内存" aria-label="Permalink to &quot;我们的代码，也就是文件是如何从硬盘加载到内存？&quot;">​</a></h3><p>我要加载文件，按道理来说，我直接去操作系统的磁盘里找到这个文件就行了，可现实却不是这样的。</p><p>无论 windows 还是 mac，都是可以多人用自己的账号登录，那么有可能我的文件我并不想让别的用户访问，所以打开文件我们不能直接打开，起码要看看你有没有打开的权限。</p><p>所以当我们打开文件的时候首先是去某个目录下寻找该文件，所以我们的目录就应该存储在硬盘里，并且因为目录访问是非常频繁的，一般开机的时候，目录表就已经加载到内存了。</p><p>问题又来了？</p><h3 id="目录中保存了哪些信息帮助我们去找文件呢" tabindex="-1">目录中保存了哪些信息帮助我们去找文件呢？ <a class="header-anchor" href="#目录中保存了哪些信息帮助我们去找文件呢" aria-label="Permalink to &quot;目录中保存了哪些信息帮助我们去找文件呢？&quot;">​</a></h3><p>回答这个问题之前，我们需要先介绍一下保存文件的物理存储设备，磁盘（我们逻辑上的数据块映射到的物理设备就是磁盘，或者更精确的说是磁盘上的扇区）。</p><p>首先磁盘是块设备，什么意思呢？就是读取信息的时候并不是一个字节一个字节读取，而是一整块一整块的读取，我们假设每个块大小是 512kb。</p><p>这里有要引申出一个问题，数据块我们一般都是逻辑上的叫法，真实映射到物理磁盘上，我们称之为扇区，什么是扇区呢？</p><h3 id="这里我们不得不来看看磁盘的物理结构了" tabindex="-1">这里我们不得不来看看磁盘的物理结构了 <a class="header-anchor" href="#这里我们不得不来看看磁盘的物理结构了" aria-label="Permalink to &quot;这里我们不得不来看看磁盘的物理结构了&quot;">​</a></h3><p><img src="'+rs+'" alt="img"></p><p>上面的是黑色部分，分别是磁头和磁臂，然后磁头读取盘面上的信息。然后磁盘上会有扇区划分，如下图：</p><p><img src="'+ts+'" alt="img"></p><p>上面可以看到，一个盘面被划分为多个相等的扇区。然后我们可以给扇区编上号，这样当我们要查找某个文件的时候，操作系统会指名这个文件在几号数据块上，数据块又映射到物理上的扇区上，讲真正的数据提取到内存中供 CPU 调度。</p><p>所以回到上面的问题：目录中保存了哪些信息帮助我们去找文件呢？肯定要包含数据块的信息，比如文件存放到 1 号数据块里，这样操作系统内部在映射到磁盘扇区上。</p><p>我们可以再想想，目录中保存的文件信息，起码要有文件名对吧，我们就是靠文件名去目录表里搜索到底是哪个文件的，当然还有我们之前提到的权限，就是权限信息，例如你有可读，可写，还是可以执行的文件的权限。文件大小，文件路径是不是按道理也需要。</p><p>我们在命令行可以输入，ls -l 命令，就可以看到目录的详细信息。如下图</p><p><img src="'+is+'" alt="img"></p><p>简而言之，每条文件信息在目录里，我们称之为 FCB，文件控制块（file control block）。在 linux 中，又被称之为 inode 表，inode 指的是 index node，也就是索引节点的意思。</p><p>这就回答了上面的问题，就是数据如何从磁盘读取到内存，其实因为磁盘读取速度比较慢，一般磁盘的数据会存储到一个缓存缓冲区里，然后缓冲区再存到内存里，缓冲区对于我们理解 node.js 中流的使用至关重要，在操作系统中，缓冲区（Buffer）是一种用于临时存储数据的区域，通常用于在两个不同的设备或进程之间进行数据传输。</p><p>文件加载进去了，此时，我们前端需要新建一个组件，我们就打开代码编辑器，在里面通过 GUI（也就是可视化界面）来创建一个新文件。</p><p>此时，又有几个问题来了，首先，你创建新文件其实是需要将新文件创建的基本信息存放到目录表里，还有实际上在磁盘里给这个文件划分使用的扇区，这样就有了物理空间存储数据。但是你怎么知道扇区里那些地方有空闲的磁盘块呢？</p><h3 id="如何知道哪里有空闲的磁盘块呢" tabindex="-1">如何知道哪里有空闲的磁盘块呢？ <a class="header-anchor" href="#如何知道哪里有空闲的磁盘块呢" aria-label="Permalink to &quot;如何知道哪里有空闲的磁盘块呢？&quot;">​</a></h3><p>其实操作系统会在你格式化的文件系统里，有一部分存储空间专门存储空闲磁盘块有哪些的信息。</p><p>例如空间磁盘块的管理方法有一种叫 bit map（位图）。</p><p>也就是说假如有我们实际上只有 4 个数据块可以使用，bit map 就存储了 0000，这 4 个比特位，4 对应了 4 个数据块，0 代表着目前 4 个数据块都是没有使用的，1 代表使用了。</p><p>这样的管理方式有什么缺点呢，就是我们要扫瞄一遍才能知道有哪个空闲块，优点是标识数据块已经有数据和没有数据非常方便，只要改下 0 或者 1 就行了。</p><p>所以还有一些其他管理方式，比如链表法，把每个空闲块用链表的方式存储起来，这样查找空闲块就很方便，从链表头部就知道哪些是空闲的。这些方法各有优缺点，不同的文件系统选择不同的管理方式。</p><p>好了，创建好文件之后，你有没有想过，我们存放的代码文件在内存里是如何存放的呢？</p><p>有人会说了，这还不简单，连续存放的呗，比如我有一个 js 文件，可能比较大，占据数据块 1 号和 2 号，存放的时候，直接 1 号和 2 号存到物理扇区里。</p><p>但是你有没有想过，假如一个文件 A 占据 10 个数据块，另一个文件 B 也占 10 个数据块，它们是挨着的，如下：</p><div class="language-bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#61AFEF;">A文件占据的数据块</span><span style="color:#ABB2BF;"> | </span><span style="color:#61AFEF;">B文件占据的数据块</span><span style="color:#98C379;"> ｜</span><span style="color:#98C379;"> C文件占据的数据块</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>那么问题来了，A 文件变大了，那么为了给 A 文件提供更多连续的存储空间，不得不把 b，c 文件数据块往后移，这就可怕了，数据文件多了，这种文件管理方式的弊端就非常明显了。</p><p>但是如果你的文件都是只读的，不能写，其实这种方式也可以。</p><p>也就是说，实际上落到磁盘的数据，如果物理上都要求连续存储，其实使用场景是非常有限的，所以我们需要一种非连续分配的方式，我这里直接说一下现代操作系统常用的一种方式吧，就是索引分配</p><p><img src="'+ds+'" alt="img"></p><p>这里可以看到，目录表，一般存放的是这个文件存储的物理块号在哪里，但索引分配是存储了索引表，在索引表上存储里对应物理块号的哪一个。（还有多级索引表，这里不引申了）</p><p>它的优点是什么，我们可以进行随机访问，因为存储索引的数据结构在 linux 的 ext4 系统里是 b 树，b 树支持随机查找。B 树示意图如下（这个不深究了，属于数据结构和算法的内容）。</p><p><img src="'+bs+'" alt="img"></p><p>其实这一部分主要想介绍的就是文件系统，接下来我们用一个完整案例，来把上面的知识串到一起。</p><p>首先，磁盘最开始什么都没有，卖磁盘的厂家会先对磁盘进行低级格式化，也就是划分扇区：</p><p><img src="'+ms+'" alt="img"></p><p>然后装操作系统的过程，会对磁盘进行高级格式化，高级格式化主要目的是在磁盘上装载文件系统，同时会安装引导操作系统启动的引导程序。</p><p><img src="'+us+'" alt="img"></p><p>可以看到，在第一个扇区，存放着主引导记录，主要包含了磁盘引导程序和分区表。分区表不用说了，这个大家能理解，尤其是 windows，我们划分为 c 盘，d 盘什么的。磁盘引导程序一个主要作用就是扫描分区，然后执行主分区里引导程序，在 windows 一下一般都是 c 盘，linux 则是情况而定。如下：</p><p><img src="'+Bs+'" alt="img"></p><p>然后执行主分区里的系统初始化程序，完成“开机”等一系列动作。</p><p>上图可以看到，c 盘里的第二个灰色块是超级块，简单来说就是存放硬盘已用空间、数据块可用空间信息等等，说白了就是描述整个文件系统基本信息的。</p><p>c 盘里的第三个灰色块，就是空闲块管理信息，比如 bit map 存储。</p><p>c 盘里的第五个灰色块，对应下面的目录表，和第四个灰色块对应下方的索引表</p><p><img src="'+fs+'" alt="img"></p><p>然后打开文件 -&gt; 去目录表（索引表或者叫 inode 表）查这个文件 -&gt; 目录表上有索引信息，然后拿着索引信息去索引表找到真实文件的逻辑地址 -&gt;</p><p>去磁盘上找到对应的文件信息 -&gt; 读取到内存等待 cpu 读取</p><p>最后，再提一个关键知识点，在 linux 系统中，其实所有打开的文件都会有记录在系统的打开文件表里，如下图</p><p><img src="'+ys+'" alt="img"></p><p>每一个进程都维护了一个自己打开哪些文件的表，例如，在 node.js 中，调用 fs 模块的 open 方法，会返回一个文件描述符，如上图最左侧，文件描述是操作文件很关键的一个凭证，其实它在知识进程打开表的一个索引而已。</p><p>好了，至此，我们简单了解了文件系统和磁盘。不知道有多少人坚持到这里了，送你一个赞</p><p><img src="'+hs+'" alt="img"></p><p>接着来，我们在写前端页面，也就是输入代码的时候，此时其实是键盘这个 I/O 设备在一个字符一个字符在输入，这期间</p><h3 id="计算机是如何让键盘上输入的字符显示到显示器上的呢" tabindex="-1">计算机是如何让键盘上输入的字符显示到显示器上的呢？ <a class="header-anchor" href="#计算机是如何让键盘上输入的字符显示到显示器上的呢" aria-label="Permalink to &quot;计算机是如何让键盘上输入的字符显示到显示器上的呢？&quot;">​</a></h3><p>整个操作系统的目的就是管理硬件资源的， 这里的键盘和显示器都是常见的 I/O 设备（I/O 设备就是能往计算里输入或者输出数据的设备），它们是如何被计算机控制的呢？</p><p>这里有个隐藏的小知识点，也就是上面我们谈到磁盘也是 I/O 设备，而且是块设备，也就读取数据是按数据块来的，而键盘是另一种 I/O 设备，叫字符设备，它输入数据是按字符来的。cpu 其实并不是直接操作 I/O 设备的，而是通过 I/O 控制器来控制， 所以这里就有问题了</p><h3 id="为什么-cpu-控制-i-o-设备要通过-i-o-控制器呢" tabindex="-1">为什么 CPU 控制 I/O 设备要通过 I/O 控制器呢？ <a class="header-anchor" href="#为什么-cpu-控制-i-o-设备要通过-i-o-控制器呢" aria-label="Permalink to &quot;为什么 CPU 控制 I/O 设备要通过 I/O 控制器呢？&quot;">​</a></h3><p>这就需要提到人类第一台计算机埃尼阿克，它也要接入 I/O 设备来输入数据和输出结果，但它连接的线非常多。</p><p><img src="'+Fs+'" alt="img"></p><p>因为每一种 I/O 设备控制的方法不一样，不得不给每一个 I/O 设备专门写控制它们的程序。</p><p>现在有了 I/O 控制器，那么</p><h3 id="cpu-怎么控制-i-o-设备" tabindex="-1">CPU 怎么控制 I/O 设备 <a class="header-anchor" href="#cpu-怎么控制-i-o-设备" aria-label="Permalink to &quot;CPU 怎么控制 I/O 设备&quot;">​</a></h3><p>最简单的思路就是，轮询，cpu 每次过 1 秒去问 I/O 设备，有没有数据啊，有的话我就拿。但这有什么问题吗？可以想象，现代的操作系统同时要处理很多任务的，键盘输入频繁，那么是不是 CPU 要花大量的时间跟键盘耗在一起了，这就没办法处理别的任务了。</p><p>所以后面产生另一种 CPU 控制 I/O 设备的方式，叫中断。</p><p>中断是一个非常非常非常重要的知识点，所以我们需要消息描述一下</p><h3 id="为什么需要中断" tabindex="-1">为什么需要中断？ <a class="header-anchor" href="#为什么需要中断" aria-label="Permalink to &quot;为什么需要中断？&quot;">​</a></h3><p>这就要谈到一些必须具备的基础概念了。所以先学习下面的概念后，我们回答这个问题</p><h4 id="两种指令、两种处理器状态、两种程序" tabindex="-1">两种指令、两种处理器状态、两种程序 <a class="header-anchor" href="#两种指令、两种处理器状态、两种程序" aria-label="Permalink to &quot;两种指令、两种处理器状态、两种程序&quot;">​</a></h4><p>假如说一个用户可以随意把服务器上的所有文件删光，这是很危险的。所以有些指令普通用户是不能使用的，只能是<code>权限较高</code>的用户能使用。此时指令就分为了两种，如下图：</p><p><img src="'+ks+'" alt="img"></p><p>这就引出一个问题：CPU<code>如何判断</code>当前是否可以执行<code>特权指令</code>？ 如下图:</p><p><img src="'+As+'" alt="img"></p><p>CPU 通常有两种工作模式即：<code>内核态</code>和<code>用户态</code>，而在 PSW（这个不用管，就知道有一个寄存器的标志位 0 表示用户态，1 表示核心态）中有一个二进制位控制这两种模式。</p><p>对于应用程序而言，有的程序能执行特权指令，有的程序只能执行非特权指令。所以操作系统里的程序又分为两种：</p><p><img src="'+gs+'" alt="img"></p><p>所以说，我们需要一种机制，让用户态的程序能进入内核态执行一些特权指令，这个就是中断其中的一个作用。中断也是用户态到内核态唯一的办法。</p><p>回到我们开始讨论的问题，CPU 怎么控制 I/O 设备，我们说轮询的方式很低效，所以产生了中断。</p><p>键盘输入字符的时候，会引发外中断，外中断是指外部 I/O 设备引起的中断。</p><p>此时中断发生，cpu 就马上回去处理这个中断。虽然比轮询更强，但是频繁中断也是很低效的，假如我们此时正在打游戏，游戏里的队友很坑，你就不停的打字喷他。</p><p>此时就会产生大量中断，也就是 cpu 要控制把你喷的字从 i/o 设备里放到内存中，然后从内存显示到显示器上。</p><p>你发现没，有时候打字到时候游戏就会卡，这是因为中断会陷入内核态，陷入之前需要把当前运行的程序信息保存起来，等回到用户态，再把之前运行程序的程序信息恢复</p><p>上面的方式主要适用于字节设备，比如键盘，是按字节为单位进行数据传输的。</p><p>对于块设备的数据传输，有一种方式叫 DMA，如下图</p><p><img src="'+Cs+'" alt="img"></p><p>DMA 控制器是如何跟 CPU 交互的呢，它允许外部设备直接跟内存进行数据传输，而无需 CPU 的干预。</p><p>cpu 指明此次要进行的操作，如读操作，并说明要读入多少数据，数据要存放在内存什么位置等等信息。</p><p>DMA 控制器会根据 cpu 提出的要求完成数据的读写工作，整块数据传输完成后，才向 CPU 发出中断信号。</p><p>我们用键盘输入的字符主要是跟后端联调的 fetch 请求的代码。如下</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#61AFEF;">fetch</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;">url</span><span style="color:#ABB2BF;">).</span><span style="color:#61AFEF;">then</span><span style="color:#ABB2BF;">((</span><span style="color:#E06C75;font-style:italic;">response</span><span style="color:#ABB2BF;">) </span><span style="color:#C678DD;">=&gt;</span><span style="color:#E5C07B;"> console</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">log</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;">response</span><span style="color:#ABB2BF;">));</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>其实这也牵扯到常见的面试题，就是 tcp 的三次握手，这次我们从更底层的角度去看，如何通过网卡这个 i/o 设备去建立 tcp 连接。</p><p><img src="'+vs+'" alt="img"></p><p>上图左边是主机 1，也就是我们前端的电脑，右边是主机 2，也就是后端的电脑</p><p>我们发起请求的时候，先是我们调用 fecth 请求，浏览器会调用 sokcet 系统调用，创建一个套接字，网络套接字你可以理解为申请一片内存空间，用来接收和发送数据</p><p>socket 系统调用会给用户返回一个 fd，也就是文件描述符（指向套接字的一个引用），然后浏览器调用 bind 函数（操作系统提供的系统调用），用来绑定本机的一个端口，不同的端口意味着不同的应用在提供服务，需要通过端口号来区分不同的应用。</p><p>最后浏览器会调用 connect 函数（也是操作系统提供的系统调用），把 fd 传进去，例如 connect（fd，ip 地址等等参数），最后会跟服务器建立连接。</p><p>最后浏览器通过 write 调用（把我们 fetch 函数里传的数据传输出去）数据存通过 write 调用传输到网卡上，网卡再传输到网络中去。</p><h2 id="我们总结一下用户层软件调用-i-o-设备的过程" tabindex="-1">我们总结一下用户层软件调用 I/O 设备的过程 <a class="header-anchor" href="#我们总结一下用户层软件调用-i-o-设备的过程" aria-label="Permalink to &quot;我们总结一下用户层软件调用 I/O 设备的过程&quot;">​</a></h2><p>算是把上面关于 io 设备的知识做一个串联。</p><p><img src="'+qs+'" alt="img"></p><p>如上图，我们简单描述一下浏览器调用 io 设备（如上图，用户层软件我们假设位是浏览器）的流程，浏览器肯定可以调用网卡这个设备的，因为我们需要 http 请求跟后端交互。</p><p>那么最终浏览器调用的是操作系统提供的 write 函数，这个 write 函数就是上图的设备独立性软件提供的，也是操作系统提供的。同时它还负责调用相应的驱动程序。</p><p>为什么需要驱动程序呢（如上图第三层），因为网卡是有不同的产品的，比如用 A 厂家的网卡和 B 厂家的网卡，可能在一些实现细节上不一样，比如发送数据 A 厂家调用自己的 writeA 函数，B 厂家叫 writeB，所以最终还需要驱动程序来实现真正最后调用硬件的细节代码。</p><p>所以为了屏蔽这些差异，外部接入设备一般都要写自己的驱动程序。</p><p>这就是一个用户从软件层面再到真实调用物理 io 设备的流程，当然，我们最终让操作系统完成写网卡这个操作是需要发出中断请求的，从而从用户态进入内核态，让操作系统去完成。相同，当 io 设备返回数据的时候，比如后端的数据又经过我们的网卡返回的时候，也是需要中断告诉操作系统，此时有数据来了，cpu 需要马上安排一下。</p><p>好了，到此为止上面简单的介绍了 i/o 设备的管理，看到这里再给你点个赞</p><p><img src="'+Es+`" alt="img"></p><p>上面一直说，无论是 i/o 设备还是从磁盘读取的数据，最终都要先到内存，才能被 cpu 调度。我们先来看一个很直接的案例，到底我们写的前端代码是如何存储在内存的。</p><p>例如代码如下：</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#C678DD;">const</span><span style="color:#E5C07B;"> global</span><span style="color:#56B6C2;"> =</span><span style="color:#D19A66;"> 100</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#C678DD;">function</span><span style="color:#61AFEF;"> f</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;font-style:italic;">x</span><span style="color:#ABB2BF;">, </span><span style="color:#E06C75;font-style:italic;">y</span><span style="color:#ABB2BF;">) {</span></span>
<span class="line"><span style="color:#C678DD;">	const</span><span style="color:#E5C07B;"> p</span><span style="color:#56B6C2;"> =</span><span style="color:#ABB2BF;"> {};</span></span>
<span class="line"><span style="color:#C678DD;">	return</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span>
<span class="line"><span style="color:#C678DD;">function</span><span style="color:#61AFEF;"> g</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;font-style:italic;">a</span><span style="color:#ABB2BF;">) {</span></span>
<span class="line"><span style="color:#61AFEF;">	f</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;">a</span><span style="color:#ABB2BF;">, </span><span style="color:#E06C75;">a</span><span style="color:#56B6C2;"> +</span><span style="color:#D19A66;"> 1</span><span style="color:#ABB2BF;">);</span></span>
<span class="line"><span style="color:#C678DD;">	return</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span>
<span class="line"><span style="color:#C678DD;">function</span><span style="color:#61AFEF;"> main</span><span style="color:#ABB2BF;">() {</span></span>
<span class="line"><span style="color:#C678DD;">	const</span><span style="color:#E5C07B;"> i</span><span style="color:#56B6C2;"> =</span><span style="color:#D19A66;"> 100</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#61AFEF;">	g</span><span style="color:#ABB2BF;">(</span><span style="color:#D19A66;">100</span><span style="color:#ABB2BF;">);</span></span>
<span class="line"><span style="color:#C678DD;">	return</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span>
<span class="line"><span style="color:#61AFEF;">main</span><span style="color:#ABB2BF;">();</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>在内存里，我们代码存放主要分为</p><ul><li>text：代码段</li><li>data：全局和静态变量数据</li><li>stack：栈用于存放局部变量，函数返回地址</li><li>heap：堆用于程序运行时动态分配内存</li></ul><p>如下图：</p><p><img src="`+Ps+`" alt="img"></p><p>之前我们写的前端代码要开始运行了，我们的前端代码是存储在 text 区域的，对于一些静态语言来说，text 是 2 进制的 binary code，而对于 javascript 这种解释性语言，存储的就是我们写的前端 js 代码，只有在执行的时候才会去解释和编译为 2 进制的机器码，再执行。</p><p>我们从上到下执行之前写的前端代码，首先</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#C678DD;">const</span><span style="color:#E5C07B;"> global</span><span style="color:#56B6C2;"> =</span><span style="color:#D19A66;"> 100</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#C678DD;">function</span><span style="color:#61AFEF;"> f</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;font-style:italic;">x</span><span style="color:#ABB2BF;">, </span><span style="color:#E06C75;font-style:italic;">y</span><span style="color:#ABB2BF;">) {</span></span>
<span class="line"><span style="color:#C678DD;">	const</span><span style="color:#E5C07B;"> p</span><span style="color:#56B6C2;"> =</span><span style="color:#ABB2BF;"> {};</span></span>
<span class="line"><span style="color:#C678DD;">	return</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span>
<span class="line"><span style="color:#C678DD;">function</span><span style="color:#61AFEF;"> g</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;font-style:italic;">a</span><span style="color:#ABB2BF;">) {</span></span>
<span class="line"><span style="color:#61AFEF;">	f</span><span style="color:#ABB2BF;">(</span><span style="color:#E06C75;">a</span><span style="color:#ABB2BF;">, </span><span style="color:#E06C75;">a</span><span style="color:#56B6C2;"> +</span><span style="color:#D19A66;"> 1</span><span style="color:#ABB2BF;">);</span></span>
<span class="line"><span style="color:#C678DD;">	return</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span>
<span class="line"><span style="color:#C678DD;">function</span><span style="color:#61AFEF;"> main</span><span style="color:#ABB2BF;">() {</span></span>
<span class="line"><span style="color:#C678DD;">	const</span><span style="color:#E5C07B;"> i</span><span style="color:#56B6C2;"> =</span><span style="color:#D19A66;"> 100</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#61AFEF;">	g</span><span style="color:#ABB2BF;">(</span><span style="color:#D19A66;">100</span><span style="color:#ABB2BF;">);</span></span>
<span class="line"><span style="color:#C678DD;">	return</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>这是全局变量，存放到 data 区域，f、g 和 main 也是全局函数，所以也会存放在 data 区域。</p><p>然后，开始执行 main 函数</p><div class="language-bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#61AFEF;">main</span><span style="color:#ABB2BF;">();</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>main 函数执行，里面代码就开始执行了,只要执行函数，就会把它的返回地址写入到 stack 中，这样方便我们执行完毕后，再返回到这个函数向下执行。所以此时 stack 区域是</p><p><img src="`+ws+`" alt="img"></p><p>然后执行 main 函数里的内容</p><div class="language-bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#C678DD;">function</span><span style="color:#61AFEF;"> main</span><span style="color:#ABB2BF;">(){</span></span>
<span class="line"><span style="color:#61AFEF;">    const</span><span style="color:#98C379;"> i</span><span style="color:#98C379;"> =</span><span style="color:#D19A66;"> 100</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#61AFEF;">    g(100</span><span style="color:#ABB2BF;">);</span></span>
<span class="line"><span style="color:#C678DD;">    return</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>i 变量是局部变量，所以存放在 stack 区域，然后继续执行 g(100)，此时 stack 区域是这样的</p><p><img src="`+Ds+'" alt="img"></p><p>然后接着 g 函数执行，g 函数执行后，f 函数又开始执行，f 函数中声明了一个对象，对象在 js 语言里是被存放到堆，也就是 heap 区域，所以此时 heap 区域就有了数据。此时 stack 如下图：</p><p><img src="'+xs+'" alt="img"></p><p>每次函数调用的时候，都会把返回地址压入栈（stack）中，那么函数执行完毕，则根据返回地址弹出 stack。</p><p>可是这里有一个很重要的点，就是局部变量 x、y 和 i 瞬间就销毁了，但是在 heap 区域里的数据不是瞬间销毁的，是需要靠垃圾回收机制销毁。</p><p>这就涉及到内存的回收，我们的操作系统如何回收 heap 里的数据呢？</p><p>这里我们延伸一下，看看 node.js 中的 v8 引擎是用了什么回收算法（下面主要介绍了分带回收和标记清除算法）。</p><h3 id="如何查看-v8-的内存使用情况" tabindex="-1">如何查看 V8 的内存使用情况 <a class="header-anchor" href="#如何查看-v8-的内存使用情况" aria-label="Permalink to &quot;如何查看 V8 的内存使用情况&quot;">​</a></h3><p>使用 process.memoryUsage(),返回如下</p><div class="language-yaml line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">yaml</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#ABB2BF;">{ </span><span style="color:#E06C75;">rss</span><span style="color:#ABB2BF;">: </span><span style="color:#D19A66;">4935680</span><span style="color:#ABB2BF;">, </span><span style="color:#E06C75;">heapTotal</span><span style="color:#ABB2BF;">: </span><span style="color:#D19A66;">1826816</span><span style="color:#ABB2BF;">, </span><span style="color:#E06C75;">heapUsed</span><span style="color:#ABB2BF;">: </span><span style="color:#D19A66;">650472</span><span style="color:#ABB2BF;">, </span><span style="color:#E06C75;">external</span><span style="color:#ABB2BF;">: </span><span style="color:#D19A66;">49879</span><span style="color:#ABB2BF;"> }</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>heapTotal 和 heapUsed 代表 V8 的内存使用情况。也就是之前我们提到的 heap 区域的使用情况。</p><p>external 代表 V8 管理的，绑定到 Javascript 的 C++对象的内存使用情况。</p><p>rss, 其实就是占用的所有物理内存的大小，是给这个进程分配了多少物理内存，也就是我们上面 提到的，这些物理内存中包含堆，栈，和代码段等等。</p><h3 id="v8-的内存分代和回收算法请简单讲一讲" tabindex="-1">V8 的内存分代和回收算法请简单讲一讲 <a class="header-anchor" href="#v8-的内存分代和回收算法请简单讲一讲" aria-label="Permalink to &quot;V8 的内存分代和回收算法请简单讲一讲&quot;">​</a></h3><p>在 V8 中，主要将内存分为新生代和老生代两代。新生代中的对象存活时间较短的对象，老生代中的对象存活时间较长，或常驻内存的对象。</p><p><img src="'+Ns+'" alt="img"></p><h4 id="新生代" tabindex="-1">新生代 <a class="header-anchor" href="#新生代" aria-label="Permalink to &quot;新生代&quot;">​</a></h4><p>新生代中的对象主要通过 Scavenge 算法进行垃圾回收。这是一种采用复制的方式实现的垃圾回收算法。它将堆内存一分为二，每一部分空间成为 semispace。在这两个 semispace 空间中，只有一个处于使用中，另一个处于闲置状态。处于使用状态的 semispace 空间称为 From 空间，处于闲置状态的空间称为 To 空间。</p><p><img src="'+Us+'" alt="img"></p><ul><li>当开始垃圾回收的时候，会检查 From 空间中的存活对象，这些存活对象将被复制到 To 空间中，而非存活对象占用的空间将会被释放。完成复制后，From 空间和 To 空间发生角色对换。</li><li>因为新生代中对象的生命周期比较短，就比较适合这个算法。</li><li>当一个对象经过多次复制依然存活，它将会被认为是生命周期较长的对象。这种新生代中生命周期较长的对象随后会被移到老生代中。</li></ul><h4 id="老生代" tabindex="-1">老生代 <a class="header-anchor" href="#老生代" aria-label="Permalink to &quot;老生代&quot;">​</a></h4><p>老生代主要采取的是标记清除的垃圾回收算法。与 Scavenge 复制活着的对象不同，标记清除算法在标记阶段遍历堆中的所有对象，并标记活着的对象，只清理死亡对象。活对象在新生代中只占叫小部分，死对象在老生代中只占较小部分，这是为什么采用标记清除算法的原因。</p><h4 id="标记清楚算法的问题" tabindex="-1">标记清楚算法的问题 <a class="header-anchor" href="#标记清楚算法的问题" aria-label="Permalink to &quot;标记清楚算法的问题&quot;">​</a></h4><p>主要问题是每一次进行标记清除回收后，内存空间会出现不连续的状态</p><p><img src="'+_s+'" alt="img"></p><ul><li>这种内存碎片会对后续内存分配造成问题，很可能出现需要分配一个大对象的情况，这时所有的碎片空间都无法完成此次分配，就会提前触发垃圾回收，而这次回收是不必要的。</li><li>为了解决碎片问题，标记整理被提出来。就是在对象被标记死亡后，在整理的过程中，将活着的对象往一端移动，移动完成后，直接清理掉边界外的内存。</li></ul><p>到这里，我们了解对前端代码在内存的简单分配和回收有了大致的了解，那么我们现在就要更深入的了解一些关于内存管理的其他知识了。</p><p>首先</p><h3 id="内存是如何存储数据的呢" tabindex="-1">内存是如何存储数据的呢？ <a class="header-anchor" href="#内存是如何存储数据的呢" aria-label="Permalink to &quot;内存是如何存储数据的呢？&quot;">​</a></h3><p>最后，我们要来讲讲进程和线程了，还是拿我们熟知的前端代码，我们上面已经知道前端代码运行时在内存的表现形式，那么 cpu 内部是如何一条一条取指令来运行的，这里首先就会有一个问题了，就是指令是什么？</p><h3 id="指令是什么" tabindex="-1">指令是什么？ <a class="header-anchor" href="#指令是什么" aria-label="Permalink to &quot;指令是什么？&quot;">​</a></h3><p>它是指计算机执行某种操作的命令，是计算机运行的最小功能单位。一台计算机的所有指令的集合构成该机的指令系统，也称为指令集。比如著名的 x86 架构（intel 的 pc）和 ARM 架构（手机）的指令集是不同的。</p><p><img src="'+js+'" alt="img"></p><p>一条指令就是机器语言的一个语句，它是一组有意义的二进制代码。一条指令通常包括操作码（OP） + 地址码（A）</p><ul><li>操作码简单来说就是我要进行什么操作，比如我要实现 1+1，加法操作，停机操作等等</li><li>地址码就是比如实现加法操作的数据地址在哪，通常是内存地址。</li></ul><h3 id="cpu-是如何去内存取指令-然后一步一步执行的呢" tabindex="-1">cpu 是如何去内存取指令，然后一步一步执行的呢？ <a class="header-anchor" href="#cpu-是如何去内存取指令-然后一步一步执行的呢" aria-label="Permalink to &quot;cpu 是如何去内存取指令，然后一步一步执行的呢？&quot;">​</a></h3><p>首先，是取指令的过程如下</p><p><img src="'+Ls+'" alt="img"></p><ul><li>我们简单描述，就是 CPU 要知道下一条指令是什么，就必须去存储器（内存）去拿，<code>PC</code>去了存储器的<code>MAR</code>拿要执行的指令地址，<code>MAR</code>（存储器里专门存指令地址的地方）</li><li>第二步和第三步，<code>MAR</code>去存储体内拿到指令之后，将指令地址放入<code>MDR</code>(存储器里专门存数据的地方)</li><li>然后 MDR 里的数据会返回给 CPU</li><li>比如这条指令是计算 1+1 等于几，CPU 会把这个任务交给内部的运算器，计算完毕，指令会告诉你把计算结果放到内存的哪个位置，上面我们知道内存逻辑上是按块存储的，比如告诉我们放到 20 号内存块，cpu 就放过去，这样一条指令执行完毕，cpu 就会接着执行程序的下一条指令。</li></ul><p>我们接着说内存是如何存储数据的</p><p>首先，我们要知道内存也是分块的，我们都知道酒店会有很多房间，房间会有很多编号，其实内存也类似，如下图</p><p><img src="'+zs+'" alt="img"></p><p>然后就是具体存放数据了，一般情况下，大家都会想，当然连续存放呗，例如 a 程序占据内存块 1 号，b 程序占据内存块 2 号，依次类推。</p><p>这其实是连续存放的思想，连续存放我们在讲磁盘存数据的时候也讲过，连续存放会导致很多严重的问题，例如，a,b,c 程序在内存的排放方式如下：</p><div class="language-bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#61AFEF;">A文件占据的内存块</span><span style="color:#ABB2BF;"> | </span><span style="color:#61AFEF;">B文件占据的内存块</span><span style="color:#98C379;"> ｜</span><span style="color:#98C379;"> C文件占据的内存块</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>此时，如果 A 程序产生了很多局部变量，也就是要存放到 A 程序占有内存的 stack 区域，因为 ABC 文件占据内存是连续存放的，我们不得不把 B 和 C 往后移动。</p><p>所以往往会采取分连续分配内存块的算法。分连续分配有分段和分页算法。这里我们简单介绍一下分页算法，分段算法就不多说了，思想是一样的，在 linux 操作系统中，其实采取的是类似分页的算法，叫 buddy 算法，buddy 的意思是伙伴，好朋友的意思，所以也叫伙伴算法。</p><p>分页算法是把内存空间分为一个个大小相等的分区，一般每个分区是 4k，我们称之为页框。</p><p>同时讲进程的逻辑地址空间也分为与内存页框相等的一个个部分，我们把每个部分称为“页”，如下图</p><p><img src="'+Is+'" alt="img"></p><p>所以我们把进程逻辑上的数据分为一个个 4kb 的块，在内存上任意地方存放，从而实现数据在内存的非连续存放。</p><p>有的同学肯定想，分散后，我咋知道内存上哪些部分是存放进程 A 数据的呢？所以我们还需要一个表，记录进程上的逻辑块号，跟内存上的块号的映射关系。</p><p><img src="'+Os+'" alt="img"></p><p>其实真实的分页处理要比这个复杂很多，例如 linux 的伙伴算法，可以有效的减少外部碎片，为了减少内部碎片，还采用了 slab 分配机制。（更详细内容建议搜索谷歌，不过对我们前端来说不了没啥影响）</p><p>这里再简单介绍一个知识点，例如我们的计算机内存是 8GB，但是一个大型游戏可能有 10GB 大，显然，内存是不够大，加上我们的电脑同时还运行着很多别的程序，所以我们的计算机到底是怎么做到呢？</p><p>这也是非常非常重要的一个概念，叫虚拟内存</p><h3 id="什么是虚拟内存-为什么需要它" tabindex="-1">什么是虚拟内存？为什么需要它？ <a class="header-anchor" href="#什么是虚拟内存-为什么需要它" aria-label="Permalink to &quot;什么是虚拟内存？为什么需要它？&quot;">​</a></h3><p>虚拟内存 使得应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。</p><p>举个例子，我们玩的游戏假如有 10G,但是目前内存只有 4G,实际上我们的计算机只会加载部分游戏数据到内存中，因为全部的游戏数据，在我们当前的画面不会全部用到，我们只把用到的加载进来，这叫做局部性原理，它是指处理器在访问某些数据时短时间内存在重复访问，某些数据或者位置访问的概率极大，大多数时间只访问局部的数据。</p><p>如果要加载新的页面，例如你玩游戏进入了新的场景，需要加载新的数据，同时也需要把已经在内存的老数据置换出去，就会触发缺页中断，告诉操作系统要置换数据了。</p><p>此时涉及到置换算法，这里就有一个很常见的置换算法叫 LRU 页面置换算法，也算是前端面试很常见的 leetcode 面试题了。</p><p>最后，我们来讲一讲 cpu 和进程，首先</p><h3 id="为什么需要进程" tabindex="-1">为什么需要进程 <a class="header-anchor" href="#为什么需要进程" aria-label="Permalink to &quot;为什么需要进程&quot;">​</a></h3><p>因为我们的计算机是多道程序并发执行（多核 cpu 可以并行），假如我们现在只有一个 cpu，那么为什么我们能同时打开 qq 聊天，还可以听着网易云音乐呢，这是两个不同的 app，我们用起来好像它们就是并行的。</p><p>可实际上，微观层面，cpu 是并发执行，也就是 cpu 会有一个时间片，先给 qq 程序一小段时间使用，然后马上切换到网易云音乐程序，只是快到我们使用者层面觉得是两个程序同时在运行。</p><p>这里面就涉及到两个问题？一是 cpu 时间片如何设计调度算法，比如有很多紧急的任务，我们一般都要先执行紧急的任务，但是如果紧急任务特别多，其他一些不紧急的任务就得不到时间片，就无法执行，这是问题。二是，时间片运行的程序实际上在操作系统层面是以进程为单位调度的，这些进程是如何表示的。</p><p>我们先来看第一个问题</p><h3 id="cpu-调度进程的算法" tabindex="-1">CPU 调度进程的算法 <a class="header-anchor" href="#cpu-调度进程的算法" aria-label="Permalink to &quot;CPU 调度进程的算法&quot;">​</a></h3><p>其实有很多算法，比如先来先服务，短作业优先等等，这些我们都不讲，对于我们前端来说，其实大概知道，cpu 执行程序的指令，是以时间片的形式，时间到了，会有外中断（操作系统提供的时钟管理强制打断目前的执行的程序）然后切换为另一个程序执行。</p><p>对于我们前端而言，了解进程和线程本身的运行机制，尤其对于后续做 nodejs 开发尤为重要，到底进程包含了哪些东西。</p><p>之前我们知道，一个程序运行的时候在内存实际上包含</p><ul><li>text：代码段</li><li>data：全局和静态变量数据</li><li>stack：栈用于存放局部变量，函数返回地址</li><li>heap：堆用于程序运行时动态分配内存</li></ul><p>其实还有一个更重要的东西，叫进程控制块（PCB），为什么需要这么一个东西呢，一个程序运行的标志是有进程正在被调度，当一个程序时间片到了切换到另一个时间片到时候，我们是不是保存上一个程序的状态，比如代码在内存哪些地方，引用的文件有哪些（当前进程打开的文件，回顾文件系统篇的内容），进程状态，pid（进程 id）等等信息。</p><p>并且实际进程切换的时候，就是 PCB 的切换，因为有了 PCB，进程的所有信息都可以找到。</p><p>到此为止，我们知道操作系统调度程序的基本单位是进程。这有什么问题，进程增加的操作系统的并发能力，但是并没有增加单个程序的并发能力，什么意思呢？比如我用 qq 的时候，是既可以聊天，又可以视频，这是单个程序的并发能力，如何实现呢？</p><p>这时，我们的线程就登场了，一个进程有多个线程，这样单个程序也具备并发能力了。如下图：如果只有一个线程就入下图的左侧部分，多线程的话就是下图右侧部分。</p><p><img src="'+Ms+'" alt="img"></p><p>我们可以看到，线程共享了代码段，数据，files（当前打开的哪些文件），pcb 等信息。</p><p>而每个线程单独拥有 registers（寄存器空间），stack（栈，放局部变量）</p><p>最后，我再简单介绍进程间通信，这里涉及到 node.js 进程间通信的问题，也是操作系统一个重要知识点，nodejs 在 Windows 下用命名管道实现，*nix 系统则采用 Unix Domain Socket 实现。</p><h3 id="管道" tabindex="-1">管道 <a class="header-anchor" href="#管道" aria-label="Permalink to &quot;管道&quot;">​</a></h3><p>在学习 Linux 命令时，我们经常看到「<code>|</code>」这个竖线。</p><div class="language-bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#61AFEF;">$</span><span style="color:#98C379;"> ps</span><span style="color:#98C379;"> aux</span><span style="color:#ABB2BF;"> | </span><span style="color:#61AFEF;">grep</span><span style="color:#98C379;"> node</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>上面命令行里的「<code>|</code>」竖线就是一个<strong>管道</strong>，它的功能是 ps aux 得到的结果传给 grep node，需要注意的是<strong>管道传输数据是单向的</strong>，如果想相互通信，我们需要创建两个管道才行。</p><p><img src="'+Qs+'" alt="image.png"></p><p>上面的管道没有名字，所以「<code>|</code>」表示的管道称为<strong>匿名管道</strong>，用完了就销毁。</p><p>还有一种管道叫<strong>命名管道</strong>，也被叫做 <code>FIFO</code>，因为数据是先进先出的传输方式。</p><p>匿名管道只能在父子关系的进程中使用，命名管道可以在不相关的进程间使用。我们使用的 shell 中的管道是匿名管道，使用匿名管道的命令实际上会被 shell 生成两个子进程。</p><h3 id="domain-sokcet" tabindex="-1">domain sokcet <a class="header-anchor" href="#domain-sokcet" aria-label="Permalink to &quot;domain sokcet&quot;">​</a></h3><p>跟我们上面介绍的网络 socket 基本一致。只是本地 socket 在 bind 的时候，不像 TCP 和 UDP 要绑定 IP 地址和端口，而是<strong>绑定一个本地文件</strong></p><p>好了，全文就说到这里，顺便推广一下我的<a href="https://link.juejin.cn?target=" target="_blank" rel="noreferrer">react 组件库教程</a>，如果对你有帮助，感谢 star，以下是常见的面试题，有兴趣的同学可以看看。</p><h3 id="以下是常见面试题-先列出来-后续更新答案-部分知识点文章没有介绍" tabindex="-1">以下是常见面试题，先列出来，后续更新答案（部分知识点文章没有介绍） <a class="header-anchor" href="#以下是常见面试题-先列出来-后续更新答案-部分知识点文章没有介绍" aria-label="Permalink to &quot;以下是常见面试题，先列出来，后续更新答案（部分知识点文章没有介绍）&quot;">​</a></h3><ol><li>进程、线程和协程的区别是什么</li><li>进程间通信是什么</li><li>中断和系统调用的区别</li><li>进程有哪几种状态，状态之间是如何转换的</li><li>进程的调度策略和流程</li><li>什么是虚拟内存？什么是共享内存？</li><li>有什么常见的页面置换算法</li><li>文件系统中文件是如何组织的</li><li>磁盘调度算法以及磁盘空间存储管理</li><li>内存分配有哪些机制</li></ol>',484)]))}const Ys=a(Ss,[["render",Xs]]);export{Ws as __pageData,Ys as default};
