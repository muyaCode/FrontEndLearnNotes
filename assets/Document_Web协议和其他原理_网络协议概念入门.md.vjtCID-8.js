import{_ as a,c as e,o as t,ah as r}from"./chunks/framework.DqD713j2.js";const s="/FrontEndLearnNotes/assets/osi7cen.BkX1bwHs.png",n="/FrontEndLearnNotes/assets/osi.LiY95Z4S.png",o="/FrontEndLearnNotes/assets/%E5%B0%81%E8%A3%85%E8%BF%87%E7%A8%8B.CvkE4hvs.jpg",c="/FrontEndLearnNotes/assets/tcpip5.bHrdKy-_.png",p="/FrontEndLearnNotes/assets/tcpip.BJe8lt52.png",h="/FrontEndLearnNotes/assets/protocal.Bt52vsb0.png",d="/FrontEndLearnNotes/assets/2.phisical.UJcIc47T.png",u="/FrontEndLearnNotes/assets/8.mac.DHWLMz-t.png",_="/FrontEndLearnNotes/assets/8.iplayer.Tuj6L5ym.png",m="/FrontEndLearnNotes/assets/8.address.B_488VKG.png",P="/FrontEndLearnNotes/assets/8.router.DAzkRMge.png",b="/FrontEndLearnNotes/assets/ipheader.BmCk4h8e.png",i="/FrontEndLearnNotes/assets/9.ip.ftBQ3oHk.png",g="/FrontEndLearnNotes/assets/ippart.EDIkcDyK.png",q="/FrontEndLearnNotes/assets/10.ipclass.CcReNjth.png",C="/FrontEndLearnNotes/assets/10.mask.BkEBnHwt.png",I="/FrontEndLearnNotes/assets/11.transfer.DXx7-J4b.png",T="/FrontEndLearnNotes/assets/11.connect.DqhSfPv0.png",N="/FrontEndLearnNotes/assets/tcpport.D8HcQcyy.png",k="/FrontEndLearnNotes/assets/tcpsequence.B42fIemM.png",f="/FrontEndLearnNotes/assets/tcpconfirm.R0A9rQBd.png",S="/FrontEndLearnNotes/assets/tcpcontrolpng.CW_ItndN.png",E="/FrontEndLearnNotes/assets/tcpack.dgovBZvq.png",F="/FrontEndLearnNotes/assets/tcpsyn.CzHRkjuv.png",x="/FrontEndLearnNotes/assets/tcpfin.B2hKfJ_T.png",L="/FrontEndLearnNotes/assets/tcpwindow.BU-8FbtX.png",A="/FrontEndLearnNotes/assets/tcpcheck.E-QywCEm.png",D="/FrontEndLearnNotes/assets/sequencenumber.CU4fyqwg.jpg",w="/FrontEndLearnNotes/assets/shake8.DWUBf6Ki.jpg",B="/FrontEndLearnNotes/assets/datatransfer8.Dgrr6b7r.jpg",O="/FrontEndLearnNotes/assets/goodbye8.DnnbvE0F.jpg",M="/FrontEndLearnNotes/assets/seqpre.OO-ghs72.png",U="/FrontEndLearnNotes/assets/tcpconstructor.BgiKsJNQ.jpg",K="/FrontEndLearnNotes/assets/15.udp.D1onOUHg.png",R="/FrontEndLearnNotes/assets/udplength.CH_LV45U.png",y="/FrontEndLearnNotes/assets/udpcheck.OcFNtaMH.png",v="/FrontEndLearnNotes/assets/arealocal.CJ5Pk6wu.png",H="/FrontEndLearnNotes/assets/dnsquery.6UyUZh8K.jpg",j="/FrontEndLearnNotes/assets/17.mail.BdXRTMT_.png",Y="/FrontEndLearnNotes/assets/18.send.D8S2LEb8.png",W="/FrontEndLearnNotes/assets/19.receive.DQVS3dq8.png",Q="/FrontEndLearnNotes/assets/reaenv2.33szYRU-.png",z="/FrontEndLearnNotes/assets/tcp_hand_shake_detail.D4vSj8mj.png",J="/FrontEndLearnNotes/assets/handshake.QsQzgJ0T.gif",G="/FrontEndLearnNotes/assets/tcp_head.Cn34IkI9.png",tl=JSON.parse('{"title":"网络协议概念入门","description":"","frontmatter":{},"headers":[],"relativePath":"Document/Web协议和其他原理/网络协议概念入门.md","filePath":"Document/Web协议和其他原理/网络协议概念入门.md","lastUpdated":1750954157000}'),V={name:"Document/Web协议和其他原理/网络协议概念入门.md"};function X($,l,Z,ll,il,al){return t(),e("div",null,l[0]||(l[0]=[r('<h1 id="网络协议概念入门" tabindex="-1">网络协议概念入门 <a class="header-anchor" href="#网络协议概念入门" aria-label="Permalink to &quot;网络协议概念入门&quot;">​</a></h1><h2 id="_1-协议的概念和作用" tabindex="-1">1. 协议的概念和作用 <a class="header-anchor" href="#_1-协议的概念和作用" aria-label="Permalink to &quot;1. 协议的概念和作用&quot;">​</a></h2><ul><li>为了让计算机能够通信，计算机需要定义通信规则，这些规则就是协议</li><li>规则是多种，协议也有多种</li><li>协议就是数据封装格式+传输</li></ul><h3 id="_1-1-服务-协议实现数据传输" tabindex="-1">1.1 服务+协议实现数据传输 <a class="header-anchor" href="#_1-1-服务-协议实现数据传输" aria-label="Permalink to &quot;1.1 服务+协议实现数据传输&quot;">​</a></h3><ul><li><a href="https://baike.baidu.com/item/%E6%91%A9%E5%B0%94%E6%96%AF%E7%94%B5%E7%A0%81/1527853?fr=aladdin" target="_blank" rel="noreferrer">摩尔斯电码</a></li></ul><h2 id="_2-osi-七层模型" tabindex="-1">2. OSI 七层模型 <a class="header-anchor" href="#_2-osi-七层模型" aria-label="Permalink to &quot;2. OSI 七层模型&quot;">​</a></h2><p>OSI 是 Open System Interconnection 的缩写，意为开放式系统互联。国际标准化组织（ISO）制定了 OSI 模型，该模型定义了不同计算机互联的标准，是设计和描述计算机网络通信的基本框架。OSI 模型把网络通信的工作分为 7 层，分别是物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。</p><ul><li>分工带来效能 <ul><li><a href="http://www.360doc.com/content/17/0616/08/3404269_663547705.shtml" target="_blank" rel="noreferrer">松江黄金大劫案</a></li></ul></li><li>将复杂的流程分解为几个功能相对单一的子进程</li><li>整个流程更加清晰，复杂问题简单化</li><li>更容易发现问题并针对性的解决问题 <ul><li>应用层(Application) 提供网络与用户应用软件之间的接口服务</li><li>表示层(Presentation) 提供格式化的表示和转换数据服务，如加密和压缩</li><li>会话层(Session) 提供包括访问验证和会话管理在内的建立和维护应用之间通信的机制</li><li>传输层(Transimission) 提供建立、维护和取消传输连接功能，负责可靠地传输数据(PC)</li><li>网络层(Network) 处理网络间路由，确保数据及时传送(路由器)</li><li>数据链路层(DataLink) 负责无错传输数据，确认帧、发错重传等(交换机)</li><li>物理层(Physics) 提供机械、电气、功能和过程特性(网卡、网线、双绞线、同轴电缆、中继器)</li></ul></li></ul><p>首先来看看 OSI 的七层模型</p><p><img src="'+s+'" alt="OSI参考模型"></p><p>2222222 <img src="'+n+'" alt="分层模型"></p><h3 id="封装过程" tabindex="-1">封装过程 <a class="header-anchor" href="#封装过程" aria-label="Permalink to &quot;封装过程&quot;">​</a></h3><p><img src="'+o+'" alt="封装过程"></p><h2 id="_3-tcp-ip-参考模型" tabindex="-1">3. TCP/IP 参考模型 <a class="header-anchor" href="#_3-tcp-ip-参考模型" aria-label="Permalink to &quot;3. TCP/IP 参考模型&quot;">​</a></h2><p>TCP/IP 是传输控制协议/网络互联协议的简称。早期的 TCP/IP 模型是一个四层结构，从下往上依次是网络接口层、互联网层、传输层和应用层。后来在使用过程中，借鉴 OSI 七层参考模型，将网络接口层划分为了物理层和数据链路层，形成五层结构。</p><ul><li>TCP/IP 是传输控制协议/网络互联协议的简称</li><li>早期的 TCP/IP 模型是一个四层结构，从下往上依次是网络接口层、互联网层、传输层和应用层</li><li>后来在使用过程中，借鉴 OSI 七层参考模型，将网络接口层划分为了物理层和数据链路层，形成五层结构</li></ul><p><img src="'+c+'" alt="222"></p><p>222222</p><p><img src="'+p+'" alt="tcpip"></p><h3 id="常用协议" tabindex="-1">常用协议 <a class="header-anchor" href="#常用协议" aria-label="Permalink to &quot;常用协议&quot;">​</a></h3><ul><li>TCP/IP 协议被称为传输控制协议/互联网协议，又称网络通讯协议</li><li>是由网络层的 IP 协议和传输层的 TCP 协议组成，是一个很大的协议集合</li><li>物理层和数据链路层没有定义任何特定协议，支持所有的标准和专用的协议</li><li>网络层定义了网络互联也就是 IP 协议 <ul><li>网际协议 IP(Internet Protocal) 负责主机和网络之间寻址和路由数据包</li><li>地址解析协议 ARP(Address Resolution Protocol) 获得同一物理网络中的硬件主机 MAC 地址</li><li>反向地址转换协议(Reverse Address Resolution Protocol) 允许局域网的物理机器从网关服务器的 ARP 表或者缓存上请求其 IP 地址</li><li>网际控制消息协议 ICMP(Internet Control Message Protocol) 发送消息，并报告有关数据包的传送错误</li><li>互联组管理协议 IGMP(Internet Group Management Protocol) IP 主机向本地多路广播路由器报告主机组成员</li></ul></li><li>传输层定义了 TCP(传输控制协议)和 UDP(用户数据报)协议</li><li>应用层定义了 HTTP(超文本传输协议)、FTP(文件传输协议)、DNS(域名系统)等协议</li></ul><p><img src="'+h+'" alt="分层模型"></p><h3 id="_3-1-网络接口层" tabindex="-1">3.1 网络接口层 <a class="header-anchor" href="#_3-1-网络接口层" aria-label="Permalink to &quot;3.1 网络接口层&quot;">​</a></h3><p>网络接口层是 TCP/IP 模型的最底层，负责接收从上一层交来的数据报并将数据报通过底层的物理网络发送出去，比较常见的就是设备的驱动程序，此层没有特定的协议 网络接口层又分为物理层和数据链路层</p><h4 id="_3-1-1-物理层" tabindex="-1">3.1.1 物理层 <a class="header-anchor" href="#_3-1-1-物理层" aria-label="Permalink to &quot;3.1.1 物理层&quot;">​</a></h4><p>计算机在传递数据的时候传递的都是 0 和 1 的数字，而物理层关心的是用什么信号来表示 0 和 1，是否可以双向通信，最初的连接如何建立以及完成连接如何终止,物理层是为数据传输提供可靠的环境。</p><ul><li>为数据端设备提供传送数据的通路</li><li>传输数据 <ul><li>激活物理连接，在连接的设备之间连接起来形成通路</li><li>传输数据,关心如何打包数据和控制传输速度</li><li>关闭物理连接</li></ul></li></ul><p><img src="'+d+'" alt="物理层"></p><h4 id="_3-1-2-数据链路层" tabindex="-1">3.1.2 数据链路层 <a class="header-anchor" href="#_3-1-2-数据链路层" aria-label="Permalink to &quot;3.1.2 数据链路层&quot;">​</a></h4><p>数据链路层们于物理层和互联网层之间，用来向网络层提供数据，就是把源计算机网络层传过来的信息传递给目标主机。</p><ul><li>如何将数据组合成数据帧(Frame)，帧是数据链路层的传输单位</li><li>数据链路的建立、维护和拆除</li><li>帧包装、帧传输、帧同步</li><li>帧的差错恢复</li><li>流量控制</li></ul><h4 id="_3-1-3-mac-地址" tabindex="-1">3.1.3 MAC 地址 <a class="header-anchor" href="#_3-1-3-mac-地址" aria-label="Permalink to &quot;3.1.3 MAC 地址&quot;">​</a></h4><ul><li>在通信过程中是用内置在网卡内的地址来标识计算机身份的</li><li>每个网卡都有一个全球唯一的地址来标识自己，不会重复</li><li>MAC 地址 48 位的二进制组成，通常分为 6 段，用 16 进制表示</li></ul><p><img src="'+u+'" alt="信号"></p><h3 id="_3-2-互联网层-网络层" tabindex="-1">3.2 互联网层(网络层) <a class="header-anchor" href="#_3-2-互联网层-网络层" aria-label="Permalink to &quot;3.2 互联网层(网络层)&quot;">​</a></h3><ul><li>位于传输层和网络接口层之间,用于把数据从源主机经过若干个中间节点传送到目标主机,并向传输层提供最基础的数据传输服务,它要提供路由和选址的工作</li></ul><p><img src="'+_+'" alt="网络层"></p><h4 id="_3-2-1-选址" tabindex="-1">3.2.1 选址 <a class="header-anchor" href="#_3-2-1-选址" aria-label="Permalink to &quot;3.2.1 选址&quot;">​</a></h4><p>交换机是靠 MAC 来寻址的，而因为 MAC 地址是无层次的,所以要靠 IP 地址来确认计算机的位置,这就是选址</p><p><img src="'+m+'" alt="网络层"></p><p><img src="https://p.ssl.qhimg.com/t0123c4234759d969dc.jpg" alt="信封"></p><h4 id="_3-2-2-路由" tabindex="-1">3.2.2 路由 <a class="header-anchor" href="#_3-2-2-路由" aria-label="Permalink to &quot;3.2.2 路由&quot;">​</a></h4><p>在能够选择的多条道路之间选择一条最短的路径就是路由的工作</p><p><img src="'+P+'" alt="网络层"></p><h4 id="_3-2-3-ip" tabindex="-1">3.2.3 IP <a class="header-anchor" href="#_3-2-3-ip" aria-label="Permalink to &quot;3.2.3 IP&quot;">​</a></h4><p>在网络中，每台计算机都有一个唯一的地址，方便别人找到它，这个地址称为 IP 地址。</p><h5 id="_3-2-3-1-ip-头部" tabindex="-1">3.2.3.1 IP 头部 <a class="header-anchor" href="#_3-2-3-1-ip-头部" aria-label="Permalink to &quot;3.2.3.1 IP 头部&quot;">​</a></h5><p><img src="'+b+'" alt="ipheader"></p><ul><li>版本</li><li>首部长部</li><li>优先级与服务类型</li><li>总长度 该字段用以指示整个 IP 数据包的长度，最长为 65535 字节，包括头和数据</li><li>标识符 唯一标识主机发送的每一份数据报</li><li>标志 分为 3 个字段，依次为保留位、不分片位和更多片位 <ul><li>保留位：一般被置为 0</li><li>不分片位：表示该数据报是否被分片，如果被置为 1，则不能对数据报进行分片，如果要对其进行分片处理，就应将其置为 0</li><li>更多片位：除了最后一个分片，其他每个组成数据报的片都要将该位置设置为 1.</li></ul></li><li>段偏移量 该分片相对于原始数据报开始处位置的偏移量</li><li>TTL(Time to Live 生存时间) 该字段用于表示 IP 数据包的生命周期，可以防止一个数据包在网络中无限循环地发下去。TTL 的意思是一个数据包在被丢弃之前在网络中的最大周转时间。该数据包经过的每一个路由器都会检查该字段中的值，当 TTL 的值为 0 时此数据包会被丢弃。TTL 对应于一个数据包通过路由器的数目，一个数据包每经过一个路由器，TTL 将减去 1。</li><li>协议号 用以指示 IP 数据包中封装的是哪个协议</li><li>首部校验和 检验和是 16 位的错误检测字段。目的主机和网络中的每个网关都要重新计算报头的校验和，一样表示没有改动过.</li><li>源 IP 地址 该字段用于表示数据包的源地址，指的是发送该数据包的设备的网络地址</li><li>目标 IP 地址 该字段用于表示数据包的目标的地址，指的是接收节点的网络地址</li></ul><h5 id="_3-2-3-2-ip-地址格式" tabindex="-1">3.2.3.2 IP 地址格式 <a class="header-anchor" href="#_3-2-3-2-ip-地址格式" aria-label="Permalink to &quot;3.2.3.2 IP 地址格式&quot;">​</a></h5><ul><li>IP 地址是一个网络编码，用来确定网络中的一个节点。</li><li>IP 地址是由 32 位二进制(32bit)组成</li></ul><p><img src="'+i+'" alt="IP地址"></p><h5 id="_3-2-3-3-ip-地址组成" tabindex="-1">3.2.3.3 IP 地址组成 <a class="header-anchor" href="#_3-2-3-3-ip-地址组成" aria-label="Permalink to &quot;3.2.3.3 IP 地址组成&quot;">​</a></h5><ul><li>网络部分(NETWORK)</li><li>主机部分(HOST)</li></ul><p><img src="'+g+'" alt="compose"></p><h5 id="_3-2-3-4-ip-地址表示" tabindex="-1">3.2.3.4 IP 地址表示 <a class="header-anchor" href="#_3-2-3-4-ip-地址表示" aria-label="Permalink to &quot;3.2.3.4 IP 地址表示&quot;">​</a></h5><p><img src="'+i+'" alt="compose"></p><h5 id="_3-2-3-5-ip-地址的分类" tabindex="-1">3.2.3.5 IP 地址的分类 <a class="header-anchor" href="#_3-2-3-5-ip-地址的分类" aria-label="Permalink to &quot;3.2.3.5 IP 地址的分类&quot;">​</a></h5><ul><li>IP 地址的网络部分是由 Internet 地址分配机构来统一分配的，这样可以保证 IP 的唯一性。</li><li>ip 地址中全为 1 的 ip 即 255.255.255.255，它称为限制广播地址，如果将其作为数据包的目标地址可以理解为发送到所有网络的所有主机</li><li>ip 地址中全为 0 的 ip 即 0.0.0.0，它表示启动时的 ip 地址，其含义就是尚未未分配时的 ip 地址</li><li>127 是用来进行本机测试的，除了 127.255.255.255 外，其它的 127 开头的地址都代表本机</li></ul><p><img src="'+q+'" alt="compose"></p><h5 id="_3-2-3-6-公有地址和私有地址" tabindex="-1">3.2.3.6 公有地址和私有地址 <a class="header-anchor" href="#_3-2-3-6-公有地址和私有地址" aria-label="Permalink to &quot;3.2.3.6 公有地址和私有地址&quot;">​</a></h5><p>私有 IP</p><ul><li>A 类私有 IP：10.0.0.0 ~ 10.255.255.255</li><li>B 类私有 IP：172.16.0.0 ~ 172.31.255.255</li><li>C 类私有 IP：192.168.0.0 ~ 192.168.255.255</li></ul><p>其他范围的 IP 均为公有 IP 地址</p><h5 id="_3-2-3-7-子网掩码" tabindex="-1">3.2.3.7 子网掩码 <a class="header-anchor" href="#_3-2-3-7-子网掩码" aria-label="Permalink to &quot;3.2.3.7 子网掩码&quot;">​</a></h5><p>子网掩码(subnet mask)又叫子网络遮罩，它是一种用来指明一个 IP 地址的哪些位标识的是主机所在的子网，以及哪些位标识的是主机位的掩码。 子网掩码不能单独存在，它必须结合 IP 地址一起使用。 子网掩码只有一个作用，就是将某个 IP 地址划分成网络地址和主机地址两部分。</p><ul><li>子网掩码也是 32 个二进制位</li><li>对应 IP 的网络部分用 1 表示</li><li>对应 IP 地址的主机部分用 0 表示</li><li>IP 地址和子网掩码做逻辑与运算得到网络地址 <ul><li>0 和任何数相与都是 0</li><li>1 和任何数相与都等于任何数本身</li></ul></li><li>A B C 三类地址都有自己默认的子网掩码 <ul><li>A 类 255.0.0.0</li><li>B 类 255.255.0.0</li><li>C 类 255.255.255.0</li></ul></li></ul><p><img src="'+C+'" alt="transfer"></p><h3 id="_3-3-传输层" tabindex="-1">3.3 传输层 <a class="header-anchor" href="#_3-3-传输层" aria-label="Permalink to &quot;3.3 传输层&quot;">​</a></h3><p>位于应用层和网络接口层之间</p><p>传输层是面向连接的、可靠的的进程到进程通信的协议。TCP 提供全双工服务，即数据可在同一时间双向传播。TCP 将若干个字节构成一个分组，此分组称为报文段(Segment)。提供了一种端到端的连接。 传输层的协议主要是 TCP ，TCP(Transimision Control Protocal)是一种可靠的、面向连接的协议，传输效率低。</p><ul><li>是面向连接的、可靠的的进程到进程通信的协议</li><li>TCP 提供全双工服务，即数据可在同一时间双向传播</li><li>TCP 将若干个字节构成一个分组，此分组称为报文段(Segment)</li></ul><p><img src="'+I+'" alt="transfer"></p><h4 id="_3-3-1-传输层的功能" tabindex="-1">3.3.1 传输层的功能 <a class="header-anchor" href="#_3-3-1-传输层的功能" aria-label="Permalink to &quot;3.3.1 传输层的功能&quot;">​</a></h4><p>提供了一种端到端的连接</p><p><img src="'+T+'" alt="connect"></p><h4 id="_3-3-2-对可靠性要求高的上层协议-实现可靠性的保证" tabindex="-1">3.3.2 对可靠性要求高的上层协议，实现可靠性的保证 <a class="header-anchor" href="#_3-3-2-对可靠性要求高的上层协议-实现可靠性的保证" aria-label="Permalink to &quot;3.3.2 对可靠性要求高的上层协议，实现可靠性的保证&quot;">​</a></h4><ul><li>如果数据丢失、损坏的情况下如何保证可靠性</li><li>网络层只管传递数据，成功与否并不关心</li></ul><h4 id="_3-3-3-协议分类" tabindex="-1">3.3.3 协议分类 <a class="header-anchor" href="#_3-3-3-协议分类" aria-label="Permalink to &quot;3.3.3 协议分类&quot;">​</a></h4><ul><li>TCP(Transimision Control Protocal) <ul><li>传输控制协议</li><li>可靠的、面向连接的协议</li><li>传输效率低</li></ul></li><li>UDP(User Datagram Protocal) <ul><li>用户数据报协议</li><li>不可靠的、无连接的服务</li><li>传输效率高</li></ul></li></ul><h4 id="_3-3-4-tcp-功能" tabindex="-1">3.3.4 TCP 功能 <a class="header-anchor" href="#_3-3-4-tcp-功能" aria-label="Permalink to &quot;3.3.4 TCP 功能&quot;">​</a></h4><ul><li>将数据进行分段打包传输</li><li>对每个数据包编号控制顺序</li><li>运输中丢失、重发和丢弃处理</li><li>流量控制避免拥塞</li></ul><h5 id="_3-3-4-1-tcp-数据包封装" tabindex="-1">3.3.4.1 TCP 数据包封装 <a class="header-anchor" href="#_3-3-4-1-tcp-数据包封装" aria-label="Permalink to &quot;3.3.4.1 TCP 数据包封装&quot;">​</a></h5><p><img src="'+N+'" alt="connect"></p><ul><li>源端口号和目标端口号，计算机通过端口号识别访问哪个服务,比如 http 服务或 ftp 服务，发送方端口号是进行随机端口，目标端口号决定了接收方哪个程序来接收 <img src="'+k+'" alt="connect"></li><li>32 位序列号 TCP 用序列号对数据包进行标记，以便在到达目的地后重新重装，假设当前的序列号为 s，发送数据长度为 l，则下次发送数据时的序列号为 s + l。在建立连接时通常由计算机生成一个随机数作为序列号的初始值 <img src="'+f+'" alt="connect"></li><li>确认应答号 它等于下一次应该接收到的数据的序列号。假设发送端的序列号为 s，发送数据的长度为 l，那么接收端返回的确认应答号也是 s + l。发送端接收到这个确认应答后，可以认为这个位置以前所有的数据都已被正常接收。</li><li>首部长度：TCP 首部的长度，单位为 4 字节。如果没有可选字段，那么这里的值就是 5。表示 TCP 首部的长度为 20 字节。 <img src="'+S+'" alt="connect"></li><li>控制位 TCP 的连接、传输和断开都受这六个控制位的指挥 <ul><li>PSH(push 急迫位) 缓存区将满，立刻传输速度</li><li>RST(reset 重置位) 连接断了重新连接</li><li>URG(urgent 紧急位) 紧急信号</li></ul></li><li>紧急指针：尽在 URG(urgent 紧急) 控制位为 1 时有效。表示紧急数据的末尾在 TCP 数据部分中的位置。通常在暂时中断通信时使用（比如输入 Ctrl + C）。</li></ul><p><img src="'+E+'" alt="tcpack"></p><ul><li>ACK(acknowledgement 确认)为 1 表示确认号 <img src="'+F+'" alt="tcpsyn"></li><li>SYN(synchronous 建立联机) 同步序号位 TCP 建立连接时要将这个值设为 1 <img src="'+x+'" alt="tcpfin"></li><li>FIN 发送端完成位，提出断开连接的一方把 FIN 置为 1 表示要断开连接 <img src="'+L+'" alt="tcpwindow"></li><li>窗口值 说明本地可接收数据段的数目，这个值的大小是可变的。当网络通畅时将这个窗口值变大加快传输速度，当网络不稳定时减少这个值可以保证网络数据的可靠传输。它是来在 TCP 传输中进行流量控制的</li><li>窗口大小：用于表示从应答号开始能够接受多少个 8 位字节。如果窗口大小为 0，可以发送窗口探测。 <img src="'+A+'" alt="connect"></li><li>用来做差错控制，TCP 校验和的计算包括 TCP 首部、数据和其它填充字节。在发送 TCP 数据段时，由发送端计算校验和，当到达目的地时又进行一次检验和计算。如果两次校验 和一致说明数据是正确的，否则 将认为数据被破坏，接收端将丢弃该数据</li></ul><h5 id="_3-2-4-2-握手和断开" tabindex="-1">3.2.4.2 握手和断开 <a class="header-anchor" href="#_3-2-4-2-握手和断开" aria-label="Permalink to &quot;3.2.4.2 握手和断开&quot;">​</a></h5><p>TCP 是面向连接的，无论哪一方向另一方发送数据之前，都必须先在双方之间建立一条连接。在 TCP/IP 协议中，TCP 协议提供可靠的连接服务，连接是通过三次握手进行初始化的。三次握手的目的是同步连接双方的序列号和确认号 并交换 TCP 窗口大小信息。</p><ul><li>TCP 是面向连接的协议，它在源点和终点之间建立虚拟连接，而不是物理连接</li><li>在数据通信之前，发送端与接收端要先建立连接，等数据发送结束后，双方再断开连接</li><li>TCP 连接的每一方都是由一个 IP 地址和一个端口组成</li></ul><p><img src="'+D+'" alt="sequencenumber"></p><h6 id="_3-2-4-2-1-三次握手" tabindex="-1">3.2.4.2.1 三次握手 <a class="header-anchor" href="#_3-2-4-2-1-三次握手" aria-label="Permalink to &quot;3.2.4.2.1 三次握手&quot;">​</a></h6><p>为了方便描述我们将主动发起请求的 172.16.17.94:8080 主机称为客户端，将返回数据的主机 172.16.17.94:8080 称为服务器，以下也是。.</p><p><img src="'+w+'" alt="三次握手"></p><ul><li>第一次握手: 建立连接。客户端发送连接请求，发送 SYN 报文，将 seq 设置为 0。然后，客户端进入 SYN_SEND 状态，等待服务器的确认。</li><li>第二次握手: 服务器收到客户端的 SYN 报文段。需要对这个 SYN 报文段进行确认，发送 ACK 报文，将 ack 设置为 1。同时，自己还要发送 SYN 请求信息，将 seq 为 0。服务器端将上述所有信息一并发送给客户端，此时服务器进入 SYN_RECV 状态。</li><li>第三次握手: 客户端收到服务器的 ACK 和 SYN 报文后，进行确认，然后将 ack 设置为 1，seq 设置为 1，向服务器发送 ACK 报文段，这个报文段发送完毕以后，客户端和服务器端都进入 ESTABLISHED 状态，完成 TCP 三次握手。</li></ul><p>第二种说法</p><ul><li>第一次握手主机 A 通过一个标识为 SYN 标识位的数据段发送给主机 B 请求连接，通过该数据段告诉主机 B 希望建立连接，需要 B 应答，并告诉主机 B 传输的起始序列号</li><li>第二次握手是主机 B 用一个确认应答 ACK 和同步序列号 SYNC 标志位的数据段来响应主机 A，一是发送 ACK 告诉主机 A 收到了数据段，二是通知主机 A 从哪个序列号做标记。</li><li>第三次握手是主机 A 确认收到了主机 B 的数据段并可以开始传输实际数据。</li></ul><h6 id="数据传输" tabindex="-1">数据传输 <a class="header-anchor" href="#数据传输" aria-label="Permalink to &quot;数据传输&quot;">​</a></h6><p><img src="'+B+'" alt="数据传输"></p><ul><li>客户端先向服务器发送数据，该数据报是长度为 159 的数据。</li><li>服务器收到报文后, 也向客户端发送了一个数据进行确认（ACK），并且返回客户端要请求的数据，数据的长度为 111，将 seq 设置为 1，ack 设置为 160（1 + 159）。</li><li>客户端收到服务器返回的数据后进行确认（ACK），将 seq 设置为 160， ack 设置为 112（1 + 111）。</li></ul><h6 id="_3-2-4-2-2-四次断开" tabindex="-1">3.2.4.2.2 四次断开 <a class="header-anchor" href="#_3-2-4-2-2-四次断开" aria-label="Permalink to &quot;3.2.4.2.2 四次断开&quot;">​</a></h6><p><img src="'+O+'" alt="goodbye2"></p><ul><li>第一次挥手：客户端向服务器发送一个 FIN 报文段，将设置 seq 为 160 和 ack 为 112，;此时，客户端进入 FIN_WAIT_1 状态,这表示客户端没有数据要发送服务器了，请求关闭连接;</li><li>第二次挥手：服务器收到了客户端发送的 FIN 报文段，向客户端回一个 ACK 报文段，ack 设置为 1，seq 设置为 112;服务器进入了 CLOSE_WAIT 状态，客户端收到服务器返回的 ACK 报文后，进入 FIN_WAIT_2 状态;</li><li>第三次挥手：服务器会观察自己是否还有数据没有发送给客户端，如果有，先把数据发送给客户端，再发送 FIN 报文；如果没有，那么服务器直接发送 FIN 报文给客户端。请求关闭连接，同时服务器进入 LAST_ACK 状态;</li><li>第四次挥手：客户端收到服务器发送的 FIN 报文段，向服务器发送 ACK 报文段，将 seq 设置为 161，将 ack 设置为 113，然后客户端进入 TIME_WAIT 状态;服务器收到客户端的 ACK 报文段以后，就关闭连接;此时，客户端等待 2MSL 后依然没有收到回复，则证明 Server 端已正常关闭，客户端也可以关闭连接了。</li></ul><blockquote><p>注意：在握手和挥手时确认号应该是对方序列号加 1,传输数据时则是对方序列号加上对方携带应用层数据的长度。</p></blockquote><ul><li>主机 A 发送 FIN 控制位发出断开连接的请求</li><li>主机 B 进行响应，确认收到断开连接请求</li><li>主机 B 提出反方向的关闭要求</li><li>主机 A 确认收到的主机 B 的关闭连接请求</li></ul><h6 id="_3-2-4-2-3-抓包" tabindex="-1">3.2.4.2.3 抓包 <a class="header-anchor" href="#_3-2-4-2-3-抓包" aria-label="Permalink to &quot;3.2.4.2.3 抓包&quot;">​</a></h6><p><img src="'+M+'" alt="sequencenumber"></p><h5 id="_3-3-5-tcp-格式" tabindex="-1">3.3.5 TCP 格式 <a class="header-anchor" href="#_3-3-5-tcp-格式" aria-label="Permalink to &quot;3.3.5 TCP 格式&quot;">​</a></h5><p><img src="'+U+'" alt="tcpframe"></p><ul><li>源端口号和目标端口号，计算机通过端口号识别访问哪个服务,比如 http 服务或 ftp 服务，发送方端口号是进行随机端口，目标端口号决定了接收方哪个程序来接收</li><li>32 位序列号 TCP 用序列号对数据包进行标记，以便在到达目的地后重新重装，假设当前的序列号为 s，发送数据长度为 l，则下次发送数据时的序列号为 s + l。在建立连接时通常由计算机生成一个随机数作为序列号的初始值</li><li>确认应答号 它等于下一次应该接收到的数据的序列号。假设发送端的序列号为 s，发送数据的长度为 l，那么接收端返回的确认应答号也是 s + l。发送端接收到这个确认应答后，可以认为这个位置以前所有的数据都已被正常接收。</li><li>首部长度：TCP 首部的长度，单位为 4 字节。如果没有可选字段，那么这里的值就是 5。表示 TCP 首部的长度为 20 字节。</li><li>控制位 TCP 的连接、传输和断开都受这六个控制位的指挥 <ul><li>PSH(push 急迫位) 缓存区将满，立刻传输速度</li><li>RST(reset 重置位) 连接断了重新连接</li><li>URG(urgent 紧急位) 紧急信号</li><li>ACK(acknowledgement 确认)为 1 表示确认号</li><li>SYN(synchronous 建立联机) 同步序号位 TCP 建立连接时要将这个值设为 1</li><li>FIN 发送端完成位，提出断开连接的一方把 FIN 置为 1 表示要断开连接</li></ul></li><li>窗口值 说明本地可接收数据段的数目，这个值的大小是可变的。当网络通畅时将这个窗口值变大加快传输速度，当网络不稳定时减少这个值可以保证网络数据的可靠传输。它是来在 TCP 传输中进行流量控制的</li><li>窗口大小：用于表示从应答号开始能够接受多少个 8 位字节。如果窗口大小为 0，可以发送窗口探测。</li><li>效验和: 用来做差错控制，TCP 校验和的计算包括 TCP 首部、数据和其它填充字节。在发送 TCP 数据段时，由发送端计算校验和，当到达目的地时又进行一次检验和计算。如果两次校验 和一致说明数据是正确的，否则 将认为数据被破坏，接收端将丢弃该数据</li><li>紧急指针：尽在 URG(urgent 紧急) 控制位为 1 时有效。表示紧急数据的末尾在 TCP 数据部分中的位置。通常在暂时中断通信时使用（比如输入 Ctrl + C）。</li></ul><h3 id="_3-4-udp" tabindex="-1">3.4 UDP <a class="header-anchor" href="#_3-4-udp" aria-label="Permalink to &quot;3.4 UDP&quot;">​</a></h3><ul><li>UDP 是一个无连接、不保证可靠性的传输层协议，也就是说发送端不关心发送的数据是否到达目标主机、数据是否出错等，收到数据的主机也不会告诉 发送方是否收到了数据，它的可靠性由上层协议来保障</li><li>首部结构简单，在数据传输时能实现最小的开销，如果进程想发送很短的报文而对可靠性要求不高可以使用</li></ul><h4 id="_3-4-1-udp-的封装格式" tabindex="-1">3.4.1 UDP 的封装格式 <a class="header-anchor" href="#_3-4-1-udp-的封装格式" aria-label="Permalink to &quot;3.4.1 UDP 的封装格式&quot;">​</a></h4><p><img src="'+K+'" alt="connect"></p><p><img src="'+R+'" alt="connect"></p><p><img src="'+y+'" alt="connect"></p><h4 id="_3-4-2-udp-的应用" tabindex="-1">3.4.2 UDP 的应用 <a class="header-anchor" href="#_3-4-2-udp-的应用" aria-label="Permalink to &quot;3.4.2 UDP 的应用&quot;">​</a></h4><ul><li>QQ</li><li>视频软件</li><li>TFTP 简单文件传输协议(短信)</li></ul><h4 id="_3-4-3-dns-服务器" tabindex="-1">3.4.3 DNS 服务器 <a class="header-anchor" href="#_3-4-3-dns-服务器" aria-label="Permalink to &quot;3.4.3 DNS 服务器&quot;">​</a></h4><h5 id="_3-4-3-1-域名" tabindex="-1">3.4.3.1 域名 <a class="header-anchor" href="#_3-4-3-1-域名" aria-label="Permalink to &quot;3.4.3.1 域名&quot;">​</a></h5><ul><li>域名空间结构</li><li>根域</li><li>顶级域 <ul><li>组织域</li><li>国家/地区域名</li></ul></li><li>二级域名</li></ul><p><img src="'+v+'" alt="域名"></p><h5 id="_3-4-3-2-dns-服务器" tabindex="-1">3.4.3.2 DNS 服务器 <a class="header-anchor" href="#_3-4-3-2-dns-服务器" aria-label="Permalink to &quot;3.4.3.2 DNS 服务器&quot;">​</a></h5><p>DNS 是 Domain Name Service 的缩写，DNS 服务器进行域名和与之对应的 IP 地址转换的服务器</p><ul><li>IP 地址不易记忆</li><li>早期使用 Hosts 文件解析域名 <ul><li>主要名称重复</li><li>主机维护困难</li></ul></li><li>DNS(Domain Name System 域名系统) <ul><li>分布式</li><li>层次性</li></ul></li></ul><h5 id="_3-4-3-3-查找过程" tabindex="-1">3.4.3.3 查找过程 <a class="header-anchor" href="#_3-4-3-3-查找过程" aria-label="Permalink to &quot;3.4.3.3 查找过程&quot;">​</a></h5><p><img src="'+H+'" alt="dns"></p><ul><li>客户端向本地域名服务器发出请求，我要访问<a href="http://www.163.xn--com%2Cip-eu6jr5qee876bm8r511dm13cmsa/" target="_blank" rel="noreferrer">www.163.com，请告诉我它的 IP 地址</a></li><li>本地 DNS 服务器向 DNS 根服务器发出请求，根 DNS 服务器会告诉本地服务器(.com)的服务器地址</li><li>本地 DNS 服务器会向(.com 域)发请求，会得到(163.com)的服务器地址</li><li>本地 DNS 服务器会向(163.com)发请求,会得到(<a href="http://www.163.xn--com" target="_blank" rel="noreferrer">www.163.com)的 IP 地址 1.1.1.1</a>ip1-2f5pqft559a.1.1.1/)</li><li>本地 DNS 服务器向客户端回复域名(<a href="http://www.163.xn--com" target="_blank" rel="noreferrer">www.163.com)对应的 IP 地址是 1.1.1.1</a>ip1-2f5pqf339c0hi6w1az59c.1.1.1/)</li></ul><h3 id="_3-5-应用层" tabindex="-1">3.5 应用层 <a class="header-anchor" href="#_3-5-应用层" aria-label="Permalink to &quot;3.5 应用层&quot;">​</a></h3><h4 id="_3-5-1-协议" tabindex="-1">3.5.1 协议 <a class="header-anchor" href="#_3-5-1-协议" aria-label="Permalink to &quot;3.5.1 协议&quot;">​</a></h4><p><img src="'+j+'" alt="connect"></p><h4 id="_3-5-2-应用层常见协议" tabindex="-1">3.5.2 应用层常见协议 <a class="header-anchor" href="#_3-5-2-应用层常见协议" aria-label="Permalink to &quot;3.5.2 应用层常见协议&quot;">​</a></h4><ul><li>HTTP 超文件传输协议</li><li>FTP 文件传输协议</li><li>SMTP(发送邮件)和 POP3(接收邮件)</li></ul><h3 id="_3-6-案例" tabindex="-1">3.6 案例 <a class="header-anchor" href="#_3-6-案例" aria-label="Permalink to &quot;3.6 案例&quot;">​</a></h3><p>数据-&gt;传输层(包)-&gt;网络层(段 Segment)-&gt;数据链路层(帧)</p><h4 id="_3-6-1-发送方是从高层到低层封装数据" tabindex="-1">3.6.1 发送方是从高层到低层封装数据 <a class="header-anchor" href="#_3-6-1-发送方是从高层到低层封装数据" aria-label="Permalink to &quot;3.6.1 发送方是从高层到低层封装数据&quot;">​</a></h4><ul><li>在应用层要把各式各样的数据如字母、数字、汉字、图片等转换成二进制</li><li>在 TCP 传输层中，上层的数据被分割成小的数据段，并为每个分段后的数据封装 TCP 报文头部</li><li>在 TCP 头部有一个关键的字段信息端口号，它用于标识上层的协议或应用程序，确保上层数据的正常通信</li><li>计算机可以多进程并发运行，例如在发邮件的同时也可以通过浏览器浏览网页，这两种应用通过端口号进行区分</li><li>在网络层，上层数据被封装上亲的报文头部(IP 头部)，上层的数据是包括 TCP 头部的。IP 地址包括的最关键字段信息就是 IP 地址，用于标识网络的逻辑地址。</li><li>数据链路径层，上层数据成一个 MAC 头部，内部有最关键的是 MAC 地址。MAC 地址就是固化在硬件设备内部的全球唯一的物理地址。</li><li>在物理层，无论在之前哪一层封装的报文头和还是上层数据都是由二进制组成的，物理将这些二进制数字比特流转换成电信号在网络中传输</li></ul><p><img src="'+Y+'" alt="connect"></p><h4 id="_3-6-2-接收方是从低层到高层解封装" tabindex="-1">3.6.2 接收方是从低层到高层解封装 <a class="header-anchor" href="#_3-6-2-接收方是从低层到高层解封装" aria-label="Permalink to &quot;3.6.2 接收方是从低层到高层解封装&quot;">​</a></h4><ul><li>数据封装完毕传输到接收方后，将数据要进行解封装</li><li>在物理层，先把电信号转成二进制数据，并将数据传送至数据链路层</li><li>在数据链路层，把 MAC 头部拆掉，并将剩余的数据传送至上一层</li><li>在网络层，数据的 IP 头部被拆掉，并将剩余的数据送至上一层</li><li>在传输层，把 TCP 头部拆掉，将真实的数据传送至应用层</li></ul><p><img src="'+W+'" alt="connect"></p><h4 id="_3-6-3-真实网络环境" tabindex="-1">3.6.3 真实网络环境 <a class="header-anchor" href="#_3-6-3-真实网络环境" aria-label="Permalink to &quot;3.6.3 真实网络环境&quot;">​</a></h4><ul><li>发送方和接收方中间可能会有多个硬件中转设备</li><li>中间可能会增加交换机和路由器</li><li>数据在传输过程中不断地进行封装和解封装的过程，每层设备只能处理哪一层的数据 <ul><li>交换机属于数据链路层</li><li>路由器属于网络层</li></ul></li></ul><p><img src="'+Q+'" alt="分层模型"></p><h2 id="_4-附录" tabindex="-1">4. 附录 <a class="header-anchor" href="#_4-附录" aria-label="Permalink to &quot;4. 附录&quot;">​</a></h2><h3 id="_4-1-不同层中的称谓" tabindex="-1">4.1 不同层中的称谓 <a class="header-anchor" href="#_4-1-不同层中的称谓" aria-label="Permalink to &quot;4.1 不同层中的称谓&quot;">​</a></h3><ul><li>数据帧（Frame）：是一种信息单位，它的起始点和目的点都是<strong>数据链路层</strong>。</li><li>数据包（Packet）：也是一种信息单位，它的起始和目的地是<strong>网络层</strong>。</li><li>段（Segment）：通常是指起始点和目的地都是<strong>传输层</strong>的信息单元。</li><li>消息（message）：是指起始点和目的地都在网络层以上（经常在<strong>应用层</strong>）的信息单元。</li></ul><h3 id="_4-2-ip-头服务类型" tabindex="-1">4.2 IP 头服务类型 <a class="header-anchor" href="#_4-2-ip-头服务类型" aria-label="Permalink to &quot;4.2 IP 头服务类型&quot;">​</a></h3><ul><li>IP 首部中的服务类型（TOS）</li><li>TOS 包括共 8 位，包括 3 bit 的优先权字段（取值可以从 000-111 所有值），4 bit 的 TOS 子字段和 1 bit 未用位但必须置 0。</li><li>3bit 的 8 个优先级的定义如下： <ul><li>111--Network Control(网络控制）一般保留给网络控制数据使用，如路由。</li><li>110--Internetwork Control(网间控制)</li><li>101--Critic(关键)语音数据使用。</li><li>100--Flash Override(疾速)视频会议和视频流使用。</li><li>011--Flash(闪速)语音控制数据使用。</li><li>010--Immediate(快速)数据业务使用</li><li>001--Priority(优先)数据业务使用</li><li>000--Routine(普通)默认标记值。</li></ul></li><li>4 bit 的 TOS 分别代表：最小时延、最大吞吐量、最高可靠性和最小费用。4 bit 中只能置其中 1 bit。如果所有 4 bit 均为 0，那么就意味着是一般服务。</li><li>Telnet、Rlogin 这两个交互应用要求最小的传输时延，FTP 文件传输要求最大吞吐量，最高可靠性是指网络管理（SNMP）和路由选择协议。用户网络新闻要求最小费用</li></ul><h3 id="_4-3-握手和断开" tabindex="-1">4.3 握手和断开 <a class="header-anchor" href="#_4-3-握手和断开" aria-label="Permalink to &quot;4.3 握手和断开&quot;">​</a></h3><p><img src="'+z+'" alt="sequencenumber"></p><p><img src="'+J+'" alt="sequencenumber"></p><p><img src="'+G+'" alt="sequencenumber"></p><h2 id="_5-参考" tabindex="-1">5. 参考 <a class="header-anchor" href="#_5-参考" aria-label="Permalink to &quot;5. 参考&quot;">​</a></h2><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=2665513094&amp;idx=1&amp;sn=a2accfc41107ac08d74ec3317995955e#rd" target="_blank" rel="noreferrer">TCP/IP 之 大明王朝邮差</a></li></ul><h2 id="_6-问题" tabindex="-1">6. 问题 <a class="header-anchor" href="#_6-问题" aria-label="Permalink to &quot;6. 问题&quot;">​</a></h2><p>1.为什么需要三次握手? 确保双方收发都是正常的</p><p>2.为什么需要四次挥手? 双方数据发送完毕，都认为可以断开</p><p>3.为什么需要等待? A 向 B 发的<code>FIN</code>可能丢失</p><p>4.为什么握手是三次，但挥手却是四次? 当 Server 端收到 FIN 报文时，很可能并不会立即关闭 SOCKET</p>',160)]))}const rl=a(V,[["render",X]]);export{tl as __pageData,rl as default};
