import{_ as e,c as s,o as n,ah as l}from"./chunks/framework.DqD713j2.js";const o="/FrontEndLearnNotes/assets/webpack-bundle-analyzer.DArGvHZn.png",p="/FrontEndLearnNotes/assets/rollup-plugin-visualizer.C9riaTFF.jpg",r="/FrontEndLearnNotes/assets/asar.zs2Kx39N.png",c="/FrontEndLearnNotes/assets/electron-version.Bj5O_oRS.jpg",B=JSON.parse('{"title":"Electron 项目打包优化配置","description":"","frontmatter":{},"headers":[],"relativePath":"Document/跨平台桌面端开发/Electron/Electron项目打包优化配置.md","filePath":"Document/跨平台桌面端开发/Electron/Electron项目打包优化配置.md","lastUpdated":1750954157000}'),t={name:"Document/跨平台桌面端开发/Electron/Electron项目打包优化配置.md"};function i(d,a,u,b,h,m){return n(),s("div",null,a[0]||(a[0]=[l('<h1 id="electron-项目打包优化配置" tabindex="-1">Electron 项目打包优化配置 <a class="header-anchor" href="#electron-项目打包优化配置" aria-label="Permalink to &quot;Electron 项目打包优化配置&quot;">​</a></h1><h2 id="打包后的文件说明" tabindex="-1">打包后的文件说明 <a class="header-anchor" href="#打包后的文件说明" aria-label="Permalink to &quot;打包后的文件说明&quot;">​</a></h2><h3 id="关键文件说明" tabindex="-1">关键文件说明 <a class="header-anchor" href="#关键文件说明" aria-label="Permalink to &quot;关键文件说明&quot;">​</a></h3><ol><li><strong>app.asar</strong></li></ol><p>将我们项目的代码进行打包后的文件。默认情况下会对我们的整个项目进行打包，包括需要使用到的在 <code>package.json</code> 中 <code>dependencies</code> 声明的包。</p><p>可以利用 asar 工具解压这个文件看下里面包含了什么。</p><p>解压工具使用文章：<a href="https://jingyan.baidu.com/article/60ccbcebb2bb1264cab197b3.html" target="_blank" rel="noreferrer">如何解压 app.asar-百度经验 (baidu.com)</a></p><h4 id="反编译-asar-文件" tabindex="-1">反编译 asar 文件 <a class="header-anchor" href="#反编译-asar-文件" aria-label="Permalink to &quot;反编译 asar 文件&quot;">​</a></h4><p>1.反编译 asar 文件，全局安装 asar</p><div class="language-bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#61AFEF;">npm</span><span style="color:#98C379;"> install</span><span style="color:#D19A66;"> -g</span><span style="color:#98C379;"> asar</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>2.将 app.asar 放在一个新建的文件夹内，然后在根目录右键单击时按住 Shift 键，选择“在此处打开 Power Shell 窗口”</p><p>在命令行中输入</p><div class="language-bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#61AFEF;">asar</span><span style="color:#98C379;"> extract</span><span style="color:#98C379;"> app.asar</span><span style="color:#98C379;"> ./</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>然后回车，即可回到文件夹查看 extract 出来的文件。注意，所输命令不带引号！“./”表示将 app.asar 反编译（解压）到根目录下，当然你也可以按需制定目标文件夹。</p><ol><li><strong>elecrton.asar</strong></li></ol><p><code>electron</code> 的 JS 部分代码。如提供 <code>remote</code>、<code>ipcMain</code>、<code>ipcRenderer</code> 等模块。</p><ol><li><strong>electron.exe</strong></li></ol><p>我们应用的主程序。一个事先就编译好的程序，功能就是运行 <code>resoruces/app.asar</code> 这个文件内所包含的项目代码。</p><h2 id="如何正确打包" tabindex="-1">如何正确打包 <a class="header-anchor" href="#如何正确打包" aria-label="Permalink to &quot;如何正确打包&quot;">​</a></h2><p>直接打包存在的问题</p><ol><li>体积大</li><li>暴露源码</li></ol><h3 id="优化方向" tabindex="-1">优化方向 <a class="header-anchor" href="#优化方向" aria-label="Permalink to &quot;优化方向&quot;">​</a></h3><p>从项目目录结构中可以看出，<code>electron.exe</code>、<code>electron.asar</code> 等文件是每个 <code>Electron</code> 应用都一样且必需的，因此我们可以优化的空间只是 <code>app.asar</code> 文件。</p><p>目前 <code>app.asar</code> 是将我们的项目整个打包，我们整个应用之所以大，原因在于 <code>node_modules</code> 文件夹特别大。因此我们要做的是我们的应用能否不打包 <code>node_modules</code> 文件夹，或者让需要打包的东西尽可能的少。</p><h2 id="打包优化" tabindex="-1">打包优化 <a class="header-anchor" href="#打包优化" aria-label="Permalink to &quot;打包优化&quot;">​</a></h2><ul><li>策略 <ul><li>缩减包体积 <ul><li>yarn autoclean -I</li><li>yarn autoclean -F</li></ul></li></ul></li><li>一些概念 <ul><li>electron-shared：所有的 electron 共享一个运行时</li><li>miniblink：国内开发者改版的浏览器的轻量内核：<a href="http://www.miniblink.net/" target="_blank" rel="noreferrer">Miniblink - 免费小巧开源的浏览器控件</a></li></ul></li></ul><h3 id="减少-dependencies-依赖" tabindex="-1">减少 <code>dependencies</code> 依赖 <a class="header-anchor" href="#减少-dependencies-依赖" aria-label="Permalink to &quot;减少 `dependencies` 依赖&quot;">​</a></h3><p>之所以需要打包 <code>dependencies</code> 中的依赖，是因为 <code>Electron</code> 是直接运行我们的源码，依赖引用的查找路径是从 <code>node_modules</code> 文件夹中查找。</p><p><strong>因此：</strong></p><p>优化应用程序体积 == 减少 <code>node_modules</code> 文件夹的大小 == 减少需要打包的依赖数量 == 减少 <code>dependencies</code> 中的依赖。</p><p><strong>如何减少 <code>dependencies</code> 中的依赖？</strong></p><p>如果我们将代码进行打包，将需要使用到的依赖直接打包进最终的文件，那就可以不需要再将 <code>node_modules</code> 打包进应用程序了。并且通过打包一方面可以减少应用的体积，另一方面也可以对我们的代码进行混淆，避免暴露我们的源码。</p><h4 id="视图层-网页界面-代码打包" tabindex="-1">视图层(网页界面)代码打包 <a class="header-anchor" href="#视图层-网页界面-代码打包" aria-label="Permalink to &quot;视图层(网页界面)代码打包&quot;">​</a></h4><p>这个和平时的网页项目一样，简单使用 <code>Webpack</code> 进行打包就好，大家都会的就不废话了~</p><p>当我们对视图层的代码打包之后，只有视图层需要用到的代码就不在需要打包进 <code>node_module</code> 文件夹中了。为了不让打包程序将这些只在视图层使用到的依赖打包进 <code>node_modules</code> 中，最简单的方式就是在 <code>package.json</code> 文件中将这部分依赖从 <code>dependencies</code> 中移动到 <code>devDependencies</code>（<code>electron-builder</code> 不会将 <code>devDependencies</code> 中的依赖打包进应用程序）。</p><p>（这样的话如果 <code>eslint</code> 配置了引用的依赖必须在 <code>denpendencies</code> 中声明的规则，则需要将其关闭）</p><h4 id="主进程-electron-层-代码打包" tabindex="-1">主进程(Electron 层)代码打包 <a class="header-anchor" href="#主进程-electron-层-代码打包" aria-label="Permalink to &quot;主进程(Electron 层)代码打包&quot;">​</a></h4><p>使用 <code>Webpack</code> 对主进程的代码打包与普通网页打包基本是一致的。需要注意的是 <code>target</code> 需要设置为 <code>electron-main</code>。</p><p>详细看 <code>Webpack</code> 中对 <code>target</code> 字段的说明：<a href="https://webpack.js.org/configuration/target/" target="_blank" rel="noreferrer">Webpack - Target</a></p><h3 id="必须保留的-dependencies-依赖" tabindex="-1">必须保留的 <code>dependencies</code> 依赖 <a class="header-anchor" href="#必须保留的-dependencies-依赖" aria-label="Permalink to &quot;必须保留的 `dependencies` 依赖&quot;">​</a></h3><p>当把上面的步骤都做好后，我们将 <code>node_modules</code> 从需要打包的文件列表中删除。但打包后会发现 <code>node_modules</code> 文件夹还是会被打包进最终的应用中。</p><p>实际上 <code>electron-builder</code> 保留 <code>node_modules</code> 是有原因的。我们使用 <code>Electron</code> 开发是为了可以实现跨平台，JS 代码借助 <code>Electron</code> 确实是可以实现跨平台，但有些 npm 包为了性能上或者其他因素的考虑，并非使用 JS 而是 C、C++ 来实现。这些包是需要根据平台来编译后才能使用。<code>electron-builder</code> 打包时也是在打包某个平台的版本时重新安装相对应平台的依赖包。</p><h3 id="双-package-json-项目结构" tabindex="-1">双 <code>package.json</code> 项目结构 <a class="header-anchor" href="#双-package-json-项目结构" aria-label="Permalink to &quot;双 `package.json` 项目结构&quot;">​</a></h3><p>上面说到，为不不让 <code>electron-builder</code> 将运行时需要用到但是我们自己已经打包好的依赖放进 <code>node_modules</code> 里一起打包，我们是将那些依赖放进了 <code>devDependencies</code> 中，因为即使设置不打包 <code>node_modules</code> 还是会帮我们打包进我们的应用。</p><p>虽然将不需要打包的依赖放进 <code>devDependencies</code> 可以解决这个问题，但是不太优雅。</p><p>而 <code>electron-builder</code> 也提供了另外一种方式帮助我们更好的管理依赖：也就是双 <code>package.json</code> 项目结构。</p><h4 id="双-packajson-json-文件进行依赖管理" tabindex="-1">双 <code>packajson.json</code> 文件进行依赖管理 <a class="header-anchor" href="#双-packajson-json-文件进行依赖管理" aria-label="Permalink to &quot;双 `packajson.json` 文件进行依赖管理&quot;">​</a></h4><p><code>electron-builder</code> 对双 <code>package.json</code> 的解释：<a href="https://www.electron.build/tutorials/two-package-structure" target="_blank" rel="noreferrer">Two package.json Structure - electron-builder</a></p><p><strong>双 <code>packajson.json</code> 具体是怎么样？</strong></p><ol><li>在原本的项目下新建一个需要打包的文件夹 <code>app</code>。</li></ol><p>如果项目下有 <code>app</code> 文件夹，<code>electron-builder</code> 在打包时会以改文件夹为打包的根文件夹，即只会打包改文件夹下的文件。配置中设置的需要打包的文件/文件夹也是基于 <code>app</code> 文件夹来设置。如设置</p><div class="language-javascript line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#98C379;">&quot;build&quot;</span><span style="color:#ABB2BF;">: {</span></span>\n<span class="line"><span style="color:#98C379;">    &quot;files&quot;</span><span style="color:#ABB2BF;">: [</span></span>\n<span class="line"><span style="color:#98C379;">        &quot;dist&quot;</span></span>\n<span class="line"><span style="color:#ABB2BF;">    ]</span></span>\n<span class="line"><span style="color:#ABB2BF;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>则只会打包 <code>app/dist</code> 这个文件夹下的内容。</p><ol><li><code>app</code> 文件夹下创建 <code>package.json</code> 文件</li></ol><p>由于只会打包 <code>app</code> 下的文件，因此我们也需要在 <code>app</code> 文件夹下创建 <code>package.json</code> 文件，在该文件中配置我们应用的名称、版本、主进程入口文件等信息。</p><ol><li>依赖管理</li></ol><p>接下来，我们可以把只在开发中使用到的依赖装在整个项目的根目录下，将需要打包的依赖(与平台相关的或者运行时需要的依赖)装在 <code>app</code> 文件夹下。因为现在打包工具不会打包除 <code>app</code> 文件夹外的文件，因此也不用担心安装在根目录下的 <code>dependencies</code> 依赖会被打包进去。</p><h3 id="进一步减少体积" tabindex="-1">进一步减少体积 <a class="header-anchor" href="#进一步减少体积" aria-label="Permalink to &quot;进一步减少体积&quot;">​</a></h3><p>将 <code>node_modules</code> 文件夹移除后相信我们的应用体积已经小了很多。不过这里还有个小技巧可以让我们的体积再小些。</p><p>如果我们没有使用到平台相关的依赖(Native npm modules)，我们打包后的应用里是没有 <code>node_modules</code> 文件夹的，但是难免会使用到，这时候我们还是需要打包 <code>node_modules</code> 文件夹。而发布包的作者一般也不会只打包代码，可能也会打包一些 <code>README</code> 等一些打包后不需要用到的文件。这些文件可以通过 <code>yarn</code> 提供的 <code>autoclean</code> 功能进行清除：</p><div class="language-bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#7F848E;font-style:italic;"># 初始化 yarn autoclean, 生成 .yarnclean 文件，和 .gitignore 一样，不过 .yarnclena 是声明需要清理的文件</span></span>\n<span class="line"><span style="color:#61AFEF;">yarn</span><span style="color:#98C379;"> autoclean</span><span style="color:#D19A66;"> -I</span></span>\n<span class="line"><span style="color:#7F848E;font-style:italic;"># 清理</span></span>\n<span class="line"><span style="color:#61AFEF;">yarn</span><span style="color:#98C379;"> autoclean</span><span style="color:#D19A66;"> -F</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h3 id="其他底层优化文章" tabindex="-1">其他底层优化文章 <a class="header-anchor" href="#其他底层优化文章" aria-label="Permalink to &quot;其他底层优化文章&quot;">​</a></h3><p><a href="https://blog.csdn.net/qq_42208826/article/details/107359532" target="_blank" rel="noreferrer">Electron 源码学习: Electron 程序体积裁剪（减小体积）_星空漫步者的博客-CSDN 博客_electron 体积</a></p><h3 id="依赖项-按需加载" tabindex="-1">依赖项，按需加载 <a class="header-anchor" href="#依赖项-按需加载" aria-label="Permalink to &quot;依赖项，按需加载&quot;">​</a></h3><p>检查一下依赖项的位置和引用，首先对于 package.json 中依赖项进行排查，查看 dependencies 和 devDependencies 中的依赖项有没有错位的（开发依赖项写在了生产依赖项中），由于打包时只打包 dependencies 中的依赖项，所以在生产环境中用不到的依赖项一律塞至 devDependencies。<br> 然后再检查引用库的按需加载：</p><p>如果是 webpack：可以使用<a href="https://www.npmjs.com/package/webpack-bundle-analyzer" target="_blank" rel="noreferrer">webpack-bundle-analyzer</a>可视化插件看一下依赖体积图示</p><p><img src="'+o+'" alt="image.png"></p><p>如果是 vite：就使用<a href="https://www.npmjs.com/package/rollup-plugin-visualizer" target="_blank" rel="noreferrer">rollup-plugin-visualizer</a></p><p><img src="'+p+`" alt="rollup-plugin-visualizer.jpg"></p><hr><h2 id="vite-打包优化配置" tabindex="-1">vite 打包优化配置 <a class="header-anchor" href="#vite-打包优化配置" aria-label="Permalink to &quot;vite 打包优化配置&quot;">​</a></h2><h3 id="node-modules-优化" tabindex="-1">node_modules 优化 <a class="header-anchor" href="#node-modules-优化" aria-label="Permalink to &quot;node_modules 优化&quot;">​</a></h3><p>基于<code>vite</code>项目依赖包分析插件 <code>rollup-plugin-visualizer</code>：<a href="https://www.npmjs.com/package/rollup-plugin-visualizer" target="_blank" rel="noreferrer">汇总插件可视化工具 - npm (npmjs.com)</a></p><h4 id="_1-安装-rollup-plugin-visualizer-插件" tabindex="-1">1.安装 rollup-plugin-visualizer 插件 <a class="header-anchor" href="#_1-安装-rollup-plugin-visualizer-插件" aria-label="Permalink to &quot;1.安装 rollup-plugin-visualizer 插件&quot;">​</a></h4><div class="language-bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#61AFEF;">npm</span><span style="color:#98C379;"> install</span><span style="color:#D19A66;"> --save-dev</span><span style="color:#98C379;"> rollup-plugin-visualizer</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><h4 id="_2-vite-config-ts-文件添加配置" tabindex="-1">2.vite.config.ts 文件添加配置 <a class="header-anchor" href="#_2-vite-config-ts-文件添加配置" aria-label="Permalink to &quot;2.vite.config.ts 文件添加配置&quot;">​</a></h4><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><h4 id="_3-项目打包后-打开跟目录下的-start-html-文件" tabindex="-1">3.项目打包后，打开跟目录下的 <code>start.html</code> 文件 <a class="header-anchor" href="#_3-项目打包后-打开跟目录下的-start-html-文件" aria-label="Permalink to &quot;3.项目打包后，打开跟目录下的 \`start.html\` 文件&quot;">​</a></h4><p>分析依赖大小</p><h4 id="_4-回到项目打开-package-json-文件-分析哪些是开发环境插件哪些是生产环境插件" tabindex="-1">4.回到项目打开 package.json 文件，分析哪些是开发环境插件哪些是生产环境插件 <a class="header-anchor" href="#_4-回到项目打开-package-json-文件-分析哪些是开发环境插件哪些是生产环境插件" aria-label="Permalink to &quot;4.回到项目打开 package.json 文件，分析哪些是开发环境插件哪些是生产环境插件&quot;">​</a></h4><p>分析一下打包后的文件包，在 release -&gt; 【版本号命名的文件夹】 -&gt; win-ia32-unpacked -&gt; resources 下有个 app.asar 文件，这其实是个压缩包，目的是保护代码隐私，在 build 中可配置是否需要压缩为 asar 包。<br> 在 electron-builder.yml 中加入：</p><div class="language-shell line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#61AFEF;">asar:</span><span style="color:#D19A66;"> true</span><span style="color:#98C379;">,</span><span style="color:#98C379;"> //</span><span style="color:#98C379;"> asar打包</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>用 asar 工具包解压。</p><div class="language-shell line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#7F848E;font-style:italic;"># 安装</span></span>
<span class="line"><span style="color:#61AFEF;">npm</span><span style="color:#98C379;"> install</span><span style="color:#98C379;"> asar</span><span style="color:#D19A66;"> -g</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;font-style:italic;"># 解压</span></span>
<span class="line"><span style="color:#61AFEF;">asar</span><span style="color:#98C379;"> extract</span><span style="color:#98C379;"> app.asar</span><span style="color:#ABB2BF;"> &lt;</span><span style="color:#98C379;">解压后的目</span><span style="color:#ABB2BF;">录&gt;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>解压然后看下包中有哪些内容：<br><img src="`+r+`" alt="asar"><br> dist 和 resources 是配置项中指定的需要复制打包的内容，这没有问题，可是 node_modules 中的依赖项已经在 webpack 打包构建时一同打包进了 dist 下，它不应该在这里，而且 electron-builder 配置项 files 中也没有指定复制此文件夹。带着这个疑问，查看一下<a href="https://www.electron.build/configuration/contents" target="_blank" rel="noreferrer">文档</a>，找到了原因，原来 files 有默认值：</p><div class="language-json line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#ABB2BF;">[</span></span>
<span class="line"><span style="color:#98C379;">	&quot;**/*&quot;</span><span style="color:#ABB2BF;">,</span></span>
<span class="line"><span style="color:#98C379;">	&quot;!**/node_modules/*/{CHANGELOG.md,README.md,README,readme.md,readme}&quot;</span><span style="color:#ABB2BF;">,</span></span>
<span class="line"><span style="color:#98C379;">	&quot;!**/node_modules/*/{test,__tests__,tests,powered-test,example,examples}&quot;</span><span style="color:#ABB2BF;">,</span></span>
<span class="line"><span style="color:#98C379;">	&quot;!**/node_modules/*.d.ts&quot;</span><span style="color:#ABB2BF;">,</span></span>
<span class="line"><span style="color:#98C379;">	&quot;!**/node_modules/.bin&quot;</span><span style="color:#ABB2BF;">,</span></span>
<span class="line"><span style="color:#98C379;">	&quot;!**/*.{iml,o,hprof,orig,pyc,pyo,rbc,swp,csproj,sln,xproj}&quot;</span><span style="color:#ABB2BF;">,</span></span>
<span class="line"><span style="color:#98C379;">	&quot;!.editorconfig&quot;</span><span style="color:#ABB2BF;">,</span></span>
<span class="line"><span style="color:#98C379;">	&quot;!**/._*&quot;</span><span style="color:#ABB2BF;">,</span></span>
<span class="line"><span style="color:#98C379;">	&quot;!**/{.DS_Store,.git,.hg,.svn,CVS,RCS,SCCS,.gitignore,.gitattributes}&quot;</span><span style="color:#ABB2BF;">,</span></span>
<span class="line"><span style="color:#98C379;">	&quot;!**/{__pycache__,thumbs.db,.flowconfig,.idea,.vs,.nyc_output}&quot;</span><span style="color:#ABB2BF;">,</span></span>
<span class="line"><span style="color:#98C379;">	&quot;!**/{appveyor.yml,.travis.yml,circle.yml}&quot;</span><span style="color:#ABB2BF;">,</span></span>
<span class="line"><span style="color:#98C379;">	&quot;!**/{npm-debug.log,yarn.lock,.yarn-integrity,.yarn-metadata.json}&quot;</span></span>
<span class="line"><span style="color:#ABB2BF;">]</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><div class="language-vhdl line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">vhdl</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#C678DD;">package</span><span style="color:#ABB2BF;">.json </span><span style="color:#C678DD;">and</span><span style="color:#ABB2BF;"> **/node_modules/**/* (only production dependencies will be copied) </span><span style="color:#C678DD;">is</span><span style="color:#ABB2BF;"> added </span><span style="color:#C678DD;">to</span><span style="color:#ABB2BF;"> your custom </span><span style="color:#C678DD;">in</span><span style="color:#ABB2BF;"> any </span><span style="color:#C678DD;">case</span><span style="color:#ABB2BF;">.</span></span>
<span class="line"></span>
<span class="line"><span style="color:#ABB2BF;">意思是：</span><span style="color:#C678DD;">package</span><span style="color:#ABB2BF;">.json和node_modules（仅仅生产依赖项会被复制）在任何情况下都会被添加至自定义（应该是files配置项下吧）中。</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>那这就很清楚了，我只需要在 files 中添加&quot;!node_modules&quot;即可，打包后体积是 128M，足足小了 37M，安装执行，没有问题。</p><h4 id="_5-externals-提取项目依赖" tabindex="-1">5.externals 提取项目依赖 <a class="header-anchor" href="#_5-externals-提取项目依赖" aria-label="Permalink to &quot;5.externals 提取项目依赖&quot;">​</a></h4><p>从上面的打包分析页面中可以看到，<code>chunk-vendors.js</code> 体积为 <code>2.21M</code>，其中最大的几个文件都是一些公共依赖包，那么只要把这些依赖提取出来，就可以解决 chunk-vendors.js 过大的问题</p><p>可以使用 <code>externals</code> 来提取这些依赖包，告诉 webpack 这些依赖是外部环境提供的，在打包时可以忽略它们，就不会再打到 chunk-vendors.js 中</p><p>1）vue.config.js 中配置：</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#E5C07B;">module</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">exports</span><span style="color:#56B6C2;"> =</span><span style="color:#ABB2BF;"> {</span></span>
<span class="line"><span style="color:#E06C75;">  configureWebpack</span><span style="color:#ABB2BF;">: {</span></span>
<span class="line"><span style="color:#E06C75;">    externals</span><span style="color:#ABB2BF;">: {</span></span>
<span class="line"><span style="color:#E06C75;">      vue</span><span style="color:#ABB2BF;">: </span><span style="color:#98C379;">&#39;Vue&#39;</span><span style="color:#ABB2BF;">,</span></span>
<span class="line"><span style="color:#98C379;">      &#39;vue-router&#39;</span><span style="color:#ABB2BF;">: </span><span style="color:#98C379;">&#39;VueRouter&#39;</span><span style="color:#ABB2BF;">,</span></span>
<span class="line"><span style="color:#E06C75;">      axios</span><span style="color:#ABB2BF;">: </span><span style="color:#98C379;">&#39;axios&#39;</span><span style="color:#ABB2BF;">,</span></span>
<span class="line"><span style="color:#E06C75;">      echarts</span><span style="color:#ABB2BF;">: </span><span style="color:#98C379;">&#39;echarts&#39;</span></span>
<span class="line"><span style="color:#ABB2BF;">    }</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><hr><h4 id="图片优化" tabindex="-1">图片优化 <a class="header-anchor" href="#图片优化" aria-label="Permalink to &quot;图片优化&quot;">​</a></h4><p>图片优化在整个项目的优化中是优先级较高的，所谓的图片优化，其实是体积与质量之间的博弈，因此要想减小包中图片的体积，是要牺牲一部分图片质量的，也就是清晰度。做出如下优化：</p><ul><li>首先对 gif 图在不影响用户观看的前提下做了一定压缩；</li><li>将一些 png（流程图，logo，线条简单的）转为 svg；</li><li>将一些截图 png 转为 jpg；</li></ul><p>最终将整体包体积 dmg 减小至 102M，ia32exe 为 80M 左右</p><h4 id="组件库的按需引入" tabindex="-1">组件库的按需引入 <a class="header-anchor" href="#组件库的按需引入" aria-label="Permalink to &quot;组件库的按需引入&quot;">​</a></h4><p>为什么没有使用 externals 的方式处理组件库呢？</p><p><strong>externals 缺点</strong>：直接在 html 内引入的，失去了按需引入的功能，只能引入组件库完整的 js 和 css</p><p>组件库按需引入的原理：最终只引入指定组件和对应的样式</p><p>elementUI 需要借助 babel-plugin-component 插件实现，插件的作用如下：</p><p>如按需引入 Button 组件：</p><div class="language-vue line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#ABB2BF;">import { Button } from &#39;element-ui&#39; Vue.component(Button.name, Button)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>编译后的文件（自动引入 button.css）：</p><div class="language-vue line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#ABB2BF;">import _Button from &quot;element-ui/lib/button&quot;; import _Button2 from</span></span>
<span class="line"><span style="color:#ABB2BF;">&quot;element-ui/lib/theme-chalk/button.css&quot;;</span><span style="color:#ABB2BF;"> // base.css是公共的样式 import</span></span>
<span class="line"><span style="color:#ABB2BF;">&quot;element-ui/lib/theme-chalk/base.css&quot;; Vue.component(_Button.name, _Button);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>通过该插件，最终只引入指定组件和样式，来实现减少组件库体积大小</p><p>1）安装 babel-plugin-component</p><div class="language-bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#61AFEF;">npm</span><span style="color:#98C379;"> install</span><span style="color:#98C379;"> babel-plugin-component</span><span style="color:#D19A66;"> -D</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>2）babel.config.js 中引入</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#E5C07B;">module</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">exports</span><span style="color:#56B6C2;"> =</span><span style="color:#ABB2BF;"> {</span></span>
<span class="line"><span style="color:#E06C75;">	presets</span><span style="color:#ABB2BF;">: [</span><span style="color:#98C379;">&quot;@vue/app&quot;</span><span style="color:#ABB2BF;">],</span></span>
<span class="line"><span style="color:#E06C75;">	plugins</span><span style="color:#ABB2BF;">: [</span></span>
<span class="line"><span style="color:#ABB2BF;">		[</span></span>
<span class="line"><span style="color:#98C379;">			&quot;component&quot;</span><span style="color:#ABB2BF;">,</span></span>
<span class="line"><span style="color:#ABB2BF;">			{</span></span>
<span class="line"><span style="color:#E06C75;">				libraryName</span><span style="color:#ABB2BF;">: </span><span style="color:#98C379;">&quot;element-ui&quot;</span><span style="color:#ABB2BF;">,</span></span>
<span class="line"><span style="color:#E06C75;">				styleLibraryName</span><span style="color:#ABB2BF;">: </span><span style="color:#98C379;">&quot;theme-chalk&quot;</span><span style="color:#ABB2BF;">,</span></span>
<span class="line"><span style="color:#ABB2BF;">			},</span></span>
<span class="line"><span style="color:#ABB2BF;">		],</span></span>
<span class="line"><span style="color:#ABB2BF;">	],</span></span>
<span class="line"><span style="color:#ABB2BF;">};</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><h3 id="webpack-打包优化配置" tabindex="-1">webpack 打包优化配置 <a class="header-anchor" href="#webpack-打包优化配置" aria-label="Permalink to &quot;webpack 打包优化配置&quot;">​</a></h3><h3 id="vue-项目优化配置" tabindex="-1">vue 项目优化配置 <a class="header-anchor" href="#vue-项目优化配置" aria-label="Permalink to &quot;vue 项目优化配置&quot;">​</a></h3><h3 id="react-项目优化配置" tabindex="-1">react 项目优化配置 <a class="header-anchor" href="#react-项目优化配置" aria-label="Permalink to &quot;react 项目优化配置&quot;">​</a></h3><h3 id="electron-builder-打包配置优化" tabindex="-1">electron-builder 打包配置优化 <a class="header-anchor" href="#electron-builder-打包配置优化" aria-label="Permalink to &quot;electron-builder 打包配置优化&quot;">​</a></h3><h4 id="双-package-json-配置" tabindex="-1">双 package.json 配置 <a class="header-anchor" href="#双-package-json-配置" aria-label="Permalink to &quot;双 package.json 配置&quot;">​</a></h4><p>官方重构了生产依赖项，提出双 package.json 结构（<a href="https://www.electron.build/tutorials/two-package-structure.html" target="_blank" rel="noreferrer">two package.json</a>）。顾名思义，通过两个 package.json 管理依赖项。一个用来管理开发依赖项，一个管理应用程序依赖项，最终打包时只打包应用程序依赖项。</p><ul><li><p>开发依赖</p><p>此 package.json 在项目根目录下，文件中声明开发依赖和打包脚本；</p></li><li><p>应用程序依赖；</p><p>在 app 文件夹下，声明应用程序依赖，打包时仅打包此文件中声明的依赖。所有的元字段应当在此文件声明（version，name 等）。</p></li></ul><h4 id="版本" tabindex="-1">版本 <a class="header-anchor" href="#版本" aria-label="Permalink to &quot;版本&quot;">​</a></h4><p>electron 版本也会对打包体积有影响，这里用 electron^8 和 10.1.5 小试一下，下图左为 8 版本，右为 10 版本。或许系统版本对打包体积也有影响，这里不做尝试了，有条件同学的可以试一下。</p><p><img src="`+c+`" alt="electron-version.jpg"></p><h3 id="babel-代码压缩配置" tabindex="-1">babel 代码压缩配置 <a class="header-anchor" href="#babel-代码压缩配置" aria-label="Permalink to &quot;babel 代码压缩配置&quot;">​</a></h3><h2 id="源码安全" tabindex="-1">源码安全 <a class="header-anchor" href="#源码安全" aria-label="Permalink to &quot;源码安全&quot;">​</a></h2><h3 id="asar" tabindex="-1">asar <a class="header-anchor" href="#asar" aria-label="Permalink to &quot;asar&quot;">​</a></h3><div class="language-bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#7F848E;font-style:italic;"># 安装</span></span>
<span class="line"><span style="color:#61AFEF;">npm</span><span style="color:#98C379;"> i</span><span style="color:#98C379;"> asar</span><span style="color:#D19A66;"> -g</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;"># 解压</span></span>
<span class="line"><span style="color:#61AFEF;">asar</span><span style="color:#98C379;"> eapp.asar</span><span style="color:#98C379;"> unpack</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;"># 进入解压的目录</span></span>
<span class="line"><span style="color:#56B6C2;">cd</span><span style="color:#98C379;"> unpack</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h3 id="asar-hack" tabindex="-1">ASAR Hack <a class="header-anchor" href="#asar-hack" aria-label="Permalink to &quot;ASAR Hack&quot;">​</a></h3><p><a href="https://www.zsbeike.com/technology/f787ba5a4f.html" target="_blank" rel="noreferrer">electron 审计及攻击链研究-其他-IT 技术 (zsbeike.com)</a></p><p><a href="https://www.cnblogs.com/jeason1997/p/6853737.html" target="_blank" rel="noreferrer">破解修改 Electron 软件 | 游戏 - JeasonBoy - 博客园 (cnblogs.com)</a></p><h2 id="electron-打包经验总结-技巧" tabindex="-1">electron 打包经验总结&amp;技巧 <a class="header-anchor" href="#electron-打包经验总结-技巧" aria-label="Permalink to &quot;electron 打包经验总结&amp;技巧&quot;">​</a></h2><ul><li>产品发布时版本号需升级，一般遵循 semver 语法，可以使用 npm version patch/minor/major 管理。</li><li>Windows 下需要证书签名，否则可能被杀毒软件误杀</li><li>Mac 下如果没有证书签名，无法使用 Electron 自动更新</li><li>windows 下打包可以写 nsis 逻辑修改安装包</li><li>开源软件可以基于 Travis，AppVeyor 持续集成</li></ul>`,131)]))}const g=e(t,[["render",i]]);export{B as __pageData,g as default};
