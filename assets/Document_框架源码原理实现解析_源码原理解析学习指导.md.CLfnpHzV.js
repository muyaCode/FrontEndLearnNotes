import{_ as a,C as p,c as s,o as n,ah as t,j as l,G as u,a as e,w as h}from"./chunks/framework.DqD713j2.js";const k=JSON.parse('{"title":"源码原理解析学习指导","description":"","frontmatter":{},"headers":[],"relativePath":"Document/框架源码原理实现解析/源码原理解析学习指导.md","filePath":"Document/框架源码原理实现解析/源码原理解析学习指导.md","lastUpdated":1750954157000}'),c={name:"Document/框架源码原理实现解析/源码原理解析学习指导.md"};function m(d,i,g,b,f,_){const r=p("setting"),o=p("router-link");return n(),s("div",null,[i[23]||(i[23]=t('<h1 id="源码原理解析学习指导" tabindex="-1">源码原理解析学习指导 <a class="header-anchor" href="#源码原理解析学习指导" aria-label="Permalink to &quot;源码原理解析学习指导&quot;">​</a></h1><h2 id="为什么要学习源码和底层原理" tabindex="-1">为什么要学习源码和底层原理 <a class="header-anchor" href="#为什么要学习源码和底层原理" aria-label="Permalink to &quot;为什么要学习源码和底层原理&quot;">​</a></h2><ol><li>面试需要</li><li>架构师 资深前端 <ol><li>做一些更高端和通用的事情</li><li>组件化，框架</li><li>框架源码里，有大量的最佳实践</li><li>vue 源码里，大量的工程化，设计模式，代码规范的最佳实践</li></ol></li><li>资深前端 <ol><li>除了经验丰富外</li><li>视野更高</li><li>解决诡异的 bug</li><li>架构的设计</li></ol></li></ol><h2 id="刻意练习" tabindex="-1">刻意练习 <a class="header-anchor" href="#刻意练习" aria-label="Permalink to &quot;刻意练习&quot;">​</a></h2><p>学习一个技能的最好途径，就是刻意练习，天天下象棋的村头王大爷，一定是个臭棋篓子，我天天玩王者荣耀，也是个钻石的菜比 武林高手不是天天打架就可以的，需要练习，需要专门修炼内力，以打 dota 为例</p><ol><li>任务分解 <ol><li>补刀(不带装备中路正反补 10 分钟)</li><li>装备</li><li>英雄搭配</li><li>兵线</li><li>手速 2.练习</li><li>很枯燥，自找不痛快（补刀毫无游戏乐趣）</li><li>完整的实践修炼</li></ol></li><li>反馈 4. 高手的源码 （vuejs 源码） 5. 高手点评</li></ol><h2 id="源码学习方法" tabindex="-1">源码学习方法 <a class="header-anchor" href="#源码学习方法" aria-label="Permalink to &quot;源码学习方法&quot;">​</a></h2><p>我认为源码学习分为三个层次 0. 根据 package.json 的 npm run build 逻辑找到 vue 执行的入口</p><ol><li>看一遍整体结构，比如把所有函数都折叠起来 看整体逻辑</li><li>参考测试代码，该清楚每个具体函数的输入输出，看明白逻辑</li><li>核心逻辑手写一遍 （虚拟 dom，compile，响应式等）</li><li>组内立 flag 分享，吹牛逼一次</li></ol><h2 id="如何熟读源码和手写实现" tabindex="-1">如何熟读源码和手写实现 <a class="header-anchor" href="#如何熟读源码和手写实现" aria-label="Permalink to &quot;如何熟读源码和手写实现&quot;">​</a></h2><p><a href="https://juejin.cn/post/7126095681428668424" target="_blank" rel="noreferrer">https://juejin.cn/post/7126095681428668424</a></p><h3 id="_1-找文档" tabindex="-1">1.找文档 <a class="header-anchor" href="#_1-找文档" aria-label="Permalink to &quot;1.找文档&quot;">​</a></h3><ul><li>1.官方文档 <ul><li>一般官方文档更全面更丰富，维护度也更高</li></ul></li><li>2.源码版本号很重要，不少源码随着版本迭代，发生了破坏性改动，不同版本对应的文档也不同，比如 react-router5 与 react-router6，因此看文档的时候，一定检查下你看的文档版本号和你要学习使用的源码是否一致。</li><li>3.关于文档版本号，一般可以在路由地址上或者官网首页上看到，之后再去看下 github 源码对应的版本号，确保两者一致。</li><li>4.如果找不到官方文档，可以先去 github 源码看一下，README 里通常是一份简单的文档，有些还是中英文都有的:</li><li>5.这个时候如果有官方文档，README 里会有链接指引。如果没有的话，可以查看下源码里是否有一个叫 docs 的文件夹： <ul><li>一般成熟的源码里都会有这个文件夹，里面就是文档。甚至有些源码下的 docs 比官方文档都全面。</li></ul></li><li>6.现在很多源码项目都是基于 monorepo 开发的，很多 packages 下的文件也都是独立的，看文档的时候，建议不要放过 docs 与 README。</li></ul><h3 id="_2-github-看示例代码与单元测试-测试用例" tabindex="-1">2.github 看示例代码与单元测试|测试用例 <a class="header-anchor" href="#_2-github-看示例代码与单元测试-测试用例" aria-label="Permalink to &quot;2.github 看示例代码与单元测试|测试用例&quot;">​</a></h3><ul><li>经历了文档阶段之后，再根据文档写一些 demo，相信大家对于这套源码已经掌握了至少六七分了，那么接下来想要在某一个难点上继续学习的话，可以看看别人的逻辑，比如示例代码和单元测试。</li><li>1.示例代码通常在 examples 文件夹下</li><li>2.单元测试是验证源码逻辑的代码，如果你对某个 API 用法不确定准确逻辑，可以去看看单元测试代码或者调试下试试 <ul><li>一般在 test 关键字的文件夹下</li></ul></li></ul><h3 id="_3-1-浏览器-github-插件实时看源码" tabindex="-1">3.1 浏览器 github 插件实时看源码 <a class="header-anchor" href="#_3-1-浏览器-github-插件实时看源码" aria-label="Permalink to &quot;3.1 浏览器 github 插件实时看源码&quot;">​</a></h3><h3 id="_3-2-编辑器阅读源码" tabindex="-1">3.2 编辑器阅读源码 <a class="header-anchor" href="#_3-2-编辑器阅读源码" aria-label="Permalink to &quot;3.2 编辑器阅读源码&quot;">​</a></h3><ul><li><ol><li>下载库源码文件</li></ol><ul><li><ol><li>直接下载或者 clone 克隆项目到本地</li></ol></li><li>2 CDN 或 npm 下载编译好的库源码 <ul><li>CDN <ul><li>bootcdn <ul><li><a href="https://www.bootcdn.cn/" target="_blank" rel="noreferrer">https://www.bootcdn.cn/</a></li></ul></li><li>Staticfile <ul><li><a href="https://staticfile.org/" target="_blank" rel="noreferrer">https://staticfile.org/</a></li></ul></li><li>75CDN <ul><li><a href="https://cdn.baomitu.com/" target="_blank" rel="noreferrer">https://cdn.baomitu.com/</a></li></ul></li><li>今日头条 CDN <ul><li><a href="https://cdn.bytedance.com/" target="_blank" rel="noreferrer">https://cdn.bytedance.com/</a></li></ul></li><li>cdnjs <ul><li><a href="https://cdnjs.com/" target="_blank" rel="noreferrer">https://cdnjs.com/</a></li></ul></li><li>jsDelivr <ul><li><a href="https://www.jsdelivr.com/" target="_blank" rel="noreferrer">https://www.jsdelivr.com/</a></li></ul></li></ul></li><li>npm <ul><li><a href="https://www.npmjs.com/" target="_blank" rel="noreferrer">https://www.npmjs.com/</a></li><li>npm 上可以看到 github 地址和主页</li></ul></li></ul></li></ul></li><li><ol start="2"><li>vscode 工具安装插件辅助阅读</li></ol><ul><li>要下载或者拉取源码来看看了，但是一般源码的代码量比较大，没法一次看完，所以我们可以借助一些工具来辅助阅读，vscode 上建议安装 Bookmarks、Better Comments、Git Blame 等插件。</li><li>Bookmarks <ul><li>可以打一些书签，方便记忆，下次可以快速找到某个函数或值。</li></ul></li><li>Better Comments <ul><li>可以做些颜色笔记，看起来比较醒目</li></ul></li><li>Git Blame <ul><li>则可以帮助查看源码的提交记录，注意得是远程拉取下来的代码，直接下载的不可以查看</li></ul></li></ul></li></ul><h3 id="_4-源码阅读" tabindex="-1">4.源码阅读 <a class="header-anchor" href="#_4-源码阅读" aria-label="Permalink to &quot;4.源码阅读&quot;">​</a></h3><ul><li>1.首先，我们要先区分下不同的文件夹下放的都是什么，并不是每个都要去看的 <ul><li>先看文件夹命名，命名和框架名称一致的或者叫 core、model 的基本都是核心文件</li></ul></li><li>2.文件目录下直接搜索关键字 <ul><li>比如我想看 createForm 的实现逻辑，直接搜索关键字</li></ul></li><li>3.自己思考功能的实现方式 <ul><li>不了解功能就开始读源码，那读代码会没有方向感</li><li>知道了源码有啥功能之后，要先思考下如果自己实现会怎么做。有个大概的思路就行。</li><li>如果想不通可以看下源码用到了哪些依赖库，这些依赖库都有啥功能，再想下应该怎么实现。</li><li>如果还想不通也没关系，重要的是要先自己思考下实现方式。</li></ul></li><li>4.粗读源码理清实现思路 <ul><li>你已经有了一个大概的实现思路，然后再去读源码，看下它是怎么实现的。和你思路类似的地方很快就可以掠过去，而且印象也很深，和你思路不一样的地方，通过读代码搞清楚它的实现思路。</li><li>这一步不用关心细节，知道某段代码是干啥的就行，关键是和自己的思路做 diff，理清它的整体实现思路。</li><li>不经过思考直接读源码，理解代码实现思路的效率会降低</li></ul></li><li>5.快速调试代码</li><li>5.通过 debugger 理清实现细节 <ul><li>不理清整体思路就开始 debugger，会容易陷入细节，理不清整体的思路</li><li>粗读源码理清了实现思路之后，对于一些部分的具体实现可能还不是很清楚，这时候就可以通过 debugger 来断点调试了。</li><li>构造一个能触发该功能的测试用例，在关心的代码处打一个断点，通过 debugger 运行代码。</li><li>这时候你已经知道这部分代码是干啥的了，单步调试也很容易理清每一条语句的功能，这样一条语句一条语句的搞懂之后，你就很容易能把这部分代码的实现细节理清楚。</li><li>这样一部分一部分的通过 debugger 理清细节实现之后，你就对整体代码的思路和细节的实现都有了比较好的掌握。</li><li>不 debugger 只大概理下整体思路，这样不能从细节上真正理清楚</li></ul></li><li>6.输出文章来讲述源码实现思路 <ul><li>当你觉得对源码的实现有了比较好的掌握的时候，可以输出一篇文章的方式来讲述源码的整体思路。</li><li>因为可能会有一些部分是你没注意到的，而在输出的过程中，会进行更全面的思考，这时候如果发现了一些没有读到的点，可以再通过前面几步去阅读源码，直到能清晰易懂的把源码的实现讲清楚。这样才算真正的把代码读懂了。</li><li>这就是我觉得比较高效的阅读源码的方法。</li><li>不通过输出文章来检验，那是否真的理清了整体思路和实现细节是没底的</li></ul></li><li>vue 和 react 源码阅读：<a href="https://juejin.cn/post/6903335881227108366" target="_blank" rel="noreferrer">https://juejin.cn/post/6903335881227108366</a></li></ul><h3 id="_5-手写实现" tabindex="-1">5.手写实现 <a class="header-anchor" href="#_5-手写实现" aria-label="Permalink to &quot;5.手写实现&quot;">​</a></h3><ul><li>读万卷书不如行万里路，动手写一遍</li><li>手写我通常是一步步实现，比如先写个最简单的 demo，然后把 api 全部换掉，导入换成自己手写的文件，然后再挨个实现，一边看源码，一边整理思路，直到呈现和源码一样的实现。</li><li>手写我通常是一步步实现，比如先写个最简单的 demo，然后把 api 全部换掉，换成自己手写的，然后再挨个实现，一边看源码，一边整理思路，直到呈现和源码一样的实现。</li></ul><h3 id="_6-github-issues" tabindex="-1">6.github issues <a class="header-anchor" href="#_6-github-issues" aria-label="Permalink to &quot;6.github issues&quot;">​</a></h3><ul><li>如果你发现看文档和源码的过程中，有很多困惑，甚至遇到一些 bug，可以去 issues 看看，看看大家的发言，也许就能找到答案。</li></ul><h3 id="_7-加社区群-关注核心维护者" tabindex="-1">7.加社区群，关注核心维护者 <a class="header-anchor" href="#_7-加社区群-关注核心维护者" aria-label="Permalink to &quot;7.加社区群，关注核心维护者&quot;">​</a></h3><p>文章：<a href="https://juejin.cn/column/6960551178908205093" target="_blank" rel="noreferrer">学习源码整体架构系列 - 若川的专栏 - 掘金 (juejin.cn)</a></p><h2 id="源码解析和技术实现" tabindex="-1">源码解析和技术实现 <a class="header-anchor" href="#源码解析和技术实现" aria-label="Permalink to &quot;源码解析和技术实现&quot;">​</a></h2><h3 id="vue项目开发步骤" tabindex="-1">vue项目开发步骤 <a class="header-anchor" href="#vue项目开发步骤" aria-label="Permalink to &quot;vue项目开发步骤&quot;">​</a></h3>',28)),l("ul",null,[i[7]||(i[7]=t("<li><p>1.创建项目</p></li><li><p>2.项目配置</p></li><li><p>代码编写规范</p></li><li><p>代码的质量及代码风格</p></li><li><p>2.1 项目UI框架css框架或其他框架选择使用和配置</p><ul><li>按需加载组件配置</li></ul></li><li><p>3.router.js路由设计</p></li><li><p>4.菜单路由结合</p></li><li><p>5.1 路由管理用户权限</p><ul><li><p>utils-&gt;auth.js权限模块</p><ul><li>export function getCurrentAuthority () { // 后台接口请求返回的权限逻辑 return [&#39;admin&#39;]; } export function check (authority) { const current = getCurrentAuthority () return current.some(item =&gt; authority.includes(item)) } export function isLogin (authority) { const current = getCurrentAuthority () return current &amp;&amp; current[0] !== &quot;guest&quot;; }</li></ul></li><li><p>router.js模块</p><ul><li>// 顶部导入 import findLast from &quot;lodash/findLast &quot;; import { check, isLogin } from &quot;./utils/auth &quot;; router.beforeEach(to, from, next) =&gt; { if(to.path !== from.path) { // 页面加载效果 } const record = findLast(to.matched, record =&gt; record.meta.authority) // 判断是否有权限 if(record &amp;&amp; !check(record.meta.authority)) { if(!isLogin() &amp;&amp; to.path !== &quot;/user/login&quot;) { // 写提示逻辑后跳转路由：提示逻辑自己写 next({ path: &quot;/user/login&quot; }) } else if (to.path !== &quot;/403&quot;) { // 写提示逻辑后跳转路由：提示逻辑自己写 next({ path: &quot;/403&quot; }) } // 页面加载结束逻辑 } next(); });</li></ul></li><li><p>菜单边栏组件的判断</p><ul><li>// 顶部导入方法 import { check } from &quot;../utils/auth &quot;; // 获取菜单数据方法里写判断逻辑 // item 是for循环for(let item of routers)遍历出来的菜单 if（item.meta &amp;&amp; item.meta.authority &amp;&amp; !check(record.meta.authority)）{ break; }</li></ul></li></ul></li>",8)),l("li",null,[i[6]||(i[6]=l("p",null,"5.2 权限组件和权限指令",-1)),l("ul",null,[l("li",null,[i[4]||(i[4]=l("p",null,"权限组件",-1)),l("ul",null,[i[1]||(i[1]=l("li",null,[l("p",null,"1.components组件:Authorized.vue"),l("ul",null,[l("li",null,'import { check } from "../utils/auth "; export default { props: { authority: { type: Array, required: true } }, render (h, context) { const { props, scopedSlots } = context; return check(props.authority) ? scopedSlots.default() : null; } }')])],-1)),i[2]||(i[2]=l("li",null,[l("p",null,"2.把组件注册到全局main.js"),l("ul",null,[l("li",null,'// 顶部导入 import Authorized from "./components/Authorized" // 注册到全局 Vue.component(‘Authorized’, Authorized);')])],-1)),l("li",null,[i[0]||(i[0]=l("p",null,"3.使用权限组件",-1)),l("ul",null,[l("li",null,[u(r)])])]),i[3]||(i[3]=l("li",null,[l("p",null,"优点"),l("ul",null,[l("li",null,"比较灵活")])],-1))])]),i[5]||(i[5]=t("<li><p>权限指令</p><ul><li><p>1.directives文件夹 -&gt; auth.js</p><ul><li>import { check } from &quot;../utils/auth &quot;; function install(Vue, options) = {}) { Vue.directive(options.name || &quot;auth&quot;, { inserted(el, binding) { if(!check(binding.value)) { el.parentNode &amp;&amp; el.parentNode.removeChild(el) } } }) } export default { install };</li></ul></li><li><p>2.指令全局注册 -&gt; main.js</p><ul><li>// 顶部导入 import Auth from “./directives/auth”; Vue.use(Auth)</li></ul></li><li><p>3.组件内使用定义好的权限指令</p><ul><li><p>v-auth=&quot;[&#39;admin&#39;]&quot;</p></li><li><p>显示隐藏一些需要权限的图标或组件</p></li></ul></li><li><p>弊端</p><ul><li>只有第一次成才生效，如果权限动态更改了，就不能再加回来</li></ul></li></ul></li>",1))])]),i[8]||(i[8]=t("<li><p>6.与服务端请求交互Axios配置</p><ul><li><p>1.utils文件夹 -&gt; request.js 二次封装请求</p><ul><li>import axios from &#39;axios&#39;; import { notification } from &quot;ant-design-vue&quot;; function request(options) { return axios(options).then(res =&gt; { return res; }) .catch(error =&gt; { const { response: { status, statusText } } = error; // 返回错误信息 notification.error({ // 返回渲染模板 message: h =&gt; ( 请求错误{ status } : { options.url } ), description: statusText }) return Promise.reject(error); }) } export default request;</li></ul></li><li><p>2.设置请求响应和请求拦截</p></li><li><p>3.导入页面使用</p><ul><li>import request from &#39;../../utils/request&#39; request({ url: &#39;/api/user&#39;, method: &#39;get&#39;, params: { id:123456 } }).then(res =&gt;{ if(res.code === 0){ // 请求成功逻辑 } }).catch(error){ console.log(error) }</li></ul></li></ul></li><li><p>7.使用图标和定制动态切换的主题</p></li><li><p>8.构建和打包发布</p><ul><li><p>优化项目打包构建</p><ul><li><p>组件使用babel按需加载</p></li><li><p>路由中使用webpack路由懒加载和拆包</p><ul><li>子主题 1</li></ul></li><li><p>组件中使用lodash 防抖和节流插件</p><ul><li>import { debounce } from ‘lodash’;</li></ul></li><li><p>图标的按需加载</p></li></ul></li><li><p>生成打包报告</p><ul><li><p>npm run build -- --report</p></li><li><p>会在dist文件夹内生成report.html文件</p></li></ul></li><li><p>分析哪些库需要优化</p><ul><li><p>1.浏览器 点击打开dist文件夹内report.html文件</p></li><li><p>2.分析和优化</p><ul><li>可以在组件库文档或者查询怎么优化相关包</li></ul></li></ul></li><li><p>构建配置优化</p></li></ul></li><li><p>9.组件的单元测试</p><ul><li><p>jest.config.js单元测试配置</p></li><li><p>.eslintrc.js配置</p></li><li><p>组件或js目录下新建如 auth.js 的单元测试文件：例子：以.spec.js结尾：auth.spec.js</p><ul><li>import { check, currentAuth } from &quot;./auth&quot;; decribe(&quot;auth test&quot;, () =&gt; { it(&quot;empty auth&quot;, () =&gt; { currentAuth.splice(0, currentAuth.length); expect(check([&#39;user&#39;])).toEqual(false); expect(check([&#39;admin&#39;])).toEqual(false); }) it(&quot;user auth&quot;, () =&gt; { currentAuth.splice(0, currentAuth.length); currentAuth.push(&quot;user&quot;) expect(check([&#39;user&#39;])).toEqual(true); expect(check([&#39;admin&#39;])).toEqual(false); }) it(&quot;admin auth&quot;, () =&gt; { currentAuth.push(&quot;admin&quot;) expect(check([&#39;user&#39;])).toEqual(true); expect(check([&#39;admin&#39;])).toEqual(true); expect(check([&#39;user&#39;], [&#39;admin&#39;])).toEqual(true); }) })</li></ul></li><li><p>3.开启单元测试</p><ul><li>npm run test:unit -- --watch</li></ul></li></ul></li><li><p>10.组件发布到npm</p></li><li><p>11.代码提交git规范</p></li>",6))]),i[24]||(i[24]=t('<h3 id="代码调试和debugger" tabindex="-1">代码调试和debugger <a class="header-anchor" href="#代码调试和debugger" aria-label="Permalink to &quot;代码调试和debugger&quot;">​</a></h3><ul><li><p>代码调试</p><ul><li><a href="https://juejin.cn/collection/7072953319152418829" target="_blank" rel="noreferrer">https://juejin.cn/collection/7072953319152418829</a></li></ul></li><li><p>开发调试</p><ul><li><a href="https://juejin.cn/collection/7052539028234567688" target="_blank" rel="noreferrer">https://juejin.cn/collection/7052539028234567688</a></li></ul></li><li><p>前后端联调</p><ul><li><a href="https://juejin.cn/collection/7061786423799578637" target="_blank" rel="noreferrer">https://juejin.cn/collection/7061786423799578637</a></li></ul></li></ul><h3 id="源码解析" tabindex="-1">源码解析 <a class="header-anchor" href="#源码解析" aria-label="Permalink to &quot;源码解析&quot;">​</a></h3>',3)),l("ul",null,[i[21]||(i[21]=t('<li><p>如何熟读源码和手写实现</p><ul><li><p><a href="https://juejin.cn/post/7126095681428668424" target="_blank" rel="noreferrer">https://juejin.cn/post/7126095681428668424</a></p></li><li><ol><li>找文档</li></ol><ul><li><p>1.官方文档</p><ul><li>一般官方文档更全面更丰富，维护度也更高</li></ul></li><li><p>2.源码版本号很重要，不少源码随着版本迭代，发生了破坏性改动，不同版本对应的文档也不同，比如react-router5与react-router6，因此看文档的时候，一定检查下你看的文档版本号和你要学习使用的源码是否一致。</p></li><li><p>3.关于文档版本号，一般可以在路由地址上或者官网首页上看到，之后再去看下github源码对应的版本号，确保两者一致。</p></li><li><p>4.如果找不到官方文档，可以先去github源码看一下，README里通常是一份简单的文档，有些还是中英文都有的:</p></li><li><p>5.这个时候如果有官方文档，README里会有链接指引。如果没有的话，可以查看下源码里是否有一个叫docs的文件夹：</p><ul><li>一般成熟的源码里都会有这个文件夹，里面就是文档。甚至有些源码下的docs比官方文档都全面。</li></ul></li><li><p>6.现在很多源码项目都是基于monorepo开发的，很多packages下的文件也都是独立的，看文档的时候，建议不要放过docs与README。</p></li></ul></li><li><ol start="2"><li>github看示例代码与单元测试|测试用例</li></ol><ul><li><p>经历了文档阶段之后，再根据文档写一些demo，相信大家对于这套源码已经掌握了至少六七分了，那么接下来想要在某一个难点上继续学习的话，可以看看别人的逻辑，比如示例代码和单元测试。</p></li><li><p>1.示例代码通常在examples文件夹下</p></li><li><p>2.单元测试是验证源码逻辑的代码，如果你对某个API用法不确定准确逻辑，可以去看看单元测试代码或者调试下试试</p><ul><li>一般在test关键字的文件夹下</li></ul></li></ul></li><li><p>3.1 浏览器github插件实时看源码</p></li><li><p>3.2 编辑器阅读源码</p><ul><li><ol><li>下载库源码文件</li></ol><ul><li><ol><li>直接下载或者clone克隆项目到本地</li></ol></li><li><p>2 CDN或npm下载编译好的库源码</p><ul><li><p>CDN</p><ul><li><p>bootcdn</p><ul><li><a href="https://www.bootcdn.cn/" target="_blank" rel="noreferrer">https://www.bootcdn.cn/</a></li></ul></li><li><p>Staticfile</p><ul><li><a href="https://staticfile.org/" target="_blank" rel="noreferrer">https://staticfile.org/</a></li></ul></li><li><p>75CDN</p><ul><li><a href="https://cdn.baomitu.com/" target="_blank" rel="noreferrer">https://cdn.baomitu.com/</a></li></ul></li><li><p>今日头条 CDN</p><ul><li><a href="https://cdn.bytedance.com/" target="_blank" rel="noreferrer">https://cdn.bytedance.com/</a></li></ul></li><li><p>cdnjs</p><ul><li><a href="https://cdnjs.com/" target="_blank" rel="noreferrer">https://cdnjs.com/</a></li></ul></li><li><p>jsDelivr</p><ul><li><a href="https://www.jsdelivr.com/" target="_blank" rel="noreferrer">https://www.jsdelivr.com/</a></li></ul></li><li><p>unpkg</p><ul><li><a href="https://unpkg.com/" target="_blank" rel="noreferrer">https://unpkg.com/</a></li></ul></li></ul></li><li><p>npm</p><ul><li><p><a href="https://www.npmjs.com/" target="_blank" rel="noreferrer">https://www.npmjs.com/</a></p></li><li><p>npm上可以看到github地址和主页</p></li></ul></li></ul></li></ul></li><li><ol start="2"><li>vscode工具安装插件辅助阅读</li></ol><ul><li><p>要下载或者拉取源码来看看了，但是一般源码的代码量比较大，没法一次看完，所以我们可以借助一些工具来辅助阅读，vscode上建议安装Bookmarks、Better Comments、Git Blame等插件。</p></li><li><p>Bookmarks</p><ul><li>可以打一些书签，方便记忆，下次可以快速找到某个函数或值。</li></ul></li><li><p>Better Comments</p><ul><li>可以做些颜色笔记，看起来比较醒目</li></ul></li><li><p>Git Blame</p><ul><li>则可以帮助查看源码的提交记录，注意得是远程拉取下来的代码，直接下载的不可以查看</li></ul></li></ul></li></ul></li><li><ol start="4"><li>源码阅读</li></ol><ul><li><p>1.首先，我们要先区分下不同的文件夹下放的都是什么，并不是每个都要去看的</p><ul><li>先看文件夹命名，命名和框架名称一致的或者叫core、model的基本都是核心文件</li></ul></li><li><p>2.文件目录下直接搜索关键字</p><ul><li>比如我想看createForm的实现逻辑，直接搜索关键字</li></ul></li><li><p>3.自己思考功能的实现方式</p><ul><li><p>不了解功能就开始读源码，那读代码会没有方向感</p></li><li><p>知道了源码有啥功能之后，要先思考下如果自己实现会怎么做。有个大概的思路就行。</p></li><li><p>如果想不通可以看下源码用到了哪些依赖库，这些依赖库都有啥功能，再想下应该怎么实现。</p></li><li><p>如果还想不通也没关系，重要的是要先自己思考下实现方式。</p></li></ul></li><li><p>4.粗读源码理清实现思路</p><ul><li><p>你已经有了一个大概的实现思路，然后再去读源码，看下它是怎么实现的。和你思路类似的地方很快就可以掠过去，而且印象也很深，和你思路不一样的地方，通过读代码搞清楚它的实现思路。</p></li><li><p>这一步不用关心细节，知道某段代码是干啥的就行，关键是和自己的思路做 diff，理清它的整体实现思路。</p></li><li><p>不经过思考直接读源码，理解代码实现思路的效率会降低</p></li></ul></li><li><p>5.快速调试代码</p></li><li><p>5.通过 debugger 理清实现细节</p><ul><li><p>不理清整体思路就开始 debugger，会容易陷入细节，理不清整体的思路</p></li><li><p>粗读源码理清了实现思路之后，对于一些部分的具体实现可能还不是很清楚，这时候就可以通过 debugger 来断点调试了。</p></li><li><p>构造一个能触发该功能的测试用例，在关心的代码处打一个断点，通过 debugger 运行代码。</p></li><li><p>这时候你已经知道这部分代码是干啥的了，单步调试也很容易理清每一条语句的功能，这样一条语句一条语句的搞懂之后，你就很容易能把这部分代码的实现细节理清楚。</p></li><li><p>这样一部分一部分的通过 debugger 理清细节实现之后，你就对整体代码的思路和细节的实现都有了比较好的掌握。</p></li><li><p>不 debugger 只大概理下整体思路，这样不能从细节上真正理清楚</p></li></ul></li><li><p>6.输出文章来讲述源码实现思路</p><ul><li><p>当你觉得对源码的实现有了比较好的掌握的时候，可以输出一篇文章的方式来讲述源码的整体思路。</p></li><li><p>因为可能会有一些部分是你没注意到的，而在输出的过程中，会进行更全面的思考，这时候如果发现了一些没有读到的点，可以再通过前面几步去阅读源码，直到能清晰易懂的把源码的实现讲清楚。这样才算真正的把代码读懂了。</p></li><li><p>这就是我觉得比较高效的阅读源码的方法。</p></li><li><p>不通过输出文章来检验，那是否真的理清了整体思路和实现细节是没底的</p></li></ul></li><li><p>vue和react源码阅读</p><ul><li><a href="https://juejin.cn/post/6903335881227108366" target="_blank" rel="noreferrer">https://juejin.cn/post/6903335881227108366</a></li></ul></li></ul></li><li><p>5.手写实现</p><ul><li><p>读万卷书不如行万里路，动手写一遍</p></li><li><p>手写我通常是一步步实现，比如先写个最简单的demo，然后把api全部换掉，导入换成自己手写的文件，然后再挨个实现，一边看源码，一边整理思路，直到呈现和源码一样的实现。</p></li><li><p>手写我通常是一步步实现，比如先写个最简单的demo，然后把api全部换掉，换成自己手写的，然后再挨个实现，一边看源码，一边整理思路，直到呈现和源码一样的实现。</p></li></ul></li><li><ol start="6"><li>github issues</li></ol><ul><li>如果你发现看文档和源码的过程中，有很多困惑，甚至遇到一些bug，可以去issues看看，看看大家的发言，也许就能找到答案。</li></ul></li><li><ol start="7"><li>加社区群，关注核心维护者</li></ol></li></ul></li><li><p>源码学习活动</p><ul><li><a href="https://juejin.cn/post/7079706017579139102" target="_blank" rel="noreferrer">https://juejin.cn/post/7079706017579139102</a></li></ul></li><li><p>源码架构学习文章</p><ul><li><a href="https://juejin.cn/column/6960551178908205093" target="_blank" rel="noreferrer">https://juejin.cn/column/6960551178908205093</a></li></ul></li><li><p>jQuery源码解析</p></li><li><p>vue2源码解析</p><ul><li><p>vue2库github地址</p><ul><li><a href="https://github.com/vuejs/vue" target="_blank" rel="noreferrer">https://github.com/vuejs/vue</a></li></ul></li><li><p>vue2源码解析</p><ul><li><p><a href="https://github.com/qq281113270/vue" target="_blank" rel="noreferrer">https://github.com/qq281113270/vue</a></p></li><li><p><a href="https://www.cnblogs.com/chandlerwong/p/16145224.html" target="_blank" rel="noreferrer">https://www.cnblogs.com/chandlerwong/p/16145224.html</a></p></li></ul></li><li><p>块解析</p><ul><li>computed和watch区别</li></ul></li></ul></li><li><p>vue3源码解析</p><ul><li><p>vue3库github地址</p><ul><li><a href="https://github.com/vuejs/core" target="_blank" rel="noreferrer">https://github.com/vuejs/core</a></li></ul></li><li><p>实现最简 vue3 模型</p><ul><li><a href="https://github.com/cuixiaorui/mini-vue" target="_blank" rel="noreferrer">https://github.com/cuixiaorui/mini-vue</a></li></ul></li></ul></li><li><p>petite-vue源码解析</p><ul><li><p>github</p><ul><li><a href="https://github.com/vuejs/petite-vue" target="_blank" rel="noreferrer">https://github.com/vuejs/petite-vue</a></li></ul></li><li><p>petite-vue源码解析文档</p><ul><li><a href="http://fsjohnhuang.gitee.io/petite-vue-source-reading/" target="_blank" rel="noreferrer">http://fsjohnhuang.gitee.io/petite-vue-source-reading/</a></li></ul></li></ul></li>',7)),l("li",null,[i[20]||(i[20]=l("p",null,"vue-router源码解析",-1)),l("ul",null,[i[19]||(i[19]=t('<li><p>源码地址</p><ul><li><p>vue-router库github地址</p><ul><li><a href="https://github.com/vuejs/vue-router" target="_blank" rel="noreferrer">https://github.com/vuejs/vue-router</a></li></ul></li><li><p>CDN</p><ul><li><a href="https://unpkg.com/vue-router@4.0.15/dist/vue-router.global.js" target="_blank" rel="noreferrer">https://unpkg.com/vue-router@4.0.15/dist/vue-router.global.js</a></li></ul></li><li><p>官网</p><ul><li><a href="https://router.vuejs.org/zh/installation.html" target="_blank" rel="noreferrer">https://router.vuejs.org/zh/installation.html</a></li></ul></li></ul></li><li><p>vue-router实现原理文档</p><ul><li><p><a href="https://www.jianshu.com/p/b85a89ca1d98" target="_blank" rel="noreferrer">https://www.jianshu.com/p/b85a89ca1d98</a></p></li><li><p><a href="https://www.cnblogs.com/cokolxvd/p/15726669.html" target="_blank" rel="noreferrer">https://www.cnblogs.com/cokolxvd/p/15726669.html</a></p></li></ul></li><li><p>实现原理</p><ul><li><p>vue-router实现了再不跳转页面的情况下更新视图，也就是只有一个页面</p></li><li><p>vue-router的三种模式</p><ul><li><p>history模式</p><ul><li><p>概述</p><ul><li><p>html5标准中，为 history 添加了pushState()、replaceState()方法，以及 onpopstate 事件。但原理和 hash 方式是相同的</p></li><li><p>history模式并不会向服务器发送请求，是因为vue-cli对history模式做了处理</p></li><li><p>通过 history模式 实现单页路由的 URL 没有 #。但因为没有 # ，所以当用户刷新页面之类的操作时，浏览器还是会给服务器发送请求</p></li><li><p>为了避免出现这种情况，所以这个实现需要服务器的支持，需要把所有路由都重定向到根页面</p></li></ul></li><li><p>底层实现原理</p><ul><li><p>​ 登录 桌面 <hr> let login=document.querySelector(&#39;#login&#39;) let content=document.querySelector(&#39;#content&#39;) login.addEventListener(&#39;click&#39;,function(e){ e.preventDefault(); history.pushState({name:&#39;loginname&#39;},&#39;login&#39;,&#39;/login&#39;) content.innerHTML=&quot;登录&quot; }) let desk=document.querySelector(&#39;#desk&#39;) desk.addEventListener(&#39;click&#39;,function(e){ e.preventDefault(); history.pushState({name:&#39;deskname&#39;},&#39;desk&#39;,&#39;/desk&#39;) content.innerHTML=&quot;桌面&quot; }) window.onpopstate=function(e){ let name=e.state.name if(name==&#39;loginname&#39;){ content.innerHTML=&quot;这是登录&quot; }else{ content.innerHTML=&quot;这是桌面&quot; } }</p><ul><li><p>history.pushState()</p></li><li><p>路径就是普通的url，通过history.pushState()方法来改变地址栏，并把当前地址记录在浏览器的访问历史中，并不会真正的跳到指定的路径，也就是浏览器不会向服务器发送请求。</p></li><li><p>通过监听popstate事件，可以监听到浏览器历史操作的变化，在popstate事件中可以记录浏览器地址栏改变后的地址，要注意的是，调用history.pushSate()和history.replaceState()不会触发popstate事件，只有点击浏览器的前进后退按钮及调用history.forward()、history.back()、history.go()方法时才会触发popstate事件。</p></li><li><p>最后通过路由找到对应的组件，渲染在浏览器中</p></li></ul></li></ul></li></ul></li><li><p>hash模式</p><ul><li><p>概述</p><ul><li><p>是以url中#后面的内容作为路由地址，可以直接通过location.url来切换浏览器的地址，如果只改变了#后面的内容，浏览器不会向服务器请求这个地址，但是会把这个地址记录在浏览器的访问记录中，当hash改变后，要监听hash的变化，并做相应的处理，我们可以监听hashchange事件，当hash发生变化时，会触发hashchange事件，在hashchange事件中记录当前路由地址，并找到当前路由对应的组件，重新渲染在浏览器中</p></li><li><p>hash模式实现的路由地址有 #</p></li><li><p>#后面的内容不会传给服务端，也就是说不会重新刷新页面，并且路由切换的时候也不会重新加载页面。</p></li><li><p>hash必须和原先的值不同，才能新增会话浏览历史的记录。</p></li></ul></li><li><p>底层实现原理</p><ul><li>​ 登录 桌面 <hr> let content= document.querySelector(&#39;#content&#39;) window.onhashchange=function(e){ console.log(window.history.state) let {newURL}=e if(newURL.endsWith(&#39;#/login&#39;)){ content.innerHTML=&#39;这是登录内容&#39; } else if(newURL.endsWith(&#39;#/desk&#39;)){ content.innerHTML=&#39;这是桌面内容&#39; } }</li></ul></li></ul></li><li><p>abstract模式</p><ul><li><p>概述</p><ul><li><p>支持所有JavaScript运行环境，如Node.js服务器端。</p></li><li><p>abstract模式是使用一个不依赖于浏览器的浏览历史虚拟管理后端。</p></li><li><p>根据平台差异可以看出，在 Weex 环境中只支持使用 abstract 模式。 不过，vue-router 自身会对环境做校验，如果发现没有浏览器的 API，vue-router 会自动强制进入 abstract 模式，所以 在使用 vue-router 时只要不写 mode 配置即可，默认会在浏览器环境中使用 hash 模式，在移动端原生环境中使用 abstract 模式。 （当然，你也可以明确指定在所有情况下都使用 abstract 模式）。</p></li></ul></li></ul></li></ul></li></ul></li>',3)),l("li",null,[i[18]||(i[18]=l("p",null,"手写router路由 (简单思路)",-1)),l("ul",null,[i[17]||(i[17]=l("li",null,[l("p",null,"需求分析"),l("ul",null,[l("li",null,[l("p",null,"作为一个插件存在：实现vue-router类和install方法")]),l("li",null,[l("p",null,"实现两个全局组件：router-view用于显示匹配组件内容，router-link用于跳转")]),l("li",null,[l("p",null,"监控url变化：监听hashchange或者popstate事件")]),l("li",null,[l("p",null,"响应最新url：创建一个响应式的属性current，当它改变时获取对应组件并显示")])])],-1)),l("li",null,[i[16]||(i[16]=l("p",null,"源码实现 src\\krouter",-1)),l("ul",null,[i[13]||(i[13]=l("li",null,[l("p",null,"index.js应用路由"),l("ul",null,[l("li",null,`import Vue from 'vue' import VueRouter from './kvue-router' import Home from '../views/Home.vue' // 1.应用插件 Vue.use(VueRouter) const routes = [ { path: '/', name: 'home', component: Home }, { path: '/about', name: 'about', // route level code-splitting // this generates a separate chunk (about.[hash].js) for this route // which is lazy-loaded when the route is visited. component: () => import(/* webpackChunkName: "about" */ '../views/About.vue') } ] // 2.创建实例 const router = new VueRouter({ mode: 'history', base: process.env.BASE_URL, routes }) export default router`)])],-1)),i[14]||(i[14]=l("li",null,[l("p",null,"krouter-router.js实现"),l("ul",null,[l("li",null,"import Link from './krouter-link' import View from './krouter-view' let Vue; // 1.实现一个插件：挂载$router class KVueRouter { constructor(options) { this.$options = options console.log(this.$options); // 需要创建响应式的current属性 // 利用Vue提供的defineReactive做响应化 // 这样将来current变化的时候，依赖的组件会重新render Vue.util.defineReactive(this, 'current', '/') // this.app = new Vue({ // data() { // return { // current: '/' // } // } // }) // 监控url变化 window.addEventListener('hashchange', this.onHashChange.bind(this)) window.addEventListener('load', this.onHashChange.bind(this)) // 创建一个路由映射表 this.routeMap = {} options.routes.forEach(route => { this.routeMap[route.path] = route }) } onHashChange() { console.log(window.location.hash); this.current = window.location.hash.slice(1) } } KVueRouter.install = function (_Vue) { // 保存构造函数，在KVueRouter里面使用 Vue = _Vue; // 挂载$router // 怎么获取根实例中的router选项 Vue.mixin({ beforeCreate() { // 确保根实例的时候才执行 if (this.$options.router) { Vue.prototype.$router = this.$options.router } } }) // 任务2：实现两个全局组件router-link和router-view Vue.component('router-link', Link) Vue.component('router-view', View) } export default KVueRouter")])],-1)),l("li",null,[i[12]||(i[12]=l("p",null,"krouter-link.js实现",-1)),l("ul",null,[l("li",null,[i[10]||(i[10]=e("export default { props: { to: { type: String, required: true }, }, render(h) { // abc // ")),u(o,{to:"/about"},{default:h(()=>i[9]||(i[9]=[e("xxx")])),_:1,__:[9]}),i[11]||(i[11]=e(" // h(tag, data, children) console.log(this.$slots); return h('a', { attrs: { href: '#' + this.to } }, this.$slots.default) // return {this.$slots.default} } }"))])])]),i[15]||(i[15]=l("li",null,[l("p",null,"krouter-view.js实现"),l("ul",null,[l("li",null,"export default { render(h) { //获取path对应的component const {routeMap, current} = this.$router; console.log(routeMap,current); const component = routeMap[current].component || null; return h(component) } }")])],-1))])])])])])]),i[22]||(i[22]=t('<li><p>vuex源码解析</p><ul><li><p>vuex库github地址</p><ul><li><a href="https://github.com/vuejs/vuex" target="_blank" rel="noreferrer">https://github.com/vuejs/vuex</a></li></ul></li><li><p>实现原理文档</p><ul><li><a href="https://www.cnblogs.com/crazycode2/p/13458804.html" target="_blank" rel="noreferrer">https://www.cnblogs.com/crazycode2/p/13458804.html</a></li></ul></li><li><p>前置介绍</p><ul><li><p>实现原理</p><ul><li>采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化</li></ul></li><li><p>Vuex的构成</p><ul><li><p>1）state</p><ul><li>state是存储的单一状态，是存储的基本数据。</li></ul></li><li><p>2）Getters</p><ul><li>getters是store的计算属性，对state的加工，是派生出来的数据。就像computed计算属性一样，getter返回的值会根据它的依赖被缓存起来，且只有当它的依赖值发生改变才会被重新计算。</li></ul></li><li><p>3）Mutations</p><ul><li>mutations提交更改数据，使用store.commit方法更改state存储的状态。（mutations同步函数）</li></ul></li><li><p>4）Actions</p><ul><li>actions像一个装饰器，提交mutation，而不是直接变更状态。（actions可以包含任何异步操作）</li></ul></li><li><p>5）Module</p><ul><li>Module是store分割的模块，每个模块拥有自己的state、getters、mutations、actions。</li></ul></li><li><p>以上使用例子</p><ul><li>const moduleA = { state: { ... }, mutations: { ... }, actions: { ... }, getters: { ... } } const moduleB = { state: { ... }, mutations: { ... }, actions: { ... } } const store = new Vuex.Store({ modules: { a: moduleA, b: moduleB } }) store.state.a // -&gt; moduleA 的状态 store.state.b // -&gt; moduleB 的状态</li></ul></li><li><p>6）辅助函数</p><ul><li>Vuex提供了mapState、MapGetters、MapActions、mapMutations等辅助函数给开发在vm中处理store。</li></ul></li></ul></li><li><p>Vuex的使用</p><ul><li>import Vuex from &#39;vuex&#39;; Vue.use(Vuex); // 1. vue的插件机制，安装vuex let store = new Vuex.Store({ // 2.实例化store，调用install方法 state, getters, modules, mutations, actions, plugins }); new Vue({ // 3.注入store, 挂载vue实例 store, render: h=&gt;h(app) }).$mount(&#39;#app&#39;);</li></ul></li><li><p>Vuex的设计思想</p><ul><li>Vuex的设计思想，借鉴了Flux、Redux，将数据存放到全局的store，再将store挂载到每个vue实例组件中，利用Vue.js的细粒度数据响应机制来进行高效的状态更新</li></ul></li></ul></li><li><p>手写vuex状态管理</p><ul><li><p>需求分析</p><ul><li><p>vuex的store是如何挂载注入到组件中</p></li><li><p>vuex的state和getters是如何映射到各个组件实例中响应式更新状态</p></li><li><p>浅层次实现</p></li></ul></li><li><p>源码实现 src\\kstore</p><ul><li><p>index.js使用vuex</p><ul><li>import Vue from &#39;vue&#39; import Vuex from &#39;./kvuex&#39; Vue.use(Vuex) export default new Vuex.Store({ state: { counter: 0 }, getters: { doubleCounter(state) { return state.counter * 2 } }, mutations: { add(state) { state.counter++ // this.state } }, actions: { // 结构上下文 add({ commit }) { setTimeout(() =&gt; { commit(&#39;add&#39;) }, 1000); } }, modules: { } })</li></ul></li><li><p>kvuex.js实现vuex</p><ul><li>// 保存构造函数引用，避免import let Vue; class Store { constructor(options) { // this.$options = options; this._mutations = options.mutations; this._actions = options.actions; // 响应化处理state // this.state = new Vue({ // data: options.state // }) this._vm = new Vue({ data: { // 加两个$，Vue不做代理 $$state: options.state } }) // 绑定commit、dispatch的上下文问store实例 this.commit = this.commit.bind(this) this.dispatch = this.dispatch.bind(this) } // 存取器， store.state get state() { console.log(this._vm); return this._vm._data.$$state } set state(v) { console.error(&#39;你造吗？你这样不好！&#39;); } // store.commit(&#39;add&#39;, 1) // type: mutation的类型 // payload：载荷，是参数 commit(type, payload) { const entry = this._mutations[type] if (entry) { entry(this.state, payload) } } dispatch(type, payload) { const entry = this._actions[type] if (entry) { entry(this, payload) } } } function install(_Vue) { Vue = _Vue; Vue.mixin({ beforeCreate() { if (this.$options.store) { Vue.prototype.$store = this.$options.store } } }) } // Vuex export default { Store, install }</li></ul></li></ul></li></ul></li></ul></li><li><p>Pinia 状态管理源码解析</p><ul><li><p>Pinia 状态管理库github地址</p><ul><li><a href="https://github.com/vuejs/pinia" target="_blank" rel="noreferrer">https://github.com/vuejs/pinia</a></li></ul></li><li><p>Pinia 状态管理源码解析</p></li></ul></li><li><p>element UI源码解析</p></li>',3))]),i[25]||(i[25]=t('<h3 id="项目实战" tabindex="-1">项目实战 <a class="header-anchor" href="#项目实战" aria-label="Permalink to &quot;项目实战&quot;">​</a></h3><ul><li><p>Vue移动书城实现</p><ul><li><p>文档和源码</p><ul><li><p>阅读器文档</p><ul><li><p>商业级web阅读器项目（上）</p><ul><li><a href="https://blog.csdn.net/weixin_43964148/article/details/101169465" target="_blank" rel="noreferrer">https://blog.csdn.net/weixin_43964148/article/details/101169465</a></li></ul></li><li><p>商业级web阅读器项目（下）</p><ul><li><a href="https://blog.csdn.net/weixin_43964148/article/details/102321907" target="_blank" rel="noreferrer">https://blog.csdn.net/weixin_43964148/article/details/102321907</a></li></ul></li></ul></li><li><p>源码</p><ul><li><p><a href="https://github.com/Wangyanjunai/node-novel-ebook" target="_blank" rel="noreferrer">https://github.com/Wangyanjunai/node-novel-ebook</a></p></li><li><p><a href="https://github.com/sunday2146/vue-novel-ebook" target="_blank" rel="noreferrer">https://github.com/sunday2146/vue-novel-ebook</a></p></li></ul></li></ul></li><li><p>功能</p><ul><li><p>书架</p><ul><li><p>私密阅读</p></li><li><p>离线阅读</p></li><li><p>分组</p></li><li><p>移除书架</p></li></ul></li><li><p>阅读器</p><ul><li><p>阅读器支持格式</p><ul><li><p>txt</p><ul><li>txt是纯文件文件，它无法支持多媒体格式，小说类应用中使用较多，但无法满足电子出版物的需求；</li></ul></li><li><p>pdf</p><ul><li><p>PDF是非常主流的电子书格式，但是在移动端下排版效果不佳，所以移动阅读很少采用PDF格式；</p></li><li><p>PDF.js</p><ul><li><p><a href="https://github.com/mozilla/pdf.js" target="_blank" rel="noreferrer">https://github.com/mozilla/pdf.js</a></p></li><li><p><a href="http://mozilla.github.io/pdf.js/" target="_blank" rel="noreferrer">http://mozilla.github.io/pdf.js/</a></p></li></ul></li></ul></li><li><p>epub</p><ul><li><p>ePub是目前最主流的电子书格式，电子书内容采用html显示，由css控制样式，不论在PC端还是移动端都有非常好的显示效果，不足之处在于文件容量较大，而且解析时需要解压，会消耗性能，可以借助本地缓存技术来缓解这个问题；</p></li><li><p>本质上是一个zip文件，可以通过 在cmd中 用unzip进行解压</p></li><li><p>epub.js库</p><ul><li><p><a href="https://github.com/futurepress/epub.js" target="_blank" rel="noreferrer">https://github.com/futurepress/epub.js</a></p></li><li><p><a href="http://futurepress.org/" target="_blank" rel="noreferrer">http://futurepress.org/</a></p></li></ul></li><li><p>完整的ePub阅读器的开发流程</p><ul><li><p>解析：获取图书的基本信息、目录信息、章节信息等</p></li><li><p>渲染：在界面上展示电子书内容，支持屏幕尺寸自适应</p></li><li><p>翻页：支持上一页和下一页的翻页操作</p></li><li><p>字号：支持修改文字的字号大小</p></li><li><p>字体：支持修改文字的字体，能够支持CSS3的Web字体</p></li><li><p>主题：支持切换阅读器的背景色和文字颜色</p></li><li><p>进度：支持动态切换阅读器的显示进度</p></li><li><p>目录：支持多级目录展示，点击目录快速跳转到指定章节</p></li><li><p>搜索：支持全文搜索和章节搜索</p></li><li><p>书签：支持将当前的阅读位置保存为书签，并能回溯</p></li><li><p>笔记：支持选中一段文本后加入笔记</p></li><li><p>适配：针对PC端和移动端进行专门的适配处理</p></li></ul></li><li><p>安装</p><ul><li>npm install --save epubjs</li></ul></li></ul></li><li><p>mobi</p><ul><li>mobi是亚马逊Kindle的电子书格式，需要在Kindle中阅读。</li></ul></li></ul></li><li><p>阅读器功能</p><ul><li><p>解析</p><ul><li>获取图书的基本信息、目录信息、章节信息等</li></ul></li><li><p>渲染</p><ul><li>在界面上展示电子书内容，支持屏幕尺寸自适应</li></ul></li><li><p>翻页效果</p><ul><li><p>实现各种复杂手势+交互动画，如何兼容手势+鼠标操作</p></li><li><p>效果</p><ul><li><p>覆盖</p></li><li><p>滑动</p></li><li><p>仿真</p></li><li><p>滚动</p></li><li><p>无动画</p></li></ul></li><li><p>翻页功能的实现</p><ul><li><p>当屏幕向左划时，向上翻页，反之翻下一页</p></li><li><p>//监听滑动翻页事件 this.rendition.on(&quot;touchstart&quot;,event=&gt;{ this.touchStartX = event.changedTouches[0].clientX; this.touchStartTime = event.timeStamp; }); this.rendition.on(&quot;touchend&quot;,event=&gt;{ const offsetX = event.changedTouches[0].clientX-this.touchStartX; const time = event.timeStamp - this.touchStartTime; if(time&lt;500 &amp;&amp; offsetx&gt;40){ this.prevPage(); }else if (time&lt;500 &amp;&amp; offsetX&lt;-40) { this.nextPage(); }else{ this.toggleTitleAndMenu() } })</p></li><li><p>// 上一页下一页 prevPage(){ if (this.rendition){ this.rendition.prev(); // this.$store.dispatch(&quot;setMenuVisible&quot;,false) this.setMenuVisible(false); } }, nextPage(){ if (this.rendition){ this.rendition.next(); // this.$store.dispatch(&quot;setMenuVisible&quot;,false) this.setMenuVisible(false); } },</p></li></ul></li></ul></li><li><p>字</p><ul><li><p>字号UI的设置</p></li><li><p>字体</p></li><li><p>缩进</p></li><li><p>边距</p></li><li><p>繁简</p></li><li><p>文字颜色和背景(长按自定义)</p></li></ul></li><li><p>主题</p><ul><li><p>支持切换阅读器的背景色和文字颜色</p></li><li><p>白天黑夜主题切换</p></li></ul></li><li><p>阅读进度</p><ul><li>支持动态切换阅读器的显示进度</li></ul></li><li><p>目录章节</p><ul><li>支持多级目录展示，点击目录快速跳转到指定章节</li></ul></li><li><p>搜索</p><ul><li><p>全文搜索</p></li><li><p>章节搜索</p></li></ul></li><li><p>书签</p><ul><li><p>支持将当前的阅读位置保存为书签，并能回溯</p></li><li><p>书签手势操作</p></li></ul></li><li><p>笔记</p><ul><li>支持选中一段文本后加入笔记</li></ul></li><li><p>朗读</p><ul><li><p>利用vuex+mixin实现组件解耦+复用</p></li><li><p>科大讯飞web在线语音合成API开发</p></li></ul></li></ul></li></ul></li><li><p>书城</p><ul><li><p>搜索</p><ul><li><p>历史搜索</p></li><li><p>热门搜索</p></li></ul></li><li><p>浏览</p></li><li><p>推荐</p></li></ul></li><li><p>详情</p><ul><li><p>基本信息</p></li><li><p>目录结构</p></li><li><p>加入书架</p></li><li><p>阅读本书</p></li></ul></li><li><p>听书</p><ul><li><p>语音合成</p></li><li><p>播放器</p></li><li><p>内容预览</p></li></ul></li><li><p>适配</p><ul><li><p>viewport配置</p><ul><li><div class="language-html line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#ABB2BF;">&lt;</span><span style="color:#E06C75;">meta</span><span style="color:#D19A66;"> name</span><span style="color:#ABB2BF;">=</span><span style="color:#98C379;">&quot;viewport&quot;</span><span style="color:#D19A66;"> content</span><span style="color:#ABB2BF;">=</span><span style="color:#98C379;">&quot;width=device-width,initial-scale=1.0,maximum-scale=1.0,minimum-scale=1.0,user-scalable=no&quot;</span><span style="color:#ABB2BF;">&gt;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div></li></ul></li><li><p>rem设置+自适应布局实现思路</p><ul><li><p>global.scss和reset.scss设置</p></li><li><p>在App.vue中编写script代码</p></li><li><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki one-dark-pro vp-code" tabindex="0"><code><span class="line"><span style="color:#C678DD;"> export</span><span style="color:#C678DD;"> default</span><span style="color:#ABB2BF;"> {      </span><span style="color:#E06C75;">name</span><span style="color:#ABB2BF;">:</span><span style="color:#98C379;">&quot;App&quot;</span><span style="color:#ABB2BF;">  }  </span><span style="color:#E5C07B;">document</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">addEventListener</span><span style="color:#ABB2BF;">(</span><span style="color:#98C379;">&#39;DOMContentLoaded&#39;</span><span style="color:#ABB2BF;">, () </span><span style="color:#C678DD;">=&gt;</span><span style="color:#ABB2BF;"> {      </span><span style="color:#C678DD;">const</span><span style="color:#E5C07B;"> html</span><span style="color:#56B6C2;"> =</span><span style="color:#E5C07B;"> document</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">querySelector</span><span style="color:#ABB2BF;">(</span><span style="color:#98C379;">&#39;html&#39;</span><span style="color:#ABB2BF;">)      </span><span style="color:#E06C75;">let</span><span style="color:#E06C75;"> fontSize</span><span style="color:#56B6C2;"> =</span><span style="color:#E5C07B;"> window</span><span style="color:#ABB2BF;">.</span><span style="color:#E06C75;">innerWidth</span><span style="color:#56B6C2;"> /</span><span style="color:#D19A66;"> 10</span><span style="color:#E06C75;">      fontSize</span><span style="color:#56B6C2;"> =</span><span style="color:#E06C75;"> fontSize</span><span style="color:#56B6C2;"> &gt;</span><span style="color:#D19A66;"> 50</span><span style="color:#C678DD;"> ?</span><span style="color:#D19A66;"> 50</span><span style="color:#C678DD;"> :</span><span style="color:#E06C75;"> fontSize</span><span style="color:#E5C07B;">      html</span><span style="color:#ABB2BF;">.</span><span style="color:#E5C07B;">style</span><span style="color:#ABB2BF;">.</span><span style="color:#E06C75;">fontSize</span><span style="color:#56B6C2;"> =</span><span style="color:#E06C75;"> fontSize</span><span style="color:#56B6C2;"> +</span><span style="color:#98C379;"> &#39;px&#39;</span><span style="color:#ABB2BF;">  })</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div></li><li></li></ul></li></ul></li></ul></li><li><p>技术栈</p><ul><li><p>uniapp基于Vue3语法技术栈</p><ul><li>vue全家桶</li></ul></li><li><p>css</p><ul><li><p>字体图标</p></li><li><p>动画</p></li><li><p>less</p></li><li><p>rem</p></li></ul></li><li><p>html5</p><ul><li><p>range控件</p></li><li><p>audio控件</p></li><li><p>localStorage</p></li><li><p>IndexedDB</p></li><li><p>离线存储机制设计：LocalStorage+IndexDB</p></li></ul></li><li><p>JavaScript</p><ul><li><p>ES6</p></li><li><p>mock.js</p></li><li><p>touch、mouse事件</p></li><li><p>axios</p></li></ul></li><li><p>发布</p><ul><li><p>Git</p></li><li><p>Node.js</p></li><li><p>服务器</p></li><li><p>Nginx</p></li></ul></li></ul></li><li><p>接口功能</p></li></ul></li><li><p>Vue实现移动音乐应用</p><ul><li><p>页面</p><ul><li><p>推荐页面</p><ul><li><p>banner轮播图</p></li><li><p>热门歌单列表</p><ul><li><p>歌单标题</p></li><li><p>歌单的歌曲操作</p><ul><li>播放全部</li></ul></li><li><p>歌单的歌曲列表</p><ul><li><p>歌名</p></li><li><p>歌手</p></li></ul></li></ul></li></ul></li><li><p>歌手页面</p><ul><li><p>歌手</p><ul><li><p>头像</p></li><li><p>名字</p></li></ul></li><li><p>右边按字母排序的跳转</p></li><li><p>歌手详情页</p><ul><li><p>歌名</p></li><li><p>歌手</p></li></ul></li></ul></li><li><p>歌手详情页</p></li><li><p>播放器页面</p><ul><li><p>播放器内核</p><ul><li>子主题 1</li></ul></li><li><p>功能</p><ul><li><p>随机播放</p></li><li><p>切换上一首</p></li><li><p>切换下一首</p></li><li><p>暂停和播放</p></li><li><p>歌曲收藏和喜欢</p></li><li><p>播放进度</p></li><li><p>播放长度</p></li><li><p>歌词显示</p></li><li><p>封面显示</p></li></ul></li></ul></li><li><p>歌单页面</p></li><li><p>排行榜页面</p></li><li><p>榜单列表页面</p></li><li><p>搜索页面</p><ul><li><p>热门搜索</p></li><li><p>搜索历史</p><ul><li><p>单个删除</p></li><li><p>全部删除</p></li></ul></li><li><p>搜索关键词实时检索歌曲和歌手</p></li></ul></li><li><p>歌曲列表页</p></li><li><p>用户中心页</p></li></ul></li><li><p>技术栈实现</p><ul><li><p>vue3技术栈</p></li><li><p>UI库</p></li><li><p>状态管理</p><ul><li>pina</li></ul></li><li><p>路由</p><ul><li>vuex</li></ul></li><li><p>服务端交互</p><ul><li>axios</li></ul></li><li><p>效果插件</p></li><li><p>工具支持</p><ul><li><p>脚手架</p><ul><li><p>vue-cli</p></li><li><p>vite</p></li></ul></li><li><p>自动化构建</p><ul><li>webpack</li></ul></li><li><p>代码格式检查</p><ul><li>eslint</li></ul></li></ul></li></ul></li></ul></li><li><p>移动影视应用开发</p></li></ul><h3 id="实现效果" tabindex="-1">实现效果 <a class="header-anchor" href="#实现效果" aria-label="Permalink to &quot;实现效果&quot;">​</a></h3><ul><li><p>单点登录的三种实现方式</p><ul><li><a href="https://juejin.cn/post/7124197782256091143" target="_blank" rel="noreferrer">https://juejin.cn/post/7124197782256091143</a></li></ul></li><li><p>子主题 2</p></li></ul><h3 id="算法题" tabindex="-1">算法题 <a class="header-anchor" href="#算法题" aria-label="Permalink to &quot;算法题&quot;">​</a></h3><ul><li>算法学习 <ul><li><a href="https://101.zoo.team/" target="_blank" rel="noreferrer">https://101.zoo.team/</a></li></ul></li></ul><h3 id="建立属于自己的前端组件库" tabindex="-1">建立属于自己的前端组件库 <a class="header-anchor" href="#建立属于自己的前端组件库" aria-label="Permalink to &quot;建立属于自己的前端组件库&quot;">​</a></h3><ul><li><p><a href="https://juejin.cn/post/7124487017588588574" target="_blank" rel="noreferrer">https://juejin.cn/post/7124487017588588574</a></p></li><li><p>技术栈</p><ul><li>vite3、vitepress、vitest、vue3、tsx</li></ul></li><li><p>微脚手架用于</p><ul><li><p>生成组件开发模版</p></li><li><p>组件文档模版</p></li><li><p>生成组件主题文件</p></li><li><p>打包发布npm</p></li></ul></li><li><p>使用 vitepress 生成组件文档</p><ul><li>githup Actions 结合 githup pages 自动部署</li></ul></li><li><p>组件库组件主题切换实现</p></li></ul><h3 id="github开源项目的运营的相关生态" tabindex="-1">GitHub开源项目的运营的相关生态 <a class="header-anchor" href="#github开源项目的运营的相关生态" aria-label="Permalink to &quot;GitHub开源项目的运营的相关生态&quot;">​</a></h3><ul><li><p>CI持续集成</p><ul><li><p><a href="https://travis-ci.org/" target="_blank" rel="noreferrer">https://travis-ci.org/</a></p></li><li><p><a href="https://circleci.com/" target="_blank" rel="noreferrer">https://circleci.com/</a></p></li></ul></li><li><p>单测覆盖率</p><ul><li><p><a href="https://codecov.io/" target="_blank" rel="noreferrer">https://codecov.io/</a></p></li><li><p><a href="https://coverall.io/" target="_blank" rel="noreferrer">https://coverall.io/</a></p></li></ul></li><li><p>开源文档托管</p><ul><li><p>github.io</p></li><li><p>gitee.io</p></li><li><p><a href="https://www.netlify.com/" target="_blank" rel="noreferrer">https://www.netlify.com/</a></p><ul><li>静态文档托管</li></ul></li><li><p>自己的域名和服务器</p></li></ul></li><li><p>issue 管理</p><ul><li><p>issue 开源解决方案</p><ul><li><p><a href="https://github.com/offu/close-issue-app" target="_blank" rel="noreferrer">https://github.com/offu/close-issue-app</a></p></li><li><p><a href="https://github.com/lee-dohm/no-response" target="_blank" rel="noreferrer">https://github.com/lee-dohm/no-response</a></p></li></ul></li><li><p>issue-helper参考</p><ul><li><a href="https://vuecomponent.github.io/issue-helper" target="_blank" rel="noreferrer">https://vuecomponent.github.io/issue-helper</a></li></ul></li><li><p>issue 关闭解决方案</p><ul><li><a href="https://github.com/dessant/lock-threads" target="_blank" rel="noreferrer">https://github.com/dessant/lock-threads</a></li></ul></li></ul></li></ul>',10))])}const y=a(c,[["render",m]]);export{k as __pageData,y as default};
